\documentclass[12pt]{scrartcl}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{ wasysym }
\usepackage{accents}
\usepackage{extpfeil}
\usepackage{graphicx}
\usepackage[dvipsnames]{xcolor}
\usepackage[a4paper,top=5mm, bottom=5mm, left=10mm, right=2mm]{geometry}
%Markup
\newcommand{\TYPE}[1]{\textcolor{NavyBlue}{\mathtt{#1}}}
\newcommand{\FUNC}[1]{\textcolor{Cerulean}{\mathtt{#1}}}
\newcommand{\LOGIC}[1]{\textcolor{Blue}{\mathtt{#1}}}
\newcommand{\THM}[1]{\textcolor{Maroon}{\mathtt{#1}}}
%META
\renewcommand{\.}{\; . \;}
\newcommand{\de}{: \kern 0.1pc =}
\newcommand{\extract}{\LOGIC{Extract}}
\newcommand{\where}{\LOGIC{where}}
\newcommand{\If}{\LOGIC{if} \;}
\newcommand{\Then}{ \; \LOGIC{then} \;}
\newcommand{\Else}{\; \LOGIC{else} \;}
\newcommand{\IsNot}{\; ! \;}
\newcommand{\Is}{ \; : \;}
\newcommand{\DefAs}{\; :: \;}
\newcommand{\Act}[1]{\left( #1 \right)}
\newcommand{\Example}{\LOGIC{Example} \; }
\newcommand{\Theorem}[2]{& \THM{#1} \, :: \, #2 \\ & \Proof = \\ } 
\newcommand{\DeclareType}[2]{& \TYPE{#1} \, :: \, #2 \\} 
\newcommand{\DefineType}[3]{& #1 : \TYPE{#2} \iff #3 \\} 
\newcommand{\DefineNamedType}[4]{& #1 : \TYPE{#2} \iff #3 \iff #4 \\} 
\newcommand{\DeclareFunc}[2]{& \FUNC{#1} \, :: \, #2 \\}  
\newcommand{\DefineFunc}[3]{&  \FUNC{#1}\Act{#2} \de #3 \\} 
\newcommand{\DefineNamedFunc}[4]{&  \FUNC{#1}\Act{#2} = #3 \de #4 \\} 
\newcommand{\NewLine}{\\ & \kern 1pc}
\newcommand{\Page}[1]{ \begin{align*} #1 \end{align*}   }
\newcommand{ \bd }{ \ByDef }
\newcommand{\NoProof}{ & \ldots \\ \EndProof}
%LOGIC
\renewcommand{\And}{\; \& \;}
\newcommand{\ForEach}[3]{\forall #1 : #2 \. #3 }
\newcommand{\Exist}[2]{\exists #1 : #2}
%TYPE THEORY
\newcommand{\DFunc}[3]{\prod #1 : #2 \. #3 }
\newcommand{\DPair}[3]{\sum #1 : #2 \. #3}
\newcommand{\Type}{\TYPE{Type}}
\newcommand{\Class}{\TYPE{Kind}}
%%STD
\newcommand{\Int}{\mathbb{Z} }
\newcommand{\NNInt}{\mathbb{Z}_{+} }
\newcommand{\Reals}{\mathbb{R} }
\newcommand{\Complex}{\mathbb{C}}
\newcommand{\Rats}{\mathbb{Q} }
\newcommand{\Nat}{\mathbb{N} }
\newcommand{\EReals}{\stackrel{\mathclap{\infty}}{\mathbb{R}}}
\newcommand{\ERealsn}[1]{\stackrel{\mathclap{\infty}}{\mathbb{R}}^{#1}}
\DeclareMathOperator*{\centr}{center}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\id}{id}
\DeclareMathOperator*{\im}{Im}
\DeclareMathOperator*{\supp}{supp}
\newcommand{\EqClass}[1]{\TYPE{EqClass}\left( #1 \right)}
\newcommand{\Cat}{\TYPE{Category}}
\newcommand{\Mor}{\mathcal{M}}
\newcommand{\Obj}{\mathcal{O}}
\newcommand{\Endo}{\mathrm{End}}
\newcommand{\Aut}{\mathrm{Aut}}
\newcommand{\Func}[2]{\TYPE{Functor}\left( #1, #2 \right)}
\mathchardef\hyph="2D
\newcommand{\Surj}[2]{\TYPE{Surjective}\left( #1, #2 \right)}
\newcommand{\ToInj}{\hookrightarrow}
\newcommand{\ToMono}{\xhookrightarrow}
\newcommand{\ToSurj}{\twoheadrightarrow}
\newcommand{\ToEpi}{\xtwoheadrightarrow}
\newcommand{\ToBij}{\leftrightarrow}
\newcommand{\ToIso}{\xleftrightarrow}
\newcommand{\Arrow}{\xrightarrow}
\newcommand{\Set}{\TYPE{Set}}
\newcommand{\du}{\; \triangle \;}
\renewcommand{\c}{\complement}
%%ProofWritting
\newcommand{\Say}[3]{& #1 \de #2 : #3, \\}
\newcommand{\Conclude}[3]{& #1 \de #2 : #3; \\}
\newcommand{\Derive}[3]{& \leadsto #1 \de #2 : #3, \\}
\newcommand{\DeriveConclude}[3]{& \leadsto #1 \de #2 : #3 ; \\} 
\newcommand{\Assume}[2]{& \LOGIC{Assume} \; #1 : #2, \\}
\newcommand{\As}{\; \LOGIC{as } \;} 
\newcommand{\QED}{\; \square}
\newcommand{\EndProof}{& \QED \\}
\newcommand{\ByDef}{\eth} 
\newcommand{\ByConstr}{\jmath}  
\newcommand{\Alt}{\LOGIC{Alternative} \;}
\newcommand{\CL}{\LOGIC{Close} \;}
\newcommand{\More}{\LOGIC{Another} \;}
\newcommand{\Proof}{\LOGIC{Proof} \; }
%CategoryTheorey
%Types
\newcommand{\Cov}{\TYPE{Covariant}}
\newcommand{\Contra}{\TYPE{Contravariant}}
\newcommand{\NT}{\TYPE{NaturalTransform}}
\newcommand{\UMP}{\TYPE{UnversalMappingProperty}}
\newcommand{\CMP}{\TYPE{CouniversalMappingProperty}}
\newcommand{\paral}{\rightrightarrows}
%functions
\newcommand{\op}{\mathrm{op}}
\newcommand{\obj}{\mathrm{obj}}
\DeclareMathOperator*{\dom}{dom}
\DeclareMathOperator*{\codom}{codom}
\DeclareMathOperator*{\colim}{colim}
%variable
\newcommand{\C}{\mathcal{C}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\B}{\mathcal{B}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\I}{\mathcal{I}}
\newcommand{\J}{\mathcal{J}}
\newcommand{\R}{\mathrm{R}}
%Cats
\newcommand{\CAT}{\mathsf{CAT}}
\newcommand{\SET}{\mathsf{SET}}
\newcommand{\PARALLEL}{\bullet \paral \bullet}
\newcommand{\WEDGE}{\bullet \to \bullet \leftarrow \bullet}
\newcommand{\VEE}{\bullet \leftarrow \bullet \to \bullet}
\author{Uncultured Tramp} 
\title{Category Theory}
\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\section{Basic Concepts of Category Theory }
\subsection{Definition}
\Page{
	\DeclareType{Category}{? \sum \mathcal{O} : \Class \. \sum \mathcal{M} : 
			\mathcal{O} \times \mathcal{O} \to \Class \. 
			\NewLine \. 
			\sum  c : \prod A,B,C \in \mathcal{O} \. 
			\mathcal{M}(A,B) \times \mathcal{M}(B,C) \to \mathcal{M}(A,C) \.
			\sum I : \prod A \in \mathcal{O} \. \mathcal{M}(A,A)   
		}
	\DefineType{\C}{Category}{ \forall A,B,C,D \in \mathcal{O} \. \forall f \in \mathcal{M}(A,B) \. 
		\forall g \in \mathcal{M}(B,C) \. \forall h \in \mathcal{M}(C,D) \. \NewLine \. 
		c\Big(f, I(A)\Big) = f = c\Big(I(A),f\Big)  \And c(c(f,g),h) = c(f,c(g,h))    }
	\\
	\DeclareFunc{objects}{\Cat \to \Class}
	\DefineNamedFunc{objects}{\C}{\Obj_{\C}}{\Obj \kern 1pc \where \kern 1pc \C = ( \Obj,\Mor, c, I  ) }	
	\\
	\DeclareFunc{morphisms}{\prod \C : \Cat \. \Obj_\C \times \Obj_\C \to \Class }
	\DefineNamedFunc{morphisms}{A,B}{\Mor_{\C}(A,B)}{ \Mor(A,B)  \kern 1pc \where \kern 1pc \C = (\Obj,\Mor, c, I)   }
	\\
	\DeclareFunc{compositionLaw}{\prod \C : \Cat \. \left( \prod A,B,C \in \Obj_\C \. \Mor_\C(A,B) \times \Mor_\C(B,C) \to
		\Mor_\C(A,C) \right)  
	}
	\DefineFunc{compositionLaw}{\C}{c \kern 1pc \where \kern 1pc \C = (\Obj, \Mor, c, i)}
	\\
	\DeclareFunc{composeInCat}{\prod \C : \Cat \. \prod A,B,C \in \Obj_\C \. 
		\Mor_\C(A,B) \times \Mor_\C(B,C) \to \Mor_\C(A,C) }
	\DefineNamedFunc{composeInCat}{f,g}{fg}{\FUNC{compostionLae}(\C)(f,g)}
	\\
	\DeclareFunc{idMorphism}{\prod \C : \Cat \. \prod A \in \Obj_\C \. \Mor(A,A)}
	\DefineNamedFunc{idMorphism}{A}{\id_A}{I(A) \kern 1pc \where \kern 1pc \C = (\Obj,\Mor,c,I)}
	\\
	\DeclareType{InCat}{ \Cat \to \Type  }
	\DefineNamedType{a}{InCat}{\Lambda \C : \Cat \. a \in \C }{ \Lambda \C : \Cat \. a \in \Obj_\C  }
	\\
	\Theorem{CategoriesAsKinds}{\forall \C : \Cat \. \big(\C,\TYPE{InCat}(\C)\big) : \Class }
	\NoProof
	\\
	\DeclareType{RealInCat}{\Cat \to \Type}
	\DefineNamedType{f}{realInCat}{ \Lambda \C : \Cat \. f \in \overrightarrow{\C}}{\Lambda \C : \Cat \. \exists A,B \in \Obj_\C :
		f \in \Mor_\C(A,B)} 
	\\
	\Theorem{CorrectCategoriesAsKinds}{\forall C : \Cat \. \big(\C,\TYPE{RealInCat}(\C)\big) : \Class}
	\NoProof
	\\
} \Page{
	\DeclareFunc{domain}{\prod \C : \Cat \. \overrightarrow{\C} \to \Set(\C)}
	\DefineNamedFunc{domain}{f}{\dom f}{ \{ A \in \C : \exists B \in \C . f \in \Mor_\C(A,B) \}   }
	\\
	\DeclareFunc{codomain}{\prod \C : \Cat \. \overrightarrow{\C} \to \Set(\C)}
	\DefineNamedFunc{codomain}{f}{\codom f}{ \{ B \in \C : \exists B \in \C \. f \in \Mor_\C(B,A) \} }
	\\
	\DeclareType{Arrow}{\prod C : \Cat \. ?(\C \times \C \times \overrightarrow{\C})}
	\DefineNamedType{(A,B,f)}{Arrow}{f : A \xrightarrow{\C} B}{f \in \Mor_{\C}(A,B)}
	\\
	\DeclareType{Small}{?\Cat}
	\DefineType{\C}{Small}{\exists O,M : \Set \. \Obj_\C = O \And \overrightarrow{C} = M  }
	\\
	\DeclareType{LocallySmall}{?\Cat}
	\DefineType{\C}{LocallySmall}{\forall A,B \in \C \. \exists M : \Set \. \Mor_\C(A,B) = M}
	\\
	\DeclareType{Preorder}{?\TYPE{LocallySmall}}
	\DefineType{\C}{Preorder}{ \forall A,B \in \C \. |\Mor_\C(A,B)| \le 1}
	\\
	\DeclareType{Identity}{\prod \C \in \Cat \. \prod A \in \C \. ? \Mor_\C(A,A)}
	\DefineType{e}{Identity}{\Big(\forall X \in \C \. \forall f \in \Mor_\C(X,A) \. fe = f \Big)
		\And \Big( \forall Y \in \C \. \forall f \in \Mor_\C(A,Y) \. ef = f\Big)}
	\\
	\Theorem{ IdentityIsUnique }{ \forall \C \in \Cat \. \forall A \in \C \. \exists! e : \TYPE{Identity}(\C)(A)  }
	&  \text{Use the fact that an identity element is unique in monoids.} \\
	\EndProof
	\\
	\DeclareType{Connected}{?\Cat}
	\DefineType{\C}{Connected}{\forall A,B \in \C \. \exists n \in \Nat : \exists X : n \to \C \. 
		X_1 = A \And X_n = B \And  \NewLine \And \forall i \in (n-1) \. (\exists X_i \Arrow{\C} X_{i+1}) | 
		(\exists X_{i+1} \Arrow{\C} X_i)
	}
	\\
	\DeclareType{Discrete}{?\Cat}
	\DefineType{\C}{Discrete}{\forall A,B \in \C \. A =B \Rightarrow \Mor_\C(A,B) = \{ {\id}_A \} \And 
		A \neq B \Rightarrow \Mor_\C(A,B) = \emptyset}
	\\
	\DeclareType{Antidiscret}{\TYPE{LocallySmall}}
	\DefineType{\C}{Antidiscrete}{\forall A,B \in \C \. \# \Mor_\C(A,B) = 1}
	\\
	\DeclareFunc{unitCategory}{\Cat}
	\DefineNamedFunc{unitCategory}{}{\mathbf{1}}{\Big(\{ 1  \}, 1 \mapsto \{ 1 \}, (1,1) \mapsto 1, 1 \mapsto 1\Big)}
}
\newpage
\subsection{Types of Morphisms}
\Page{
	\DeclareType{Inverse}{\prod \C : \Cat \. \prod A, B \in \C \. (A \xleftrightarrow{\C} B) \to 
		?(B \xleftrightarrow{\C} A) }
	\DefineType{g}{Inverse}{\Lambda f : A \xleftrightarrow{\C} B \. fg = \id_{A} \And gf = \id_{B} }
	\\
	\DeclareType{Isomorphism}{\prod \C : \Cat \. \prod  A, B \in \C \. ?\Big(A \xrightarrow{\C} B\Big) }
	\DefineNamedType{f}{ Isomorphism  }{f : A \xleftrightarrow{\C} B}
	{ \exists g : B \xrightarrow{\C} A \.  g : \TYPE{Inverse}(f) }
	\\
	\DeclareType{Isomorphic}{\prod \C : \Cat \.   ?( \C \times \C )   }
	\DefineNamedType{(A,B)}{Isomorphic}{A \cong B}{\exists f  : A \xleftrightarrow{\C} B }
	\\
	\Conclude{\FUNC{Endomorphism}(A)}{  \Endo_{\C}(A) = \mathcal{M}_{\C}(A,B)  }{  \prod \C : \Cat \.  \C  \to \Class }
	\\
	\Conclude{\FUNC{Automorphism}(A)}{ \Aut_{\C}(A) =  A \xleftrightarrow{\C} A   }{\prod \C : \Cat \. \C \to \Class}
	\\
	\DeclareType{Groupoid}{ ? \Cat}
	\DefineType{\C}{Groupoid}{\forall A,B \in \C \. \forall f : A \xrightarrow{\C} B \. f : A \xleftrightarrow{\C} B  }
	\\
	\DeclareType{Subcategory}{\TYPE{Small} \to ?\TYPE{Small}}
	\DefineNamedType{\mathcal{S}}{Subcategry}{\Lambda \C : \Cat \. \mathcal{S} \subset \C}{ 
		\Obj_{\mathcal{S}} \subset \C \And \forall A,B \in \mathcal{S} \.  
		\Mor_{\mathcal{S}}(A,B) \subset  \Mor_{\C}(A,B)    }
	\\
	\DeclareFunc{maximalGroupoid}{\Cat \to \TYPE{Groupoid}}
	\DefineFunc{maximalGroupoid}{ (\Obj,\Mor,c,I) }{ \Big( \Obj, \TYPE{Isomorphism}(\mathcal{C}),c, I \Big) }
	\\
	\Theorem{InverseIsUnique}{ \forall f : \TYPE{Isomorphism}(\C)(A,B) \. 
		\exists! \TYPE{Inverse}(f)   }
	\Assume{g,h}{ \TYPE{Inverse}(f)  }
	\Say{(1)}{\bd \TYPE{Inverse}(f)(g)}{ fg = \id }
	\Say{(2)}{ h(1) }{hfg = h}
	\Say{(3)}{\bd \TYPE{Inverse}(h)(f)}{ hf = \id }
	\Conclude{(4)}{(2)(3)}{ g = h }
	\DeriveConclude{(*)}{I(\exists!)\bd \TYPE{Isomorphism}(\C)(A,B)(f)}{\exists! \TYPE{Inverse}(f)}
	\EndProof
	\\
	\DeclareFunc{inverse}{\prod \C : \Cat \. \prod A,B \in \C \. \prod f : A \ToIso{\C} B \. \TYPE{Inverse}(f)}
	\DefineNamedFunc{inverse}{}{f^{-1}}{ \THM{InverseIsUniq}(f)  }
}\Page{
	\DeclareFunc{CatSliceUnder}{ \prod \C : \Cat \. \C \to \Cat}
	\DefineNamedFunc{CatSliceUnder}{ A }{\frac{\C}{A}}{ \Bigg( \sum X \in C \. \Mor_\C(A,X), 
		\Big((X,f),(Y,g)\Big) \mapsto \Big\{ h : X \xrightarrow{\C} Y | fh = g  \Big\}, \NewLine , 
		\FUNC{compositionLaw}(\C), (X,f) \mapsto \id_X  \Bigg)  }
	\\
	\DeclareFunc{CatSliceOver}{ \prod \C : \Cat \. \C \to \Cat}
	\DefineNamedFunc{CatSliceOver}{ A }{\frac{A}{\C}}{ \Bigg( \sum X \in C \. \Mor_\C(X,A), 
		\Big((X,f),(Y,g)\Big) \mapsto \Big\{ h : X \xrightarrow{\C} Y | hf = g  \Big\}, \NewLine , 
		\FUNC{compositionLaw}(\C), (X,f) \mapsto \id_X  \Bigg)  }
	\\
	\DeclareType{Monic}{\prod \C : \Cat \. \prod A, B \in \C \. ?(A \xrightarrow{\C} B)}
	\DefineNamedType{f}{Monic}{f : A \xhookrightarrow{\C} B}{\forall X \in \C \. \forall g, h : X \xrightarrow{\C} A \.
		gf = hf \Rightarrow g = h  }
	\\
	\DeclareType{Epic}{\prod \C : \Cat \. \prod A,B \in \C \. ?(A \xrightarrow{\C} B)}
	\DefineNamedType{f}{Epic}{ f : A \ToEpi{\C} B}{\forall X \in \C \. \forall g,h : B \xrightarrow{\C} X \. 
		fg = fh \Rightarrow g = h} 
	\\
	\DeclareType{Section}{\prod \C : \Cat \. \prod A, B \in \C \. (A \xrightarrow{\C} B) \to 
		?(B \Arrow{\C} A) }
	\DefineType{g}{Section}{\Lambda f : A \xrightarrow{\C} B \. gf = \id_B}
	\\
	\DeclareType{Retraction}{ \prod \C : \Cat \. \prod A, B \in \C \. (A \xrightarrow{\C} B) \to 
		?(B \Arrow{\C} A) }
	\DefineType{g}{Retraction}{\Lambda f : A \xrightarrow{\C} B \. fg = \id_A}
	\\
	\DeclareType{SplitMono}{\prod \C : \Cat \. \prod A, B \in \C \. ?(A \xrightarrow{\C} B)}
	\DefineType{f}{SplitMono}{ \exists \TYPE{Retraction}(f)}
	\\
	\DeclareType{SplitEpic}{\prod \C : \Cat \. \prod A,B \in \C \. ?(A \xrightarrow{\C} B)}
	\DefineType{f}{SplitEpic}{\exists \TYPE{Section}(f)}
	\\
	\DeclareType{idempotent}{\prod \C : \Cat \. \prod A \in \C \. \Endo_\C(A) }
	\DefineType{f}{idempotent}{ ff = f}
}\Page{
	\Theorem{SplitMonoIsMono}{\forall f : \TYPE{SplitMono}(\C)(A,B) \. f : A \ToMono{\C} B}
	\Say{r}{\bd \TYPE{SplitMono}(f)}{\TYPE{Retraction}(r)}
	\Say{(1)}{\bd \TYPE{Retraction}(f)(r)}{  fr = \id_A   }
	\Assume{X}{\C}
	\Assume{g,h}{X \Arrow{\C} A}
	\Assume{(2)}{gf = hf}
	\Conclude{()}{(1)((2)r)(1)}{g = gfr = hfr = h}
	\DeriveConclude{(*)}{\bd^{-1} \TYPE{Mono}(\C)(A,B)}{\Big( f : A \ToMono{\C} B  \Big)}
	\EndProof
	\\
	\Theorem{SplitEpicIsEpic}{\forall f : \TYPE{SplitEpic}(\C)(A,B) \. f : A \ToEpi{\C} B}
	\Say{s}{\bd \TYPE{SplitEpic}(f)}{\TYPE{Section}(r)}
	\Say{(1)}{\bd \TYPE{Section}(f)(s)}{  sf = \id_A   }
	\Assume{Y}{\C}
	\Assume{g,h}{B \Arrow{\C} Y}
	\Assume{(2)}{fg = fh}
	\Conclude{()}{(1)(s(2))(1)}{g = sfg = sfh = h}
	\DeriveConclude{(*)}{\bd^{-1} \TYPE{Epic}(\C)(A,B)}{\Big( f : A \ToEpi{\C} B  \Big)}
	\EndProof
	\\
	\Theorem{LeftRightInverse}{\forall f : A \Arrow{\C} B \. \forall s : \TYPE{Section}(f) \. 
		\forall r : \TYPE{Retraction}(f) \. s = r }
	\Say{(1)}{\bd \TYPE{Retraction}(f)(r)}{ fr = \id }
	\Say{(2)}{ s(1) }{sfr = s}
	\Say{(3)}{\bd \TYPE{Section}(f)(s)}{ sf = \id }
	\Conclude{(*)}{(2)(3)}{ s = r }
	\EndProof
	\\
	\Theorem{IsoBySplit}{\forall f : \TYPE{SplitMono} \And \TYPE{SplitEpic}(\C)(A,B) \. f : A \ToIso{\C} B}
	\Say{r}{\bd \TYPE{SplitMono}(f)}{\TYPE{Retraction}(f)}
	\Say{s}{\bd \TYPE{SplitEpic}(f)}{\TYPE{Section}(f)}
	\Say{(1)}{\THM{LeftRightInverse}(f,s,r)}{s = r}
	\Say{(2)}{\bd^{-1}\TYPE{Inverse}(f) \bd \TYPE{Retraction}(f)(r)(1)\bd\TYPE{Section}(f)(s)}
	{\Big[ r : \TYPE{Inverse}(f) \Big]}
	\Conclude{(*)}{\bd^{-1} \TYPE{Iso}(2)}{ \Big[ f : A \ToIso{\C} B  \Big] }
	\EndProof
}
\newpage
\subsection{Functors}
\Page{
	\DeclareType{Covariant}{ \prod \mathcal{A},\mathcal{B} : \Cat \. ?\sum F : \mathcal{A} \to \mathcal{B} \. 
		\NewLine \. \prod  X,Y \in \mathcal{A} \. (X \Arrow{\mathcal{A}} Y) \to \Big(F(X) \Arrow{\mathcal{B}} F(Y)\Big)  }
	\DefineType{(F,F')}{Covariant}{ \Big( \forall X,Y,Z \in \mathcal{A} \.  \forall f : X \Arrow{\mathcal{A}} Y \.        
		\forall g : Y \Arrow{\mathcal{A}} Z \. \NewLine \. F'_{X,Z}(fg) = F'_{X,Y}(f)F'_{Y,Z}(g) \Big)
			\And \Big( \forall A \in \mathcal{A} \. F'_{A,A}\; \id_A = \id_{F(A)} \Big)
		}
	\\
	\DeclareType{Contravariant}{ \prod \mathcal{A},\mathcal{B} : \Cat \. ?\sum F : \mathcal{A} \to \mathcal{B} \. 
		\NewLine \. \prod  X,Y \in \mathcal{A} \. (X \Arrow{\mathcal{A}} Y) \to \Big(F(Y) \Arrow{\mathcal{B}} F(X)\Big) }
	\DefineType{(F,F')}{Contravariant}{  \Big( \forall X,Y,Z \in \mathcal{A} \.  \forall f : X \Arrow{\mathcal{A}} Y \.        
		\forall g : Y \Arrow{\mathcal{A}} Z \. \NewLine \.  F'_{X,Z}(fg) = F'_{Y,Z}(g)F'_{X,Y}(f) \Big)
		\And \Big( \forall A \in \mathcal{A} \. F'_{A,A}\; \id_A = \id_{F(A)} \Big)}
	\\
	\Conclude{\TYPE{Functor}}{\Cov | \Contra}{ \Cat \times \Cat \to  \Type}
	\\
	\DeclareFunc{actOnObjects}{  \prod \mathcal{A}, \mathcal{B}  :  \Cat \. 
		\TYPE{Functor}(\mathcal{A},\mathcal{B}) \to    
		\mathcal{A} \to \mathcal{B}  }
	\DefineNamedFunc{actOnObjects}{F,X}{F(X)}{F''(X) \quad \where \quad  F = (F',F'')}
	\\
	\DeclareFunc{actOnMorphism}{  \prod \mathcal{A}, \mathcal{B}  :  \Cat \. 
		 \TYPE{Functor}(\mathcal{A},\mathcal{B}) \to    
		\overrightarrow{\mathcal{A}} \to \overrightarrow{\mathcal{B}}  }
	\DefineNamedFunc{actOnMotphism}{F,f}{F(f)}{F''(f) \quad \where \quad  F = (F',F'')}
	\\
	\DeclareFunc{functorCompose}{ \prod \mathcal{A},\mathcal{B},\mathcal{C} : \Cat \.                    
		\Func{\mathcal{A}}{\mathcal{B}} \times \Func{\mathcal{B}}{\C} \to \Func{\mathcal{A}}{\C}}
	\DefineNamedFunc{functorCompose}{F, G} { FG = G \circ F}{ \Big(X \mapsto G\big(F(X)\big), f \mapsto G\big(F(f)\big) \Big) }
	\\
	\DeclareType{Full}{?\Func{\mathcal{A}}{\mathcal{B}}}
	\DefineType{(F,F')}{ Full }{ \forall X,Y \in \mathcal{A} \. F'_{X,Y} : \TYPE{Surjective}}
	\\
	\DeclareType{Faithful}{?\Func{\mathcal{A}}{\mathcal{B}}}
	\DefineType{(F,F')}{Faithful}{ \forall X,Y \in \mathcal{A} \. F'_{X,Y} : \TYPE{Injective}}
	\\
	\DeclareType{FullyFaithful}{?\Func{\mathcal{A}}{\mathcal{B}}}
	\DefineType{(F,F')}{FullyFaithful}{ \forall X,Y \in \mathcal{A} \. F'_{X,Y} : \TYPE{Bijective}}
	\\
	\DeclareType{EmbeddingFunctor}{?\TYPE{FullyFaithful}(\mathcal{A},\mathcal{B})}
	\DefineType{(F,F')}{EmbeddingFunctor}{F : \TYPE{Injective}(\mathcal{A},\mathcal{B})}
}\Page{
	\Theorem{CovariantPreservesIso}{\forall F : \Cov(\mathcal{A},\mathcal{B}) \. 
		\forall f : X \ToIso{\mathcal{A}} Y \. F(f) : F(X) \ToIso{\mathcal{B}} F(Y) }
	\Say{(1)}{\bd \Cov(\mathcal{A},\mathcal{B})(F\; \id_X)\bd^{-1} ff^{-1} \bd \Cov(\mathcal{A},\mathcal{B})(F)}
		{ \NewLine :\id_{F(X)}  = F \; \id_X = F\Big( ff^{-1} \Big) = F(f) F\Big( f^{-1} \Big)}
	\Say{(2)}{\bd \Cov(\mathcal{A},\mathcal{B})(F\; \id_X)\bd^{-1} f^{-1}f \bd \Cov(\mathcal{A},\mathcal{B})(F)}
		{ \NewLine : \id_{F(X)}  = F \; \id_X = F\Big( f^{-1}f \Big) =  F\Big( f^{-1} \Big)F(f)}
	\Say{(3)}{\bd^{-1} \TYPE{Inverse}(1,2)}{\Big(F(f)\Big)^{-1} = F\Big(  f^{-1}\Big)}
	\Conclude{(*)}{\bd^{-1}\TYPE{Iso}(3)}{\Big[ F(f) : F(X) \ToIso{\mathcal{B}} F(Y) \Big]}
	\EndProof
	\\
	\Theorem{CovntravariantPreservesIso}{\forall F : \Contra(\mathcal{A},\mathcal{B}) \. 
		\forall f : X \ToIso{\mathcal{A}} Y \. F(f) : F(Y) \ToIso{\mathcal{B}} F(X) }
	\Say{(1)}{\bd \Contra(\mathcal{A},\mathcal{B})(F\; \id_X)\bd^{-1} f^{-1}f \bd \Contra(\mathcal{A},\mathcal{B})(F)}
		{ \NewLine : \id_{F(X)}  = F \; \id_X = F\Big( f^{-1}f \Big) = F(f) F\Big( f^{-1} \Big)}
	\Say{(2)}{\bd \Contra(\mathcal{A},\mathcal{B})(F\; \id_X)\bd^{-1} f f^{-1} \bd \Contra(\mathcal{A},\mathcal{B})(F)}
		{ \NewLine : \id_{F(X)}  = F \; \id_X = F\Big( ff^{-1} \Big) =  F\Big( f^{-1} \Big)F(f)}
	\Say{(3)}{\bd^{-1} \TYPE{Inverse}(1,2)}{\Big(F(f)\Big)^{-1} = F\Big(  f^{-1}\Big)}
	\Conclude{(*)}{\bd^{-1}\TYPE{Iso}(3)}{\Big[ F(f) : F(Y) \ToIso{\mathcal{B}} F(X) \Big]}
	\EndProof
	\\
	\Theorem{FunctorPreservesIso}{\forall F : \Func{\mathcal{A}}{\mathcal{B}} \.
		\forall f : \TYPE{Iso}(\mathcal{A}) \. F(f) : \TYPE{Iso}(\mathcal{B}) }
	& \text{Combine two last statements.} \\
	\EndProof
	\\
	\Theorem{CovariantMapsSplitMonoToSplitMono}{\forall F : \Cov(\mathcal{A},\mathcal{B}) \. 
		\forall f : \TYPE{SplitMono}{\mathcal{A}}(X,Y) \. 
		\NewLine \. F(f) : \TYPE{SplitMono}(\mathcal{B})\Big(F(X),F(Y)\Big)}
	\NoProof
	\\
	\Theorem{CovariantMapsEpiEpiToSplitEpi}{\forall F : \Cov(\mathcal{A},\mathcal{B}) \. 
		\forall f : \TYPE{SplitEpi}{\mathcal{A}}(X,Y) \. 
		\NewLine \. F(f) : \TYPE{SplitEp}(\mathcal{B})\Big(F(X),F(Y)\Big)}
	\NoProof
}\Page{
	\\
	\Theorem{ContravriantMapsSplitMonoToSplitEpi}{\forall F : \Contra(\mathcal{A},\mathcal{B}) \. 
		\forall f : \TYPE{SplitMono}{\mathcal{A}}(X,Y) \. 
		\NewLine \. F(f) : \TYPE{SplitEpi}(\mathcal{B})\Big(F(Y),F(X)\Big)}
	\NoProof
	\\
	\Theorem{ContravariantMapsSplitRpiToSplitMono}{\forall F : \Contra(\mathcal{A},\mathcal{B}) \. 
		\forall f : \TYPE{SplitEpi}{\mathcal{A}}(X,Y) \. 
		\NewLine \. F(f) : \TYPE{SplitMono}(\mathcal{B})\Big(F(Y),F(X)\Big)}
	\NoProof
	\\
	\DeclareFunc{sign}{ \Func{\mathcal{A}}{\mathcal{B}} \to \TYPE{Sign} }
	\DefineFunc{sign}{ \Cov,F  }{+1}
	\DefineFunc{sign}{ \Contra,F }{-1}
	\\
	\Theorem{ InverseFunctoriality }{  \forall F : \Cov \And \TYPE{FullyFaithful}(\A,\B) \. 
		\forall X,Y,Z \in \A \. \NewLine \. \forall f : F(X) \Arrow{\B}  F(Y)\. 
		\forall g : F(Y) \Arrow{\B} F(X)  \.   F^{-1}_{X,Y}(f)F^{-1}_{Y,Z}(g) = F^{-1}_{X,Z}(fg)}
	\Say{f'}{ F^{-1}_{X,Y}(f)}{X \Arrow{\A} Y}
	\Say{g'}{F^{-1}_{X,Y}(g)}{X \Arrow{\A} Y}
	\Say{(1)}{\bd \Cov(F) \bd f' g'}{  F_{X,Z}(f'g') = F_{X,Y}(f')F_{Y,Z}F(g') = fg}
	\Conclude{(*)}{F^{-1}_{X,Z}(1)}{f'g' = F^{-1}_{X,Z}(fg)}
	\EndProof
	\\
	\Theorem{FullyFaithfulReflectsIso}{ \forall F : \Cov \And \TYPE{FullyFaithful}(\A,\B)  \. 
		\forall X,Y \in \A \. \forall f : X \Arrow{\A} Y \. 
		\NewLine \.
		\Big[ F(f) : F(X) \ToIso{\B} F(Y) \Big] \Rightarrow \Big[ f : X \ToIso{\A} Y  \Big]     
	}
	\Say{(g,1)}{ \bd \TYPE{Iso}(F(f)) \bd \TYPE{FullyFaithful} }{
		\sum g : Y \Arrow{\A} X \.  F(f)F(g) = {\id}_{F(X)} \And F(g)F(f) = {\id}_{F(Y)}  }
	\Say{(2)}{ \bd \Cov(\A,\B)(F)(1) \bd \TYPE{FullyFaithful}(F)   }
	{  fg = {\id}_A \And gf = {\id}_B }
	\Conclude{(*)}{ \bd^{-1}\TYPE{Iso}(2)}{ \Big[ f : X \ToIso{\A} Y \Big] }
	\EndProof
}
\newpage
\Page{
	\Theorem{FaithfulReflectsMono}{ 
		\forall \A,\B : \Cat \. \forall F : \TYPE{Faithful}(\A,\B) \. \forall f : A \Arrow{\A}  B \.
		 \NewLine \.
		\Big[ F(f) : F(A) \ToMono{\B} F(B) \Big] \Rightarrow \Big[   f : A \ToMono{\A} B    \Big]
	}
	\Assume{C}{\A}
	\Assume{h,g}{ C \Arrow{\A} A }
	\Assume{(1)}{ hf = gf }
	\Say{(2)}{\bd\Cov(F) F(1)\bd\Cov(F) }{ F(h)F(f) = F(hf) = F(gf) = F(g)F(f)  }
	\Say{(3)}{ \bd \TYPE{Monic}\big(F(f)\big)(2) }{ F(h) = F(f)  }
	\Conclude{()}{ \bd \TYPE{Faithful}(F)(3)  }{  h = f }
	\Derive{(*)}{\bd^{-1}\TYPE{Monic}}{ [f : A \ToMono{\A} B]   }
	\EndProof
	\\
	\Theorem{FaithfulReflectsEpi}{ 
		\forall \A,\B : \Cat \. \forall F : \TYPE{Faithful}(\A,\B) \. \forall f : A \Arrow{\A}  B \.
		 \NewLine \.
		\Big[ F(f) : F(A) \ToEpi{\B} F(B) \Big] \Rightarrow \Big[   f : A \ToEpi{\A} B    \Big]
	}
	& \text{Apply dual trick to previous theorem.}    \\
	\EndProof
}
\newpage
\subsection{Duality through Opposition}
\Page{
	\DeclareFunc{oppositeCategory}{\Cat \to \Cat}
	\DefineNamedFunc{oppositeCategory}{ \C    }{ \C^{\op}   }{  ( O, M \circ \FUNC{swap}, c \circ \FUNC{swap}, I) 
		\quad \where \quad \C = (O,M,c,I) }
	\\
	\DeclareFunc{oppose}{\prod \C : \Cat \. \Contra(\C, \C^\op)}
	\DefineNamedFunc{oppose}{X}{X}{X}
	\DefineNamedFunc{oppose}{f}{f^\op}{f}
	\\
	\Theorem{ReflexiveOpposition}{\forall \C \in \Cat \. ((\C)^\op)^\op = \C}
	\NoProof
	\\
	\DeclareFunc{dualStatement}{(\Cat \to \Type) \to (\Cat \to \Type)}
	\DefineNamedFunc{dualStatement}{ \mathbb{T} }{\mathbb{T}^*}{\Lambda \C \in \Cat \. \mathbb{T}(\C^\op) }
	\\
	\Theorem{DualStatementIsReflexive}{\forall \mathbb{T} : \Cat \to \Type \. \mathbb{T}^{**} = \mathbb{T} }
	\NoProof
	\\
	\Theorem{DualTrick}{\forall \mathbb{L} : \Cat \to \TYPE{Logical} \. 
	\Big(\forall \C \in \Cat \. \mathbb{L}(\C)\Big) \iff    \Big(\forall \C \in \Cat \. \mathbb{L}^*(\C)\Big)  }
	\Assume{(1)}{ \forall \C \in \Cat \. \mathbb{L}(\C)  }
	\Assume{\C}{ \Cat  }
	\Say{(2)}{(1)(\C^\op)}{ \mathbb{L}(\C^\op) }
	\Conclude{()}{ \bd^{-1} \FUNC{dualStatement}(2)   }{ \mathbb{L}^*(\C) }
	\DeriveConclude{(3)}{I(\forall))}{ \forall \C \in \Cat \. \mathbb{L}^*(\C)   }
	\Derive{(1)}{ I(\Rightarrow) }{ 
		\Big( \forall \C \in \Cat \. \mathbb{L}(\C) \Big) \Rightarrow
		\Big( \forall \C \in \Cat \. \mathbb{L}^*(\C) \Big)  }
	\Assume{(2)}{\forall \C \in \Cat \. \mathbb{L}^*(\C)}
	\Say{(3)}{(1)(2)}{\forall \C \in \Cat \. \mathbb{L}^{**}(\C)}
	\Say{(4)}{\THM{DualStatementIsReflexive}(\mathbb{L})}{\mathbb{L}^{**} = \mathbb{L}}
	\Conclude{()}{E(=)(4)(3)}{\forall \C \in \Cat \. \mathbb{L}(\C)}
	\DeriveConclude{(*)}{I(\iff)I(\Rightarrow)(1)}{\LOGIC{This}}
	\EndProof
}\Page{
	\Theorem{OppositeOfMonoIsEpi}{\forall f : A \ToMono{\C} B  \. f^\op : B \ToEpi{\C^\op} A}
	\NoProof
	\\
	\Theorem{OppositeOfEpiIsMono}{\forall f : A\ToEpi{\C} \. f^\op : B \ToMono{\C^\op} A }
	\NoProof	
	\\
	\DeclareFunc{reverse}{\Func{\A}{\B} \to \Func{\A^\op}{\B}}
	\DefineNamedFunc{reverse}{F}{-F}{F}
	\DefineNamedFunc{reverse}{F_{X,Y}}{-F_{X,Y}}{ F_{X,Y} \circ \FUNC{swap}}
	\\
	\DeclareFunc{orientatedAlong}{\prod \A,\B \in \Cat \. \Func{\A}{\B} \to \Cat}
	\DefineNamedFunc{orientatedAlong}{F}{ |\A|_F  }{ \If \Func{F} = -1 \Then \C^\op \Else \C }
	\\
	\DeclareFunc{wellOrientatedFunctor}{\prod \A,\B \in \Cat \. \Func{\A}{\B} \to \Cov(|\A|_F,\B)}
	\DefineNamedFunc{wellOrientatedFunctor}{F}{|F|}{\FUNC{sign}(F)F }
}
\newpage
\subsection{Representation of Functors}
\Page{
	\DeclareFunc{covariantRepresentedByObject}{\prod \C : \Cat \. \C \to \Cov(\C,\SET)}
	\DefineNamedFunc{covariantRepresrntedByObject}{A}{ \Mor_\C(A,\underline{\quad}) }{
		\NewLine \de
		\Big( X \mapsto \Mor_\C(A,X) , \Lambda f \in \Mor_\C(X,Y) \. \Lambda g \in \Mor_\C(A,X) \. gf \Big)	
	}
	\\
	\DeclareFunc{PushForward}{\prod \C : \Cat \. \prod A,X,Y \in \C \. \Mor_\C(X,Y) \to \Big(\Mor_\C(A,X) \to \Mor_\C(A,Y)\Big)}
	\DefineNamedFunc{PushForward}{f}{(A) \quad f_*}{\Mor_\C(A,\underline{\quad})(f)}
	\\
	\DeclareFunc{contravariantRepresentedByObject}{\prod \C : \Cat \. \C \to \Contra(\C,\SET)}
	\DefineNamedFunc{contravariantRepresentedByObject}{A}{ \Mor_\C(\underline{\quad},A) }{
		\NewLine \de
		\Big( X \mapsto \Mor_\C(X,A) , \Lambda f \in \Mor_\C(X,Y) \. \Lambda g \in \Mor_\C(Y,A) \. fg \Big)	
	}
	\\
	\DeclareFunc{PullBack}{\prod \C : \Cat \. \prod A,X,Y \in \C \. \Mor_\C(X,Y) \to \Big(\Mor_\C(Y,A) \to \Mor_\C(X,A)\Big)}
	\DefineNamedFunc{PushForward}{f}{(A) \quad f^*}{\Mor_\C(\underline{\quad},A)(f)}
	\\
	\Theorem{PushForwardOfIsoIsBijection}{\forall \C \in \Cat \. \forall A,X,Y \in \C \. 
		\forall f : X \ToIso{\C} Y \. (A) \quad f_* : \TYPE{Bijection}}
	& \text{By $\THM{FunctorPreservesIso}$.} \\
	\EndProof
	\\
	\Theorem{PullBackOfIsoIsBijection}{\forall \C \in \Cat \. \forall A,X,Y \in \C \. 
		\forall f : X \ToIso{\C} Y \. (A) \quad f^* : \TYPE{Bijection}}
	& \text{By $\THM{FunctorPreservesIso}$.} \\
	\EndProof
	\\
	\Theorem{PushForwardOfMonoIsInjection}{\forall \C \in \Cat \. \forall A,X,Y \in \C \. 
		\forall f : X \ToMono{\C} Y \. (A)f_* : \TYPE{Injection}}
	\Assume{g,h}{\Mor_{\C}(A,X)}
	\Assume{(1)}{f_*(g) = f_*(h)}
	\Say{(2)}{\bd ((A) \quad f_*)(1) }{  gf = hf  }
	\Conclude{()}{\bd \TYPE{Monic}(f)(2)}{ g = h  }
	\Derive{(*)}{\bd^{-1} \TYPE{Injection}}{ \Big( f_* : \TYPE{Injection} \Big) }
	\EndProof
	\\
	\Theorem{PullBackOfEpiIsSurjection}{\forall \C \in \Cat \. \forall A,X,Y \in \C \. 
		\forall f : X \ToMono{\C} Y \. (A) f^* : \TYPE{Surjection}}
	& \text{Apply dual trick to precious theorem.}\\
	\EndProof
}
\subsection{Bifunctors}
\Page{
	\DeclareFunc{ProductOfCats}{\Cat \times \Cat \to \Cat}
	\DefineNamedFunc{ProductOfCats}{\mathcal{A},\mathcal{B}}
	{\mathcal{A} \times \mathcal{B}}{\Big( \Obj_{\mathcal{A}} \times \Obj_{\mathcal{B}},   
		(A,B),(X,Y) \mapsto \Mor_{\mathcal{A}}(A,X) \times \Mor_{\mathcal{B}}(B,Y), \cdot \times \cdot, \id \times \id
	\Big)}
	\\
	\Conclude{\TYPE{Bifunctor}}{\Lambda \C, \mathcal{X} : \Cat \. \Cov(\C^\op \times \C,\mathcal{X})}{\Cat \to \Cat \to \Type}
	\\
	\DeclareFunc{TwoSidedRepresented}{\prod \C : \TYPE{LocallySmall} \. \TYPE{Bifunctor}(\C,\SET) }
	\DefineNamedFunc{TwoSidesRepresented}{  }{\Mor_\C(\underline{\quad},\underline{\quad})}{  
		\NewLine \de \Big( \Lambda  (X,Y) \in \C^\op \times \C \. \Mor_\C(X,Y), 
		 \NewLine ,	\Lambda (A,B),(X,Y) \in C^\op \times C  \. \Lambda (f,g) : \Mor_\C(X,A)\times \Mor_\C(B,Y) \.
		\Lambda h \in \Mor_\C(A,B) \. fhg 	\Big)
	}
}
\newpage
\subsection{Categories of Categories}
\Page{
	\DeclareFunc{identityFunctor}{\prod \C \. \Func{\C}{\C}}
	\DefineNamedFunc{identityFunctor}{}{ \mathrm{Id}_\C }{ ( \Lambda X \in \C \. X,
		\Lambda X,Y \in \C \. \Lambda f : X \Arrow{\C} Y\. f )}
	\\
	\DeclareFunc{Categories}{\Cat}
	\DefineNamedFunc{Categories}{}{\mathsf{LSCAT}}{ ( \TYPE{LocallySmall}, \TYPE{Functor}, \circ, \mathrm{Id} )}
	\\
	\DeclareFunc{SmallCategories}{\Cat}
	\DefineNamedFunc{SmallCategories}{}{\mathsf{SCAT}}{ ( \TYPE{Small}, \TYPE{Functor}, \circ, \mathrm{Id} )}
}
\newpage
\subsection{Comma Categories}
\Page{
	\DeclareFunc{commaCategory}{\prod \mathcal{A},\mathcal{B},\C, : \Cat \. 
		\Cov(\mathcal{A},\C) \times \Cov(\mathcal{B}, \C) \to \Cat}
	\DefineNamedFunc{commaCategory}{ F,G   }{ F \downarrow G }
	{  \Big( \sum A \in \mathcal{A} \.  B \in \mathcal{B} \. FA \Arrow{\C}  GB , \NewLine
		\Lambda (A,B,f),(X,Y,g) \. \sum (\alpha,\beta) \in \Mor_{\mathcal{A}}(A,X) \times \Mor_{\mathcal{B}}(B,Y) \.  
		fG(\beta) = F(\alpha)g, \NewLine
		\FUNC{compositionRule}(\mathcal{A}) \times \FUNC{compositionRule}(\mathcal{B}), \id \times \id
	\Big)}	
	\Assume{(A,B,f),(C,D,g),(X,Y,h)}{F \downarrow G}
	\Assume{ (\alpha,\beta) }{(A,B,f) \Arrow{F \downarrow G} (C,D,g)  }
	\Assume{(\gamma,\delta)}{(C,D,g) \Arrow{F \downarrow G} (X,Y,h)}
	\Say{ (1)  }{\bd (\alpha,\beta)}{ fG(\beta) = F(\alpha)g  }
	\Say{ (2) }{\bd(\gamma,\delta)}{ gG(\delta) = F(\gamma)h }
	\Say{ (3) }{ \bd \Cov(G(\beta\delta))(1)(2)\bd \Cov(F(\alpha)F(\gamma))    }
	{  
		\NewLine
		:fG(\beta \delta) = fG(\beta)G(\delta) = F(\alpha)gG(\delta) = F(\alpha)F(\gamma)h = F(\alpha \gamma) h }
	\Conclude{ (*) }{\bd^{-1} F \downarrow G (3)}{ (\alpha\gamma,\beta\delta) : (A,B,f) \Arrow{F \downarrow G} (C,D,g)}
	\EndProof
	\\
	\DeclareFunc{leftProjFunctor}{ \prod \mathcal{A}, \mathcal{B},\C : \Cat \. \prod F : \Cov(\mathcal{A},\C) \. 
		\prod G : \Cov(\mathcal{B},\C) \.  
		\NewLine \. \Cov(F \downarrow G, \mathcal{A}  ) }
	\DefineNamedFunc{leftProjFunctor}{A,B,f}{\Pi_{\mathcal{A}}(A,B,f)}{ A  }
	\DefineNamedFunc{leftProjFunctor}{\alpha,\beta}{\Pi_{\mathcal{A}}(\alpha,\beta)}{\alpha}
	\\
	\DeclareFunc{rightProjFunctor}{ \prod \mathcal{A}, \mathcal{B},\C : \Cat \. \prod F : \Cov(\mathcal{A},\C) \. 
		\prod G : \Cov(\mathcal{B},\C) \.  
		\NewLine \. \Cov(F \downarrow G, \mathcal{B}  ) }
	\DefineNamedFunc{rightProjFunctor}{A,B,f}{\Pi_{\mathcal{B}}(A,B,f)}{ B  }
	\DefineNamedFunc{rightProjFunctor}{\alpha,\beta}{\Pi_{\mathcal{B}}(\alpha,\beta)}{\beta}
	\\
	\Theorem{SliceUnderAsComma}{\forall \C : \Cat \. \forall A \in \C \. \frac{\C}{A} = I \downarrow \mathrm{Id}_\C
		\NewLine \where \NewLine
		I = ( 1 \mapsto A, \id_1 \mapsto \id_A ) : \Cov(\mathbf{1},\C)	
	}
	\NoProof
	\\
	\Theorem{SliceOverAsComma}{\forall \C : \Cat \. \forall A \in \C \. \frac{A}{\C} =  \mathrm{Id}_\C \downarrow I
		\NewLine \where \NewLine
		I = ( 1 \mapsto A, \id_1 \mapsto \id_A ) : \Cov(\mathbf{1},\C)	
	}
	\NoProof
}
\subsection{Natural Transformations}
\Page{
	\DeclareType{NaturalTransform}{\prod \C \mathcal{D} \in \Cat \.  F,G : \Cov(\C,\mathcal{D}) \. 
		 \prod X \in \C \. F(X) \Arrow{\mathcal{D}} G(X) }
	\DefineNamedType{ \alpha }{NaturalTransform}{(F \Rightarrow G)}{\forall f : A \Arrow{\C} B\. \alpha(A)G(f) = F(f)\alpha(B)  }
	\\
	\DeclareType{NaturalIso}{ ?\NT(\C,\mathcal{D},F,G)}
	\DefineNamedType{\alpha}{NaturalIso}{(F \iff G)}{\forall X \in \C \. \alpha(X) : F(X) \ToIso{\mathcal{D}} G(X)}
	\\
	\DeclareFunc{invert}{\TYPE{NaturalIso}(\C,\mathcal{D},F,G) \to \TYPE{natuatalIso}(\mathcal{D},\C,F,G)}
	\DefineNamedFunc{invert}{\alpha}{\alpha^{-1}}{\Lambda X \in \C \. \alpha_X^{-1}}
}
\newpage
\subsection{Equivalence of Categories}
\Page{
	\DeclareType{EquivalentCategories}{?(\Cat \times \Cat)}
	\DefineNamedType{(\mathcal{A},\mathcal{B})}{EquivalentCategories}{\mathcal{A} \simeq \mathcal{B}}
	{ \exists F : \Cov(\mathcal{A},\mathcal{B}) : \exists G : \Cov(\mathcal{B},\mathcal{A}) :
	  \NewLine :
	  \exists  (\mathrm{Id}_{\mathcal{A}} \iff FG) \times (\mathrm{Id}_{\mathcal{B}} \iff GF) }
	\\
      \Theorem{CategoryEqIsEq}{ \Big[\TYPE{EquivalentCategries} : \TYPE{Equivalence}(\Cat)\Big]}
      \Assume{\A,\B,\C}{\Cat}
      \Assume{(1)}{\A \simeq \B}
      \Assume{(2)}{\B \simeq \C}
      \Say{(F,G,\alpha,\beta)}{ \bd \TYPE{EquivalentCategories}(1) }{\sum F : \Cov(\A,\B) \.
        \NewLine \.
      	\sum G : \Cov(\B,\A) \. (\mathrm{Id}_{\A} \iff FG) \And (\mathrm{Id}_{\B} \iff GF)}
      \Say{(F',G',\alpha',\beta')}{ \bd \TYPE{EquivalentCategories}(1) }{\sum F' : \Cov(\B,\C) \.
        \NewLine \.
      	\sum G' : \Cov(\C,\B) \. (\mathrm{Id}_{\B} \iff F'G') \And (\mathrm{Id}_{\C} \iff G'F')}
     \Assume{X}{\A}
     \Say{\alpha''(X)}{  \alpha(X)G\Big(\alpha'\big(F(X)\big)\Big)  }{  X \ToIso{\A} FF'G'G(X) }
     \Assume{Y}{\A}
     \Assume{f}{X \Arrow{\A} Y} 
     \Conclude{(3)}{ \bd \alpha''(X)  FF'G'G(f) \bd \Cov(\B.\A)(G)\bd \NT(\alpha')\big(F(X)\big)\big(F(f)\big) 
     	\NewLine \bd \Cov(\B,\A)(G) \bd \NT(\alpha)(X)(f) \bd^{-1} \alpha''(Y)
     }{   \NewLine :
     	\alpha''(X) FF'G'G(f) =  \alpha(X) G\Big( \alpha'\big(F(X)\big)\big) G( F'G(F(f)) \Big) 
        = \alpha(X) G\Big(   \alpha'\big(F(X)\big) F'G'\big(F(f)\big)  \Big) = 
	\NewLine =  \alpha(X) G \Big(  F(f) \alpha'\big(F(Y)\big)   \Big) = 
	\alpha(X) FG(f) G\Big(\alpha'\big(F(Y)\big)\Big)  = f \alpha(Y) G\Big(\alpha'\big(F(Y)\big)\Big) = f \alpha''(Y) 
     }
    \Derive{\alpha''}{\bd^{-1}\TYPE{NaturalIso}}{ \mathrm{Id}_{\mathcal{A}} \iff FF'G'G    }
     \Assume{X}{\C}
     \Say{\beta''(X)}{  \beta'(X)F'\Big(\beta \big(G'(X)\big)\Big)  }{  X \ToIso{\A} FF'G'G(X) }
     \Assume{Y}{\C}
     \Assume{f}{X \Arrow{\C} Y} 
     \Conclude{(3)}{ \bd \beta''(X)  G'GFF'(f) \bd \Cov(\B.\C)(F')\bd \NT(\beta)\big(G'(X)\big)\big(G'(f)\big) 
     	\NewLine \bd \Cov(\B,\C)(F') \bd \NT(\beta')(X)(f) \bd^{-1} \beta''(Y)
     }{   \NewLine :
     	\beta''(X) G'GFF'(f) =  \beta'(X) F'\Big( \beta\big(G'(X)\big)\big) F'( GF(G'(f)) \Big) 
        = \beta'(X) F'\Big(   \beta \big(G'(X)\big) GF\big(G'(f)\big)  \Big) = 
	\NewLine =  \beta'(X) F' \Big(  G'(f) \beta\big(G'(Y)\big)   \Big) = 
	\beta'(X) F'G'(f) F'\Big(\beta \big(G'(Y)\big)\Big)  = f \beta' (Y) G\Big(\alpha'\big(F(Y)\big)\Big) = f \beta''(Y) 
     }
    \Derive{\beta''}{\bd^{-1}\TYPE{NaturalIso}}{ \mathrm{Id}_{\C} \iff G'GFF' }
    \Conclude{()}{\bd^{-1} \TYPE{EquivalentCategory}(FF',G'G,\alpha'',\beta'')}{ \A \simeq \C}
    \Derive{(1)}{\bd^{-1} \TYPE{Transitive}}{ \Big[ \TYPE{EquivalentCategory} : \TYPE{Transitive} \Big] }
    \Conclude{(*)}{\ldots}{\LOGIC{This}}
    \EndProof
}
\Page{
	\DeclareType{ProvidesEquivalence}{\prod \A,\B : \Cat \. ? \Cov(\A,\B)}
	\DefineType{F}{ProvidesEquivalence}
	{ 
		\exists G : \Cov(\mathcal{B},\mathcal{A}) :
		\exists  (\mathrm{Id}_{\mathcal{A}} \iff FG) \times (\mathrm{Id}_{\mathcal{B}} \iff GF) 
	}
	\\
	\Theorem{EquivalenceProvison}{\forall \A,\B : \Cat \. \forall F : \TYPE{ProvidesEquivalence}(\A,\B) \. A \simeq \B} 
	\EndProof
	\\
	\DeclareFunc{isoClass}{   \prod \C : \Cat \. \C \to \Class}
	\DefineFunc{isoClass}{A}{\Big\{ B \in \C : \exists f : A \ToIso{\C} B \Big\}}
	\\
	\DeclareType{IsoClass}{ \Cat \to \Class}
	\DefineType{A}{IsoClass}{ \Lambda \C : \Cat \. \exists a \in \C  : A = \FUNC{isoclass}(a)}
	\\
	\DeclareType{Embedding}{\prod \A, \B : \Cat \. ? \TYPE{Faithful}(\A,\B)} 
	\DefineType{(E,E')}{Embedding}{\Big[E : \TYPE{Injective}(\A,\B)\Big]}
	\\
	\Conclude{\TYPE{Subcategory}}{\prod \C : \Cat \. \sum \A : \Cat \. \TYPE{Embedding}(\A,\C)}{ \Cat \to \Type}
	\\
	\DeclareFunc{synecdoche}{ \prod \C : \Cat \. \TYPE{Subcategory}(\C) \to \Cat   }
	\DefineFunc{synecdoche}{ \A,E  }{\A}
	\\
	\DeclareType{EssSubcat}{?\TYPE{Subcategory}(\C)}
	\DefineType{(\A,E)}{EssSubcat}{ \forall C : \TYPE{Isoclass}(\C) \. \exists A \in \A : \exists c \in C : F(A) = c }
	\\
	\DeclareType{Essentially}{  \prod \mathbb{T} : \prod A,B : \Class \. ?(A \to B) \. \prod \A, \B : \Cat \. ?\Cov(\A,\B)}
	\DefineType{ (F,F')  }{  Essentially  }
	{ \exists \A' : \TYPE{EssSubcat}(\A) : \exists \B' : \TYPE{EssSubcat}(\B) : 
		F(\A') \subset \B' \And F_{|\A'} : \mathbb{T}(\A',\B')   } 
       \\
       \Conclude{\TYPE{Isofunctor}}
       {\prod \A,\B : \Cat \. \TYPE{FullyFaithful} \And \TYPE{Essentially} \; \TYPE{Bijective}(\A,\B)  }
       { \NewLine : \Cat \times \Cat \to \Type}
       \\
       \Theorem{ IsomorphismLemma  }{ \forall \C : \Cat \. \forall A,B,A',B' \in \C \. 
		\forall f : A \Arrow{\C} B \.  \forall \varphi : A \ToIso{\C} A' \. 
		\forall \psi : B \ToIso{\C} B' \. 
		\NewLine \.
		\exists! : f' : A' \Arrow{\C} B' :
		f\psi = \varphi f' \And \varphi^{-1}f\psi = f' \And 
		f = \varphi f \psi^{-1} \And \varphi^{-1} f = f'\psi^{-1} 
	}
	\Say{f'}{\varphi^{-1}f \psi}{A' \Arrow{\C} B'}
	\Say{(1)}{\varphi \bd f'}{ f \psi = \varphi f'  }
	\Say{(2)}{ (1) \psi }{ f = \varphi f' \psi^{-1}}
	\Conclude{(*)}{  \varphi^{-1}(2)   }{ \varphi^{-1} f = f' \psi^{-1}  }
	\EndProof
 } \Page{
	 \Theorem{ EquivalenceProviderIsIsofunctor  }{ \forall F : \TYPE{EquivalenceProvider}(\A,\B) \. 
	 	\Big[ F : \TYPE{Isofunctor}(\A,\B)  \Big]
	 }
 	 \Assume{\A,\B}{\Cat}
	 \Assume{F}{\TYPE{EquivalencProvider}(\A,\B)}
	 \Say{(G,\alpha,\beta)}{\bd F}{\sum G : \Cov(\B,\A) \. (\mathrm{Id}_\A \iff FG) \times (\mathrm{Id}_\B \iff GF)}
	 \Assume{X,Y}{\A}
	 \Assume{f}{X \Arrow{\A} Y}
	 \Say{(1)}{\bd \alpha (f)}{   f \alpha(Y)  =  \alpha(X) FG(f)   }
	 \Conclude{()}{ \alpha^{-1}(X)(f)  }{ f = \alpha(X) FG(f) \alpha^{-1}(Y) }
	 \Derive{(1)}{I(\forall)}{\forall f : X \Arrow{\A} Y \. f = \alpha^{-1}(X) FG(f) \alpha(Y) }
	 \Conclude{(2)}{\THM{InjectiveByComposition}(F,1)}{ \Big[ F_{X,Y} : \Mor_\A(X,Y) \ToInj  \Mor_\B\big(F(X),F(Y))  \Big]  }
	 \Derive{(1)}{I(\forall)\bd^{-1}\TYPE{Faithful}I(\forall)}
	 { \forall F : \TYPE{EquivalenceProvider}(\A,\B) \. \Big[  F : \TYPE{Faithful}(\A,\B) \Big]}
	 \Say{(G,\alpha,\beta)}{\bd F}{\sum G : \Cov(\B,\A) \. (\mathrm{Id}_\A \iff FG) \times (\mathrm{Id}_\B \iff GF)}
	 \Say{(2)}{ (1)( G ) }{ \Big( G : \TYPE{Faithful}(\B,\A) \Big)}
	 \Assume{X,Y}{\A}
	 \Assume{g}{ F(X) \Arrow{\B} F(Y) }
	 \Say{(f,3)}{\THM{IsomorphismLemma}\Big(G(g),\alpha(X),\alpha(Y)\Big)}
	 {\sum f : X \Arrow{\A} Y \. f = \alpha(X)G(g)\alpha^{-1}(Y)}
	 \Say{(4)}{ \big((3)\alpha(Y)\big)\bd\alpha(f)}{  \alpha(X)G(g) =  f\alpha(Y) = \alpha(X)FG(f) }
	 \Say{(5)}{ \alpha^{-1}(X)(4) }{ G(g) = FG(f)}
	 \Conclude{()}{\THM{InjectionIsRightInvertible}\bd \TYPE{Faithful}(G)}{ g = F(f)}
	 \DeriveConclude{()}{\bd^{-1} \TYPE{Bijective} \Big((1)(F)\bd \TYPE{Faithful}\Big)\bd^{-1}\TYPE{Surjective}}
	 { \Big[ F_{X,Y} : \Mor_\A(X,Y) \ToBij \Mor_\B\big(F(X),G(X)\big)  \Big] }
	 \Derive{(3)}{\bd^{-1}\TYPE{FullyFaithful}}{\big[F : \TYPE{FullyFaithul} \big]}
	 \Assume{b}{\B}
	 \Say{(4)}{\bd^{-1}\TYPE{Isomorphic}\bd \beta(b)}{b \cong_\B GF(b)}
	 \Conclude{()}{\bd \TYPE{Image}(F)\Big(GF(b)\Big)}{ GF(b) \in \im F}
	 \Derive{(4)}{\bd^{-1} \ldots}{ \Big[  F : \TYPE{Essentially} \; \TYPE{Bijective}(\A,\B) \Big]  }
	 \Conclude{()}{\bd^{-1} \TYPE{Isofuncctor}(3,4)}{\Big[ F : \TYPE{Isofuncot}(\A,\B) \Big]}
	 \EndProof
}\Page{
	\Theorem{ IsofunctorProvidesEquivalence }{ \forall F : \TYPE{IsoFunctor}(\A,\B) \. \forall (0) : \TYPE{Choice} 
		\. \NewLine \. \Big[ F : \TYPE{EquivalenceProvider}(\A,\B) \Big]}
	\Say{C}{\Lambda S : \TYPE{Isoclass}(\B) \. F^{-1}(S)}{ \TYPE{Isoclass}(\B) \to ?\A  }
	\Say{(1)}{\bd \TYPE{Isofunctor}(F)\bd C}{\forall S : \TYPE{Isoclass}(\B) \. C(S) \neq \emptyset}
	\Say{(A,2)}{ (0)(C)}{ \sum A : \TYPE{Isoclass}(\B) \to \A \. \forall S : \TYPE{Isoclass}(\B) \. F(A(S)) \in S }
	\Say{G'}{ \Lambda B \in \B \. A(\FUNC{isoclass}(B))}{\B \to \A}
	\Assume{B }{\B}
	\Say{(3)}{\bd \TYPE{Isoclass}(2)\bd G'(B')}{ F\big(G'(B) \big) \cong_\B B }
	\Conclude{\beta(B) }{ \bd \TYPE{Isomorphic}(3)  }{ B \ToIso{\B}  F\big(G'(B)\big)  }
	\Derive{\beta}{I\left( \prod \right)}{ \prod B \in \B \. B \ToIso{\B} F\big(G'(B)\big)  }
	\Assume{A}{\A}
	\Say{(3)}{\bd G'(1) G'(F(A))}{ F\Big(G'\big(F(A)\big)\Big) \cong_{\B} F(A)}
	\Conclude{\alpha(A)}{ F^{-1}_{A, G'FA}\Big(\beta\big(F(A)\big)\Big) }{ A \ToIso{\A} G'\big( F(A) \big)}
	\Assume{B,B'}{\B}
	\Assume{f}{ B \Arrow{\B} B'}
	\Say{f'}{ \beta^{-1}(B)f\beta(B')}{ F\big(G'(B) \big) \Arrow{\B} F\big( G'(B') \big)  }
	\Conclude{G''_{B,B'}(f)}{ F_{G'(B),G'(B')}^{-1}(f')  }{ G'(B) \Arrow{\A} G''(B)   }
	\Derive{G''}{I\left(\prod\right)I(\to)}{ \prod B,B' \in \B \. (B \Arrow{\B} B') \to \big( G'(B) \Arrow{\A} G'(B')\big)  }
	\Assume{B,B',B''}{\B}
	\Assume{f}{B \Arrow{\B} B'}
	\Assume{f'}{B' \Arrow{\B} B''}
	\Conclude{()}{
		\bd G''_{B,B'}(f)G''_{B',B''}(f')\THM{InverseFunctoriality}(F)\bd\TYPE{Inverse}\big(\beta(B')\big)
	        \bd^{-1} G''_{B,B''}(ff')
	}
	{ 
		\NewLine :
		G''_{B,B'}(f)G''_{B',B'''}(f') =  
		F_{G'(B),G'(B')}^{-1}\big( \beta^{-1}(B)f\beta(B') \big) 
		F_{G'(B'),G'(B'')}^{-1}\big( \beta^{-1}(B')f'\beta(B'')  \big)  = \NewLine =  
		F_{G'(B),G'(B'')}^{-1}\big( \beta^{-1}(B)ff'\beta(B'') \big) = 
		G''_{B,B''}(ff')
	}
	\Derive{(3)}{I^3\left(\forall \right)}{\forall B,B',B'' \in \B \. \forall f : B \Arrow{\B} B' \. 
		\forall f' : B' \Arrow{\B} B'' \. G''_{B,B'}(f)G'_{B',B''}(f') = G''_{B,B''}(ff') }
	\Assume{B}{\B}
	\Conclude{()}{ \bd G''_{B,B} \bd \TYPE{Identity}(B) \bd \TYPE{Inverse}\big(\beta(B)\big) \bd F   }
	{ \NewLine : 
		G''_{B,B}({\id}_B) = F_{G'(B),G'(B)}^{-1}( \beta^{-1}(B) {\id}_B \beta(B)  ) = 
		F^{-1}_{G'(B),G'(B)}({\id}_{FG'(B)}) = {\id}_{G'(B)}
	}
	\Derive{(4)}{ I(\forall) }{ \forall B \in \B \. G''_{B,B}({\id}_B) = {\id}_{G'(B)}}
	\Say{G}{\big(G',G'',(3),(4)\big)}{\Cov(\B,\A)}
}\Page{	
   	\Assume{X,Y}{\A}
	\Assume{f}{X \Arrow{\A} Y}
	\Conclude{()}{\bd G (\alpha(X) FG(f)) \THM{InverseFunctoriality}(F) \bd^{-1} \alpha \bd \TYPE{Inverse}(\alpha(X))}{  
		\NewLine :
		\alpha(X) FG(f)  = \alpha(X) F^{-1}_{FG(X),FG(Y)}( \beta^{-1}(F(X))F(f)  \beta(F(Y)) )   
		= \alpha(X) \alpha^{-1}(X) f \alpha(Y) = f \alpha(Y)
	}
	\Derive{(5)}{\bd^{-1} \TYPE{NaturalIso}}{ [ \alpha : \mathrm{Id}_A \iff FG  ]   }
	\Assume{X,Y}{\B}
	\Assume{f}{X \Arrow{B} Y}
	\Conclude{()}{ \bd G (\beta(X)GF(f)) \bd \TYPE{Inverse}(F)\bd \TYPE{Inverse}\big( \beta(X) \big)  }
	{  \NewLine :
		\beta(X) GF(f) = \beta(X) F\Big( F^{-1} \big( \beta^{-1}(X)f\beta(Y)  \big) \Big) =f \beta(Y)
	}
	\Derive{(6)}{\bd^{-1} \TYPE{naturalIso}}{[\beta : \mathrm{Id}_B \iff GF ]}
	\Conclude{(*)}{\bd^{-1} \TYPE{EquivalenceProvider}(F)(G,\alpha,\beta)}{\Big[ F : \TYPE{EquivalenceProvider}(\A,\B) \Big]}
	\EndProof
	\\
	\Theorem{IsofunctorComposition }{ \forall  F : \TYPE{Isofunctor}(\A,\B) \. 
		\forall G : \TYPE{Isofunctor}(\B,\C) \. FG : \TYPE{isofunctor}(\A,\C) }
	\EndProof
	\\
	\DeclareType{Skeletal}{ ?\Cat  }
	\DefineType{\C}{Skeletal}{ \forall A \in \C \. \# \TYPE{Isoclass}(A) = 1  }
	\\
	\DeclareType{Skeleton}{\prod  \C : \Cat \.  ?\TYPE{Skeletal}}
	\DefineType{\A}{Skeleton}{ A \simeq \C }
	\\
	\DeclareType{Essentially}{ ?\Cat \to ?\Cat}
	\DefineType{\C}{Essentially}{ \Lambda \mathbb{T} : ?\Cat \. 
		\exists \A : \mathbb{T} : \A \simeq \C  }
}
\newpage
\subsection{ Commutative Diagrams }
\Page{
	\Conclude{\TYPE{Diagram}}{ \prod \C : \Cat \. \sum \I : \TYPE{Small} \. \Cov(\I,\C) }{ \Cat \to \Type}
	\\
	\DeclareFunc{index}{ \TYPE{Diagram} \to \TYPE{Small}  }
	\DefineFunc{index}{\I,D}{\I}
	\\
	\Conclude{\TYPE{MorphismChain}}{ \prod \C : \Cat \. \prod A,B \in \C \. 
		\sum n \in \Nat \. \sum X : (n + 1) \to \C \. \NewLine \. 
		\sum f : \prod i \in n \.  X_i \Arrow{\C} X_{i+1}  \. X_1 = A \And X_{n+1} = B   }
		{\prod \C : \Cat  \. \C \times \C \to \Type }
	\\
	\DeclareType{Commutative}{?\TYPE{Diagram}}
	\DefineType{ (\I,D)  }{Commutative}{  \forall (n,X,f),(m,Y,g) : \TYPE{MorphismChain}(\I)(I,J) 
		\. \prod^n_{i=1} D(f_i) = \prod^m_{i=1}D(g_i)}
	\\
	\Theorem{FunctorPreservesCommutativity}{
		\forall (\I,D) : \TYPE{Commutative}(\A ) \.
		\forall F : \TYPE{Functor}(\A,\B) \. \NewLine \.
		  (\I,DF) : \TYPE{Commutative}(\B)
		}
	\NoProof
	\\
	\DeclareType{ Initial }{ \prod \C : \Cat \. ?\C}
	\DefineType{I}{Initial}{ \forall A \in \C \. \exists! f : I \Arrow{\C} A  }
	\\
	\DeclareType{Terminal}{\prod \C : \Cat \. ?\C}
	\DefineType{T}{Terminal}{\forall A \in \C \. \exists! f : A \Arrow{\C} T }
	\\
	\Conclude{\TYPE{Zero}}{\TYPE{Initial} \And \TYPE{Terminal} }{ \Cat \to \Type}
	\\
	\Theorem{CommutativityOfChainsAtZero}{\forall (n,X,f),(m,Y,g) : \TYPE{MorphismChain}(\C)(A,B) 
		\.  \NewLine \. \Big(A : \TYPE{Initial}(\C) \Big| B : \TYPE{Terminal}(\C)\Big) 
		\Rightarrow \prod^n_{i=1} f_i = \prod^m_{i=1} g_i     }
	\NoProof
	\\
	\Conclude{ \TYPE{Concrete} }{ \sum \C : \Cat \. \TYPE{Faithful}(\C,\SET)  }{ \Type  }
	\\
	\DeclareFunc{synecdoche}{\TYPE{Concrete} \to \Cat}
	\DefineFunc{synecdoche}{\C,F}{ \C  }
} \Page{
	\Theorem{FaithfulReflectsCommutative}{  
		\forall (\I,D) : \TYPE{Diagramm}(\A) \. \forall F : \TYPE{Faithful}(\A,\B) \. \NewLine \. 
		\Big[(\I,FD) : \TYPE{Commutative}(\B) \Big] \Rightarrow \Big[ (\I,D) : \TYPE{Commutative}(\A) \Big]  
		}
	\NoProof
	\\
	\Theorem{ZeroCondition}{
		\forall I : \TYPE{Initial}(\C) \. \forall T : \TYPE{Terminal}(\C) \.
		\forall f : T \Arrow{\C} I \. I \cong T
		}
		\NoProof
}
\newpage
\subsection{Coalgebras}
\Page{
	\Conclude{\TYPE{Coalgebra}}{ \prod T : \Cov(\C,\C) \. ? \sum X \in \C \. X \Arrow{\C} TX   }
	{\prod \C : \Cat \. \Cov(\C,\C) \to \Type}
	\\	
	\DeclareType{CoalgebraMorphism}{  \prod (A,\alpha),(B,\beta) : \TYPE{Coalgebra}(\C)(T) \. ?(A \Arrow{\C} B) }
	\DefineType{f}{CoalgebraMorphism}{\alpha Tf = f \beta}
	\\
	\DeclareFunc{coalgebraCategory}{\prod \C : \Cat \. \Cov(\C,\C) \to \Cat}
	\DefineNamedFunc{coalgebraCategory }{ T }{ \mathsf{COALG}(T) }{ 
		\NewLine \de 
		\Big( \TYPE{Coalgebra}(T),\TYPE{CoalgebraMorphism},
		\FUNC{compositionLaw}(\C),\FUNC{idMorphism}(\C) \Big) }
	\\
	\Theorem{TerminalCoalgebra}{\forall (X,\gamma) : \TYPE{Terminal}\Big(\mathsf{COALG}(\C)(T)\Big) 
		\.   \gamma : X \ToIso{\C} TX   }
	\Say{\gamma'}{T\gamma}{ TX \ToIso{\C} T^2X  }
	\Say{ (1) }{  \bd \TYPE{Coalgebra}(TX,\gamma') }{ \Big[ (TX,\gamma') :  \TYPE{Coalgebra}(T)  \Big] }
	\Say{(2)}{ \bd \gamma'(\gamma\gamma')}{\gamma\gamma' = \gamma T \gamma}
	\Say{(3)}{\bd^{-1} \TYPE{CoalgMorphism}(2)}{\Big[ \gamma : (X,\gamma) \Arrow{\mathsf{COALG}(T)}  (TX,\gamma') \Big]}
	\Say{f}{\bd \TYPE{Terminal}(\mathsf{COALG}(T))(X,\gamma)}{  (TX,\gamma') \Arrow{\mathsf{COALG}(T)} (X,\gamma) }
	\Say{(4)}{  \bd \TYPE{Terminal}(\mathsf{COALG}(T))(X,\gamma)(\gamma f) }{ \gamma f = {\id}_{(X,\gamma)} }
	\Say{(5)}{  \bd \Cov(T) (4)  \bd \TYPE{CoalgebraMorphism}(f)\bd \Cov(T) }
	{  \NewLine : {\id}_{(TX,T\gamma)} = T\Big({\id}_{(X,\gamma)}\Big) =T(\gamma f) = T \gamma Tf = f \gamma  }
	\Say{(6)}{\bd^{-1}\TYPE{Inverse}}{f = \gamma^{-1}}
	\Conclude{(*)}{\bd \mathsf{COALG}(\C)(T)(6) }{ \Big[ \gamma : X \ToIso{\C} TX \Big] }
	\EndProof
}
\newpage
\subsection{Functor Category}
\Page{
	\DeclareFunc{verticalCompositonOfNT}{\prod \A,\B : \Cat \. F,G,H : \Cov(\A,\B) \. \NewLine 
		\. (F \Rightarrow G) \times (G \Rightarrow H) \to (F \Rightarrow H)  }
	\DefineNamedFunc{verticalCompositionOfNT}{\alpha,\beta}{\alpha\beta}{ \prod X \in \A \. \alpha(X)\beta(X) }
	\Assume{X,Y}{\A}
	\Assume{f}{X \Arrow{\A} Y}
	\Say{(1)}{\bd \alpha(f)}{  \alpha(X)G(f) = F(f)\alpha(Y)   }
	\Say{(2)}{\bd \beta(f)}{ \beta(X)H(f) = G(f)\beta(Y) }
	\Conclude{()}{ \bd \alpha \beta \Big( \alpha\beta(X)H(f) \Big)(2)(1) \bd^{-1} \alpha \beta  }
	{  \NewLine :
		\alpha\beta(X) H(f) = \alpha(X)\beta(X)H(f) = \alpha(X)G(f)\beta(Y) = F(f)\alpha(Y)\beta(Y) = F(f)\alpha\beta(Y) }
	\DeriveConclude{(*)}{\bd^{-1} \NT(\A,\B)}{[ \alpha\beta : F \Rightarrow H  ]}
	\EndProof
	\\
	\DeclareFunc{functorCategory}{  \Cat \times \Cat \to \Cat }
	\DefineNamedFunc{functorCategory}{\A,\B}{\B^\A}
	{ \NewLine \de 
		\Big(  \Cov(\A,\B), (F,G) \mapsto F \Rightarrow G,  \FUNC{verticalCompositionOfNT},  
		F \mapsto \big(X \mapsto {\id}_{F(X)} \big) \Big)  
	}
	\\
}
\newpage
\subsection{2$\hyph$Category of All Categories}
\Page{
	\DeclareFunc{horisontalComposition}{\prod \A, \B, \C \in \Cat \. 
		\forall F,G : \Cov(\A,\B) \. \forall H,E : \Cov(\B,\C) \. \NewLine 
		\. (F \Rightarrow G) \times (H \Rightarrow E) \to (FH \Rightarrow GE)
	}
	\DefineNamedFunc{horisontalComposition}{\alpha,\beta}{\alpha * \beta }{ \prod X \in \A \. 
		H\big(\alpha(X)\big)\beta\big(G(X)\big)  }
	\Assume{X,Y}{\A}
	\Assume{f}{X \Arrow{\A} Y}
	\Say{(1)}{\bd \beta (\alpha(X))}{ \beta(F(X))E(\alpha(X)) = H(\alpha(X))\beta(G(X))  }
	\Say{(2)}{\bd \alpha( f )}{ \alpha(X)G(f) = F(f) \beta(X)   }
	\Say{(3)}{\bd \beta \Big( F(f) \alpha(Y)   \Big)}{ \beta(F(X)) E( F(f) \alpha(Y) ) =  H( F(f) \alpha(Y) ) \beta( G(Y) ) }
	\Conclude{(*)}{\bd \alpha * \beta (\alpha * \beta(X)GE(f))(1)\bd\Cov E (2)(3) \bd \Cov (H) \bd^{-1} \alpha * \beta}
	{ \NewLine : 
		\alpha * \beta(X) GE(f) = H\big(\alpha(X)\big)\beta\big(G(X)\big) GE(f) =  
		 \beta(F(X)) E(\alpha(X)) GE(f) = \beta(F(X)) E(\alpha(X) G(f)) = \NewLine 
		 = \beta(F(X)) E( F(f) \alpha(Y) ) =  H( F(f) \alpha(Y) ) \beta( G(Y) ) 
		 = FH(f) H( \alpha(Y) ) \beta(G(Y)) = FH(f) \alpha * \beta(Y)
	}
	\DeriveConclude{(*)}{\bd^{-1} \NT}{[\alpha * \beta : FH \Rightarrow GE]}
	\EndProof
	\\
	\Theorem{FourInterchangeLemma}{\forall \A,\B,\C : \Cat \. \forall F,G,H : \Cov(\A,\B) \. \forall K,L,M : \Cov(\B,\C) \. 
	        \NewLine \. \forall \alpha : F \Rightarrow G \. \forall \beta : G \Rightarrow H \. 
		\forall \gamma : K \Rightarrow L \. \forall \delta : L \Rightarrow M \. 
		 (\alpha\beta) * (\gamma \delta) = (\alpha * \gamma)(\beta * \delta)
	}
	\Assume{X}{\A}
	\Conclude{(*)}{ 
		\bd \FUNC{horisontalComposition} \bd \FUNC{verticalComposition} \bd \gamma (\beta(X))
		\bd \Cov(K)\NewLine 	
		\bd^{-1} \FUNC{horisontalComposition} \bd^{-1} \FUNC{verticalComposition}
	}
	{ \NewLine : 
		(\alpha \beta) * (\gamma \delta)(X) = K( \alpha \beta(X)  ) \gamma \delta (H(X)) = 
		K( \alpha(X) \beta(X) ) \gamma(H(X)) \delta(H(X)) = \NewLine = 
		K( \alpha(X)) K(\beta(X)) \gamma(H(X)) \delta(H(X)) =
		K( \alpha(X)) \gamma( G(X)) L(\beta(X)) \delta( H(X)) = (\alpha * \gamma)(\beta * \delta)(X)
	}
	\EndProof
	\\
	\DeclareType{TwoCategory}{ ?\sum \C : \Cat \. \sum \mathcal{F} : \prod A,B \in \C \. \Cat \.  
		\prod A,B,C \in \C \.  \NewLine \.  \forall A,B \in \C \. \Mor_{\C}(A,B) = \mathcal{F}(A,B) \And \NewLine \And
		\prod F,G \in \mathcal{F}(A,B) \. \prod H,E \in \mathcal{F}(B,C) \.
		\Mor_{\mathcal{F}(A,B)}(F,G) \times \Mor_{\mathcal{F}(B,C)}(H,E)  
		\to \Mor_{\mathcal{F}(A,C) }(FH,GE)   
	}
	\DefineNamedType{(\C,\mathcal{F},\mathrm{h})}
	{TwoCategory}{2\hyph\Cat}{ \forall A,B,C \in \C \. \forall f,g,h : A \Arrow{\C} B \.  
		\forall x,y,z : B \Arrow{\C} C \. \NewLine
		\forall \alpha : f \Arrow{\Mor_\C(A,B)}  g\. 
		\forall \beta  : g \Arrow{\Mor_\C(A,B)} h \. 
		\forall \gamma : x \Arrow{\Mor_\C(B,C)} y \.
		\forall \delta : y \Arrow{\Mor_\C(B,C)} z \. 
		\mathrm{h}(\alpha\beta,\gamma\delta) = \mathrm{h}(\alpha,\gamma)\mathrm{h}(\beta,\delta) \And \NewLine
		\And \Big( \C,  (A,B) \mapsto \sum f,g : A \Arrow{\C} B \.  f \Arrow{\Mor_{\C}(A,B)} g, \mathrm{h},
		  A \mapsto ({\id}_A,{\id}_A,{\id}_{{\id}_A})  \Big) : \Cat
	}
	\\
	\DeclareFunc{catCat}{2\hyph\Cat}
	\DefineNamedFunc{catCat}{}{\CAT}
	{\Big( (\Cat,\Cov,\circ,\mathrm{Id}), (\A,\B) \mapsto \B^\A, \FUNC{verticalComposition} \Big)}
	\\
	\DeclareFunc{synecdoche}{2\hyph\Cat \to \Cat}
	\DefineFunc{synecdoche}{ \C,\mathcal{F},\mathrm{h}  }{ \C  }
} \Page{
	\DeclareFunc{arrow2}{ \prod \C : 2\hyph\Cat \. \prod A,B  \in \C \. (A \Arrow{\C} B) \to \Class   
	}
	\DefineNamedFunc{arrow2}{f,g}{f \xRightarrow{\C} g}{\Mor_{\mathcal{F}(A,B)}(f,g) \quad \where \quad 
		\C = (\C, \mathcal{F}, \mathrm{h})}
	\\
	\DeclareFunc{composition2 }{ \prod \C : 2\hyph\Cat \. \prod A,B,C \in \C \. \prod f,g : A \Arrow{\C} B \. 
		\prod x,y : B \Arrow{\C} C \. \NewLine \.
		(f \xRightarrow{\C} g) \times (x \xRightarrow{\C} y) \to (fx \xRightarrow{\C} gy)
	}
	\DefineNamedFunc{ Composition2 }{\alpha, \beta }{ \alpha * \beta }
	{\mathrm{h}(\alpha,\beta) \quad \where \quad \C = (\C,\mathcal{F},\mathrm{h})}
}
\newpage
\section{Yoneda's Theory}
\subsection{Representation}
\Page{
	\DeclareFunc{toSetFunctor}{ \prod \C \in \CAT \.\C \Arrow{\CAT} \SET  }
	\DefineNamedFunc{toSetFunctor}{A}{\{\cdot\}(A)}{\{A\}}
	\DefineNamedFunc{toSetFunctor}{f}{\{\cdot\}_{A,B}(f)}{ A \mapsto B }
	\\
	\Theorem{InitialRepresentation}{ \forall \C \in \CAT \. \forall I \in \C \.
		\Big[I : \TYPE{Initial}(\C)\Big] \iff \Mor_\C(I,\cdot) \cong \{ \cdot\}
	}
	\Assume{(1)}{\Big[I : \TYPE{Initial}\Big]}
	\Assume{X}{\C}
	\Say{(2)}{ \bd \TYPE{Initial}(\C)(I)(X) }{ \Big[ \Mor_\C(I,X) : \TYPE{Singleton}\big(\Mor_\C(I,X)\big) \Big]}
	\Say{(f,3)}{ \bd \TYPE{Singleton}(2)  }{  \sum f : I \Arrow{\C} X \. \Mor_\C(I,X) = \{ f \}    }
	\Conclude{\alpha(X)(f)}{X}{ \{f\} \ToIso{\SET} \{ X \}  }
	\Derive{\alpha}{I\left( \prod \right)}{\prod X \in \C \. \Mor_\C(I,X) \iff \{ X \} }
	\Assume{X,Y}{\C}
	\Assume{\varphi}{ X \Arrow{\C} Y }
	\Conclude{() }{ \bd \TYPE{Singleton} }{   \varphi \alpha(Y)(f) = Y = \alpha(X) \{ \cdot \}(f)  }
	\Derive{(2)}{\bd^{-1} \TYPE{NaturalIso}}{ [\alpha : \Mor_\C(I,\cdot) \iff \{\cdot\}] }
	\Conclude{(3)}{\bd^{-1} \TYPE{Isomorphic}(2)}{\Mor_\C(I,\cdot) \cong \{ \cdot\}}
	\Derive{(1)}{I(\Rightarrow)}{\Big[ I : \TYPE{Initial}(\C)  \Big] \Rightarrow \Mor_\C(I,\cdot) \cong \{ \cdot \}}
	\Assume{(2)}{\Mor_\C(I,\cdot) \cong \{ \cdot \}}
	\Say{\alpha}{ \bd \TYPE{Isomorphic}(2) }{ \Mor_\C(I,\cdot) \iff \{ \cdot \} }
	\Assume{X}{\C}
	\Say{(3)}{\bd \alpha (X) }{ \Mor_{\C}(I,X) \cong_{\SET} \{ X \} }
	\Conclude{(4)}{\bd^{-1} \TYPE{Card}(3)}{ \Big| \Mor_{\C}(I,X) \Big| \cong \Big| \{ X \} \Big| }
	\DeriveConclude{()}{\bd^{-1} \TYPE{Initial}}{ \Big[ I : \TYPE{Initial}(\C) \Big]  }
	\Conclude{(*)}{I(\iff)(1)I(\Rightarrow)}{ \LOGIC{This}   }
	\EndProof
	\\
	\Theorem{TerminalRepresentation}{ \forall \C \in \Cat \. \forall T \in \C \. 
		\Big[ T : \TYPE{Terminal}(\C) \Big] \iff \Mor_{\C^\op}(\cdot,T) \cong \{ \cdot \}   }
	& \text{Apply dual trick.}\\
	\EndProof
}
\Page{
	\DeclareType{Representable}{ \prod \C \in \mathsf{LSCAT} \. ?\Func{\C}{\SET} }
	\DefineType{F}{Representable}{  \exists R \in \C \. |F| \cong \Mor_{|\C|_F}(R,\cdot)  }
	\\
	\DeclareType{RepresentedBy}{\prod \C \in \mathsf{LSCAT} \. \C \to \Func{\C}{\SET} }
	\DefineType{F}{RepresentedBy}{\Lambda R \in \C \. |F| \cong \Mor_{|\C|_F}(R,\cdot) }
	\\
	\DeclareType{Representing}{\prod \C \in \mathsf{LSCAT} \. \Func{\C}{\SET} \to ?\C}
	\DefineType{F}{Representing}{\Lambda F \in \Func{\C}{\SET} \. |F| \cong \Mor_{|\C|_F}(R,\cdot)}
	\\
	\Theorem{RepresentablePresevesMono}{\forall \C \in \mathsf{LSCAT} \. 
		\forall F : \TYPE{Representable}(\C) \And \Cov(\C,\SET) \.
		 \NewLine \. \forall A,B \in \C \. \forall f : A \ToMono{\C} B \. F_{A,B}(f) : F(A) \ToMono{\SET} F(B)  
		}
	\Say{(X,1)}{\bd \TYPE{Representable}(\C)(f)}{\sum X \in \C \. F \cong \Mor_{\C}(X,\cdot)}
	\Say{(2)}{(1)\bd \Mor_{\C}(X,\cdot)(f)}{ F(f) \cong f_* }
	\Conclude{(*)}{ (2)\THM{PushForwardOfMonoIsInjection}(X,A,B,f)}{\Big[ F(f) : \TYPE{Injection} \Big]}
	\EndProof
}
\newpage
\subsection{Yoneda's Lemma}
\Page{
	\Theorem{YonedasLemma}{
		\forall \C \in \mathsf{LSCAT} \. \forall F : \Cov(\C,\SET) \. 
		\forall X \in \C  \. F(X) \cong_\SET \Mor_{\SET^\C}\Big( \Mor_\C(X,\cdot), F  \Big)
	}
	\Assume{x}{F(X)}
	\Assume{A}{\C}
	\Conclude{\phi(x)(A)}{ \Lambda f \in \Mor_\C(X,A) \. F(f)(x)  }{ \Mor_\C(X,A) \to F(A) }
	\Derive{\phi(x)}{I\left(\prod\right)}{ \prod A \in \C \. \Mor_\C(X,A) \to F(A)  }
	\Assume{A,B}{\C}
	\Assume{f}{A \Arrow{\C} B}
	\Assume{g}{X \Arrow{\C} A}
	\Conclude{()}{\bd f_* \bd \phi(x)B \bd \Cov(\C,\SET)(F) \bd^{-1} \phi(x)(A)}{ \NewLine :
		f_* \phi(x)(B)(g) = \phi(x)(B)(gf) = F(gf)(x) = F(g)F(f)(x) = F(f)\Big(\phi(x)(A)(g)\Big)  }
	\DeriveConclude{() }{ I(=,\to) }{ f_* \phi(x)(B) = \phi(x)(A)F(f) }
	\DeriveConclude{()}{\bd^{-1} \NT}{ \phi(x) : \Mor_\C(X,\cdot) \Rightarrow F }
	\Derive{\phi}{I(\to)}{F(X) \to \Mor_\C(X,\cdot) \Rightarrow F}
	\Say{\psi}{ \Lambda \alpha : \Mor_\C(X,\cdot) \Rightarrow F \. \alpha(X)({\id}_{X})  }
	{      \Mor_\C(X,\cdot) \Rightarrow F \to F(X)  }
	\Say{(1)}{ \bd \phi \psi \bd \Cov(\C,\SET) \bd^{-1} {\id}_{F(X)}   }
	{\phi \psi = \Lambda x \in F(x) \. F({\id}_X)(x) = \Lambda x \in F(x) \. x =  {\id}_{F(X)}}
	\Say{(2)}{ \bd \psi \phi \Lambda \alpha \in \Mor_\C(X,\cdot) \. \bd \NT(\alpha) \bd^{-1} \id  }{ 
		\NewLine : \psi \phi = 
		\Lambda \alpha \in \Mor_\C(X,\cdot) \Rightarrow F \. \Lambda A \in \C \. 
		\Lambda f : X \Arrow{\C} A \.  F(f) \big(  \alpha(X)({\id}_X) \big) = \NewLine = 
		\Lambda \alpha \in \Mor_\C(X,\cdot) \Rightarrow F \. \Lambda A \in \C \.
		\Lambda f : X \Arrow{\C} A \. \alpha(A)(f) = \id_{ \Mor_\C(X,\cdot) \Rightarrow   F}
	}
	\Conclude{(*)}{\bd^{-1} \TYPE{Isomorphic}(1)(2)}{ F(X) \cong \Mor_{\SET^\C}\Big( \Mor_\C(X,\cdot),F \Big)  }
	\EndProof
	\\
	\DeclareFunc{functorOfYoneda}{\prod \C \in \mathsf{LSCAT} \. \Cov(\C,\SET) \to \Cov(\C,\SET)}
	\DefineNamedFunc{functorOfYoneda}{F,X}{\mathbb{Y}^F(X)}{\Mor_{\SET^\C}\Big( \Mor_{\C}(X,\cdot), F \Big)}
	\DefineNamedFunc{functorOfYoneda}{F,X,Y,f}{\mathbb{Y}^F_{X,Y}(f)}{ 
		\Lambda \alpha \in \mathbb{Y}^F(X) \. \Lambda g \in \Mor_{\C}(Y,A) \.  \alpha(A)( fg  )   }
	\\
	\DeclareFunc{mapOfYoneda}{
		\prod \C \in \Cat \.  \prod F : \Cov(\C,\SET) \. 
		\mathbb{Y}^F \iff F  
	}
	\DefineNamedFunc{mapOfYoneda}{X,\alpha}{Y^F(X)(\alpha)}{ \alpha(X)({\id}_X) }
	\Assume{A,B}{\C}
	\Assume{f}{A \Arrow{\C} B}
	\Conclude{()}{ 
		\bd Y^F(A) \Lambda \alpha \in \mathbb{Y}^F(A) \. \bd \alpha \bd f_* \bd^{-1} 
		\mathbb{Y}^F_{A,B} \bd^{-1} Y^f   
	}
	{  
		\NewLine :	
		Y^F(A)F_{A,B}(f) = \Lambda \alpha \in \mathbb{Y}^F(A) \. 
		F_{A,B}(f) \Big( \alpha(A)({\id}_A) \Big) = \NewLine =    
		\Lambda \alpha \in \mathbb{Y}^F(A) \. \alpha(A)F_{A,B}(f) ({\id}_A) =  
		\Lambda \alpha \in \mathbb{Y}^F(A) \. f_* \alpha(B)( {\id}_A) =
		\Lambda \alpha \in \mathbb{Y}^F(A) \. \alpha(B)(f) = \NewLine = 
		\Lambda \alpha \in \mathbb{Y}^F(A) \. \mathbb{Y}^F(f) (\alpha)({\id}_B)
		   = \mathbb{Y}^F_{A,B}(f)Y^F(B)  
	}
	\DeriveConclude{(*)}{\bd^{-1}\TYPE{NaturalIso}}{ \Big[Y^F : \mathbb{Y}^F(f) \iff F\Big]  }
	\EndProof
}\Page{
	\DeclareFunc{functorOfYoneda2}{ \prod \C \in \mathsf{LSCAT} \. \C \to \Cov\Big( \SET^\C_{\mathrm{Cov}}, \SET \Big)   }
	\DefineNamedFunc{functorOfYoneda2}{X,F}{\mathbb{Y}^X(F)}{ \Mor_{\SET^\C}\Big( \Mor_{\C}(X,\cdot),F\Big)}
	\DefineNamedFunc{functorOfYoneda2}{X,F,G,\alpha}{\mathbb{Y}^X_{F,G}(\alpha)}{ 
		\Lambda  \beta : \Mor_\C(X, \cdot) \Rightarrow F \. \beta \alpha   }
	\\
	\DeclareFunc{evaluationFunctor}{\prod \C \in \CAT \. \C \to \Cov(\SET^\C,\C)}
	\DefineNamedFunc{evaluetionFuncor}{X,F}{\mathrm{Ev}^X(F)}{F(X)}
	\DefineNamedFunc{evaluationFunctor}{X,F,G,\alpha}{\mathrm{Ev}^X_{F,G}(\alpha)}{ \alpha(X) } 
	\\
	\DeclareFunc{mapOfYoneda2}{\prod \C \in \mathsf{LSCAT} \.  \prod X \in \C \. \mathbb{Y}^X \iff \mathrm{Ev}^X}
	\DefineNamedFunc{mapOfYoneda2}{F,\alpha}{Y^X(F)(\alpha)}{ \alpha(X)(\mathrm{id}_X)}
	\Assume{F,G}{\Cov(\C,\SET)}
	\Assume{\alpha}{  F \Rightarrow G  }
	\Conclude{()}{ 
		\bd \mathrm{Ev}^X_{F,G} \bd Y^X(F) \bd^{-1} \FUNC{verticalComposition}(\alpha,\beta)   
		\bd^{-1} \mathbb{Y}^X_{F,G} \bd^{-1} Y^X(G)
	}{ \NewLine : 
		Y^X(F)\mathrm{Ev}^X_{F,G}(\alpha) = 
		Y^X(F)\alpha(X) = 
		\Lambda \beta \in \mathbb{Y}^X(F) \. \alpha(X)\Big( \beta(X)(\mathrm{id}_X) \Big) = \NewLine =
		\Lambda \beta \in \mathbb{Y}^X(F) \. \beta \alpha (X)(\mathrm{id}_X) = 
		\mathbb{Y}^X_{F,G}(\alpha) Y^X(G)                        
	}
	\DeriveConclude{(*)}{\bd^{-1} \TYPE{naturalIso}}{\Big[Y^X : \mathbb{Y}^X \iff \mathrm{Ev}^X\Big]}
	\EndProof
	\\
	\Theorem{DualYonedasLemma }{ \forall \C \in \mathsf{LSCAT} \. \forall F : \Contra(\C,\SET) \. \forall  X \in \C \. 
		\NewLine \. \Mor_{ \SET^\C}\Big(  \Mor(\cdot,X) , F \Big) \cong_\SET F(X)
	}
	& \text{Apply dual trick to Yoneda's Lemma} \\
	\EndProof
}
\newpage
\subsection{Yoneda's Embedding}
\Page{
	\DeclareFunc{embeddingOfYoneda}{\prod \C \in \mathsf{LSCAT} 
		\. \TYPE{FullyFaithful} \And \TYPE{Embedding}( \C, \SET^{\C^\op})}
	\DefineNamedFunc{embeddingOfYoneda}{X}{\mathrm{y}(X)}{\Mor_\C(\cdot, X)}
	\DefineNamedFunc{embeddingOfYoneda}{X,Y,f}{\mathrm{y}_{X,Y}(f)}{f_*}
	\\
	\DeclareFunc{embeddingOfYoneda2}{\prod \C \in \mathsf{LSCAT} 
		\. \TYPE{FullyFaithful}\And \TYPE{Embedding}( \C^\op, \SET^{\C})}
	\DefineNamedFunc{embeddingOfYoneda2}{X}{\mathrm{y}(X)}{\Mor_\C(X, \cdot)}
	\DefineNamedFunc{embeddingOfYoneda2}{X,Y,f}{\mathrm{y}_{X,Y}(f)}{f^*}
}
\newpage
\subsection{Universal Property}
\Page{
	\DeclareType{UniversallyEq}{\prod \C \in \mathsf{LSCAT} \. ?\Big( \C \times \C \Big)  }
	\DefineType{A,B}{UniversallyEq}{ \mathrm{y}(A) \cong \mathrm{y}(B)  }
	\\
	\Theorem{UniversallyEqAreIsomorphic}{\prod \C \in \mathsf{LSCAT} \. \forall A,B \in \C 
		\big[(A,B) : \TYPE{UniversallyEq}(\C)\big] \iff A \cong_\C B  }
	& \text{Use the fact that fully faithful functor both creates and preserves isomorphism} \\
	\EndProof
	\\
	\Conclude{\UMP}{\Lambda \A,\B \in \CAT \. \Lambda F : \Cov(\A,\B) \. \Lambda B \in \B \. \NewLine \. 
		\TYPE{Initial}\Big( \mathrm{Const}(B) \downarrow F \Big)    } 
	{ \prod \A,\B \in \CAT \. \Cov(\A,\B) \to \B \to \Type }
	\\
	\DeclareFunc{mediatingMorphismMap}{ \prod (1,A,f) : \UMP(\A,\B, F, B ) \. \prod X \in  \A \. \NewLine 
		 \. \Mor_\B(B, F(X)) \to \Mor_\A(A,X)   }
	\DefineNamedFunc{mediatingMorphismMap}{g}{\tau_{B,X}(A,f)(g)}
	{ \Big(\bd \TYPE{Initial}(\mathrm{Const}(B) \downarrow F)(1,A,f)(1,X,g) \Big)_2    }
	\\
	\Theorem{MediatingInverse}
	{ 
		\forall (1,A,f) : \UMP(\A,\B,F,B) \. \forall X \in \A \. \NewLine \. 
		\forall h : A \Arrow{\B} X  \.  \tau_{B,X}(A,f) \Big( f F(h) \Big) = h
	}
	\Say{g}{f F(h)}{B \Arrow F(X)}
	\Say{(1) }{\bd g }{f F(h) = g}
	\Say{(2)}{\bd \mathrm{Const}(B) \downarrow F}{\Big[(\id,h) : (1,A,f) \Arrow{\mathrm{Const}(B) \downarrow F} (1,X,g)\Big]}
	\Conclude{(*)}{E\LOGIC{Unique}\bd \TYPE{Initial}(\mathrm{Const}(B) \downarrow F)(1,A,f)}
	{ \tau_{B,X}(A,f)\Big( f F(h) \Big) = h }
	\EndProof
	\\
	\Theorem{MediatingInverseFormula}{ \forall (1,A,f) : \UMP(\A,\B,F,B) \. \forall X \in \A \. \NewLine 
		\tau_{B,X}^{-1}(A,f) = \Lambda h : X \Arrow{\A} A \.  fF(h) }
	\NoProof
	\\
	\Theorem{MediatingFormula}{\forall (1,A,f) : \UMP(\A,\B,F,B) \. \forall X \in \A \. \NewLine \.
	 \forall g : B \Arrow{\B} F(X) \. f F\big( \tau_{B,X}(A,f)(g) \big) = g
	}
	\Say{(1)}{\THM{MediatingInverse}(1,A,f)(X)\Big( \tau_{B,X}(A,f)(g)  \Big)}
	{  \tau_{B,X}(A,f) \Big( f F\big( \tau_{B,X}(A,f)(g) \big) \Big) =  \tau_{B,X}(A,f)(g)         }
	\Conclude{(*)}{\tau^{-1}_{B,X}(A,f)(1)}{ f F\big( \tau_{B,X}(A,f)(g) \big) 
	}
	\EndProof
} \Page{
	\Theorem{MediatingMorphismsAreNatural}
	{  \forall  (1,A,f) : \UMP(\A,\B,F,B)  \. 
		\NewLine 
		\tau_{B,\cdot}(A,f) : F\Mor_\B(B,\cdot) \iff \Mor_\A(A,\cdot)  
	}
	\Assume{X,Y}{\A}
	\Assume{y}{ X \Arrow{\A} Y  }
	\Assume{g }{ B \Arrow{\B} F(X)}
	\Conclude{()}{\bd \Cov(F)\THM{MediatingFormula}(A,f)(X)(g)}
	{ f F(\tau_{B,X}(A,f)(g)y) =  f F(\tau_{B,X}(A,f)g)F(y)  =gF(y)  }
	\Derive{(1)}{\bd \mathrm{Const}(B) \downarrow F}
	{\Big[ \tau_{B,X}(A,f)(g)y : (1,A,f) \Arrow{\mathrm{Const}(B) \downarrow F} (1,Y,gF(y)) \Big]}
	\Conclude{()}{ \bd \big( F(y) \big))* \bd \tau_{B,Y}(A,f) \bd \UMP(1,A,f)(1)   }
	{  
		\NewLine:
		\big(F(y)\big)_*\tau_{B,Y}(A,f) = \Lambda g : B \Arrow{\B} F(X) \.  \tau_{B,Y}(A,f)(gF(y))  = \NewLine   
		= \Lambda g : B \Arrow{\B} F(X) \.    \tau_{B,X}(A,f)(g)y  =  \tau_{B,X}(A,f)y_*
	}
	\DeriveConclude{()}{\bd \TYPE{NaturalIso}}{ \tau_{B,\cdot}(A,f) : F\Mor_\B(B,\cdot) \iff \Mor_\A(A,\cdot) }
	\EndProof
	\\
	\Theorem{UniversalPropertyIsUnique}{
		\forall \A,\B \in \CAT \. \forall F : \Cov(\A,\B) \. \forall B \in \B \. \NewLine \.
		\forall (T,f),(S,g) : \UMP(\A,\B,F,B) \. \exists \alpha : T \ToIso{\A} S : g = f F(\alpha)
	}
	& \text{ Use properties of initial objects.} \\
	\EndProof
	\\
	\Conclude{\CMP}{\prod \A,\B \in \CAT \. \prod F : \A \Arrow{\CAT} \B \. \prod B \in \B \. \NewLine \.
	       \TYPE{Terminal}\big(F \downarrow \mathrm{Const}(B) \big) }{\prod \A, \B \in \Cat \. 
	       \A \Arrow{\CAT} \B \to \B  \to \Type}
	\\
	\DeclareFunc{comediatingMorphismMap}{ \prod (A,1,f) : \CMP(\A,\B, F, B ) \. \prod X \in  \A \. \NewLine 
		 \. \Mor_\B(F(X), A) \to \Mor_\A(X,A)   }
	\DefineNamedFunc{comediatingMorphismMap}{g}{\mu_{B,X}(A,f)(g)}
	{ \Big(\bd \TYPE{Terminal}(F \downarrow \mathrm{Const}(B) )(A,1,f)(X,1,g) \Big)_2    }
	\\
	\Theorem{ComediatingInverseFormula}{ \forall (A,1,f) : \CMP(\A,\B,F,B) \. \forall X \in \A \. \NewLine 
		\mu_{B,X}^{-1}(A,f) = \Lambda h : X \Arrow{\A} A \.  F(h)f }
	\NoProof
	\\
	\Theorem{comediatingFormula}{\forall (A,1,f) : \CMP(\A,\B,F,B) \. \forall X \in \A \. \NewLine \.
	 \forall g : F(X) \Arrow{\B} B  \.  F\big( \mu_{B,X}(A,f)(g) \big)f = g
	}
	\NoProof
} \Page{
	\Theorem{comediatingMorphismsAreNatural}
	{  \forall  (A,f) : \UMP(\A,\B,F,B)  \. 
		\NewLine 
		\tau_{B,\cdot}(A,f) : F\Mor_\B(\cdot, B) \iff \Mor_\A(\cdot,A)  
	}
	\NoProof
}
\newpage
\subsection{Category of Universal Elements}
\Page{
	\DeclareFunc{categoryOfElements}{ \prod \C \in  \CAT \.  \Cov\Big( \C, \SET \Big) \to \CAT }
	\DefineNamedFunc{categoryOfElements}{F}{\int \!\!\! F}{ \NewLine \de \Big( \sum X \in \C \. F(X), 
		\big((X,x),(Y,y)\big) \mapsto \{ f : X \Arrow{\C} Y : F(f)(x) = y  \}, \cdot_{\C}   ,\id  \Big)  }
	\\
	\DeclareFunc{categoryOfElements2}{\prod \C \in \CAT \. \Contra\Big(\C, \SET \Big) \to \CAT}
	\DefineNamedFunc{categoryOfElements2}{F}{\int \!\!\! F}{
		\NewLine \de
		\Big( \sum C \in \. F(X), \big( (X,x),(Y,y) \big) \mapsto \{ f : X \Arrow{\C} Y : F(f)(x) = y \},\cdot_{\C},\id \Big)
		}
	\\
	\DeclareFunc{projectionFunctor }{ \prod \C \in \CAT \. \prod F : \Cov\Big( \C, \SET \Big) \. 
		\Cov\left( \int \!\!\! F, \C \right)}
	\DefineNamedFunc{projectionFunctor}{X,x}{\Pi(X,x)}{X}
	\DefineNamedFunc{projectionFunctoe}{(X,x),(Y,y),f}{\Pi( f )}{f}
	\\
	\Theorem{ElementsAsComma}{ \forall \C \in \CAT \. \forall F : \Contra(\C,\SET) \. 
		\int \!\!\! F \simeq \mathrm{y} \downarrow \mathrm{Const}(F) }
	\Assume{(X,x)}{\int \!\!\! F}
	\Assume{A}{\C}
	\Conclude{\alpha(A)}{\Lambda f \in \Mor_\C(A,X) \.F(f)(x) }{\Mor_\C(A,X) \to F(A)}
	\Derive{\alpha}{ I\left(\prod\right)I(\to)  }{ \prod A \in \C \. \Mor_\C(A,X) \to F(A)}
	\Assume{A,B}{\C}
	\Assume{f}{B \Arrow{\C} A}
	\Conclude{()}{ \bd f^* \. \bd \alpha(B) \bd \Contra(\C,\SET)(F) \bd \bd^{-1} \alpha(A)  }{ \NewLine :
		f^* \alpha(B) = 
		\Lambda g \in \Mor_\C(A,X) \. \alpha(B)(fg) = 
		\Lambda g \in \Mor_\C(A,X) \. F(fg)(x) = \NewLine =
		\Lambda g \in \Mor_\C(A,X) \. F(g)F(f)(x)  = 
		 \alpha(A) F(f)
	}
	\Derive{()}{\bd^{-1} \NT}{\big[\alpha : \Mor_\C(\cdot,X) \Rightarrow F\big]} 
	\Say{ G'(X,x) }{ (X,1,\alpha ) }{ \mathrm{y} \downarrow \mathrm{Const}(F)  }
	\Derive{G'}{I(\to)}{\int \!\!\! F \to \mathrm{y} \downarrow \mathrm{Const}(F) }
	\Assume{f}{(X,x) \Arrow{\int \!\! F} (Y,y)}
	\Say{G''\Big((X,x),(Y,y)\Big)(f)}{(f,{\id}_1)}{ \Big(X \Arrow{\C} Y \Big) \times \Big(1 \Arrow{\mathbf{1}} 1\Big)  }
	\Say{(X,1,\alpha)}{G'(X,x)}{\mathrm{y} \downarrow \mathrm{Const}(F)}
	\Say{(Y,1,\beta)}{G'(Y,y)}{\mathrm{y} \downarrow \mathrm{Const}(F)}
} \Page{
	\Conclude{()}{ 
		\bd \Cov\Big(\mathbf{1},\SET^{\C^\op} \Big) \bd \alpha \bd^{-1}\FUNC{categoryOfElements}(f) 
		\bd \Contra(\C,\SET)(F) \bd^{-1}\beta \bd^{-1} f_* 
	}{ 
		\NewLine :
		\alpha \mathrm{Const}(F)({\id}_1)  = 
		\alpha {\id}_F = 
		\Lambda A \in \C \. \Lambda g \in \Mor_\C(A,X) \. F(g)( x )  = \NewLine = 
		\Lambda A \in \C \. \Lambda g \in \Mor_\C(A,X) \.  F(f)F(g)(y) =
		\Lambda A \in \C \. \Lambda g \in \Mor_\C(A,X) \. F(gf)(y) =
		f_* \beta
	}
	\Derive{G''}{I\left(\prod\right)I(\to)}{
		\prod (X,x),(Y,Y) \in \int \!\!\! F \. (X,x) \Arrow{\int \!\! F} (Y,y) \to 
		G'(X,x) \Arrow{\mathrm{y} \downarrow \mathrm{Const}(F) } G'(Y,y) 
	}
	\Say{G}{(G',G'')}{\Cov\left( \int \!\!\! F,  \mathrm{y} \downarrow \mathrm{Const}(F)  \right)}
	\Assume{(X,1,\alpha)}{ \mathrm{y} \downarrow \mathrm{Const}(F)}
	\Say{x}{\alpha(X)({\id}_X)}{F(X)}
	\Conclude{H'(X,1,\alpha)}{(X,x)}{\int \!\!\! F}
	\Derive{H'}{I(\to)}{ \mathrm{y} \downarrow \mathrm{Const}(F) \to \int \!\!\! F }
	\Assume{(X,1,\alpha),(Y,1,\beta)}{\mathrm{y} \downarrow \mathrm{Const}(F)}
	\Assume{(f,\id)}{(X,1,\alpha) \Arrow{\mathrm{y}\downarrow \mathrm{Const}(F)} (Y,1,\beta)}
	\Say{H''(f,\id)}{f}{ X \Arrow{\C^\op} Y  }
	\Say{(1)}{\bd \FUNC{commaCategory}(f)}{ \forall A \in \C \. \alpha(A)  = f_*\beta(A)  }
	\Conclude{(2)}{  (1)(X) \bd^{-1} f^*  \bd \NT(\beta)f}{
		\alpha(X)({\id}_X) = 
		f_* \beta(X)({\id}_X) =
		f^* \beta(X)({\id}_Y) =  \NewLine 
		= F(f)\big(\beta(Y)(\mathrm{id}_Y) \big) 
	}
	\Derive{H''}{I\left( \prod \right)I(\to)}{
		\prod (X,1,\alpha),(Y,1,\beta) \in \mathrm{y} \downarrow \mathrm{Const}(F) \. \NewLine \.
		(X,1,\alpha) \Arrow{\mathrm{y} \downarrow \mathrm{Const}(F)} (Y,1,\beta) \to
		H'(X,1,\alpha) \Arrow{\int \!\! F} H'(Y,1,\beta))
	}
	\Say{H}{(H',H'')}{ \Cov\left( \mathrm{y} \downarrow \mathrm{Const}(F), \int \!\!\! F \right) }
	\Assume{(X,x)}{\int \!\!\! F}
	\Conclude{()}{\bd G \bd H}{ 
		GH(X,x) = 
		H\Big(X,1, \Lambda A \in \C \. \Lambda f : A \Arrow{\C} X \. F(f)(x)  \Big) =
		\big( X, F({\id}_X)(x)\big) = 
		(X,X)
	}
	\Derive{(1)}{I(\forall)}{\forall (X,x) \in \int \!\!\! F \. GH(X,x) = (X,x)}
	\Assume{(X,1,\alpha)}{\mathrm{y} \downarrow \mathrm{Const}(F)}
	\Conclude{()}{\bd H \bd G \bd \NT(\alpha)\bd^{-1} \alpha}{           
		HG(X,1,\alpha) = 
		G\big(X,\alpha(X)({\id}_X)\big) = \NewLine =
		\Big(X,1, \Lambda A \in \C \. \Lambda f \in \Mor(A,X) \. F(f) ( \alpha(X)({\id}_X)  )  \Big) = \NewLine =
		\Big( X,1, \Lambda A \in \C \. \Lambda f \in \Mor(A,X) \.  \alpha(A)(f)\Big) = 
		(X,1,\alpha)
	}
	\Derive{(2)}{I(\forall)}
	{\forall (X,1,\alpha) \in \mathrm{y} \downarrow \mathrm{Const}(F) \. HG(X,1,\alpha) = (X,1,\alpha)}
	\Say{(3)}{(1)(2)}{HG = \mathrm{Id} \and GH = \mathrm{Id}}
	\Conclude{(*)}{\bd^{-1} \TYPE{Isomorphic}(\CAT)(3)}{\int \!\!\! F \cong_\CAT \mathrm{y} \downarrow \mathrm{Const}(F)  }
	\EndProof
}
\Page{
	\Theorem{RepresentableIffInitialElement }{ 
		\forall \C \in \mathsf{LSCAT} \. \forall F : \Cov(\C,\SET) \. \NewLine \. 
		\Big[F : \TYPE{Representable}(\C)\Big] \iff \exists \TYPE{Initial}\left( \int \!\!\! F \right)
	}
	\Assume{(1)}{\Big[ F : \TYPE{Representable}(\C)\Big]}
	\Say{(X,\alpha)}{ \bd \TYPE{Representable}(\C)(F) }{ \prod X \in \C \. \Mor_\C(X,\cdot) \iff F  }
	\Assume{(A,\alpha(f))}{ \int \!\!\! F    }
	\Conclude{()}{\bd \int \!\!\! F \bd^{-1} \Mor_{\int \!\! F}(X, \alpha_X({\id}_X))(A,\alpha_A(f))}{
		\Mor_{\int \!\! F}\Big((X,\alpha_X({\id}_X)),(A,\alpha_A(f))\Big) = \{ f \}}
	\DeriveConclude{()}{\bd^{-1}\TYPE{Initial}}{\left[ (X, \alpha_X({\id}_X) ) : \TYPE{Initial}\left( \int F \right) \right]}
	\Derive{(1)}{I(\Rightarrow)}{\Big[F : \TYPE{Representable}\Big] \Rightarrow \exists \TYPE{initial}
		\left( \int \!\!\! F \right)}
	\Assume{(X,x)}{\TYPE{Initial}\left( \int \!\!\! F \right)}
	\Assume{A}{\C}
	\Assume{f}{\Mor_\C(X,A)}
	\Conclude{\alpha(A)(f)}{ F(f)(x)}{F(A)}
	\Derive{\alpha}{I\left(\prod\right)I(\to)}{ \Mor_\C(X,\cdot) \Rightarrow F  }
	\Assume{A}{\C}
	\Assume{a}{F(A)}
	\Say{(f,2)}{\bd \TYPE{Initial}\left( \int \!\!\! F\right)(X,x)}{\sum f : (X,x) \Arrow{\int \!\! F} (A,a) \. 
		\Mor_{\int \!\! F}\Big( (X,x),(A,a)\Big) = \{ f \}   }
	\Say{(3)}{\bd \int \!\!\! F(f)}{F(f)(x) = a}
	\Conclude{\beta(A)(a)}{f}{X \Arrow{\C} A}
	\Derive{\beta}{I\left(\prod\right)I(\to)}{\prod A \in \C \. F(A) \to X \Arrow{\C} A}
	\Assume{A,B}{\C}
	\Assume{\phi}{A \Arrow{\C} B}
	\Assume{a}{F(A)}
	\Say{(3)}{\bd \beta(A)(a)(x)}{\beta(A)(a)(x) = a}
	\Say{(4)}{F(\phi)(3)}{\beta(A)(a)F(\phi)(x) = F(\phi)(a)}
	\Say{(5)}{\bd \beta(B)(F(\phi)(a))(x)}{\beta(B)(F(\phi)(a))(x) = F(\phi)(a)}
	\Say{(6)}{\bd \beta \bd \TYPE{Initial}\left( \int \!\!\! F\right)(X,x)}{\beta(B)(F(\phi))(a) = \beta(A)(a)}
	\Conclude{()}{\bd \phi_*(6)}{ 
		\beta(A)\phi_*(a) =  \beta(A)(a)\phi 
		= \beta(B)\big( F(\phi)(a) \big)  
		= F(\phi)\beta(B)(a)
		}
	\Derive{(3)}{\bd^{-1} \NT}{\left[\beta : F \Rightarrow \Mor_C(X,\cdot) \right]}
} \Page{
	\Assume{A}{\C}
	\Assume{f}{X \Arrow{\C} A}
	\Conclude{()}{\bd \alpha(A)\bd\beta(A)\bd \TYPE{Initial}\left( \int \!\!\! F\right)(X,x) }
	{\alpha(A)\beta(A)(f) = \beta(A)\big(F(f)(x)\big) = f}
	\Derive{(4)^*}{I(=,\to)}{\alpha(A)\beta(A) = \id}
	\Assume{a}{F(A)}
	\Conclude{()}{\bd \beta(A) \bd \alpha(A) \bd \TYPE{Initial}\left( \int \!\!\! F \right)(X,x) }
	{ \beta(A)\alpha(A)(a) = a }
	\DeriveConclude{()}{ I(=,\to)}{ \beta(A)\alpha(A) = \id}
	\Derive{(4)}{\bd \TYPE{Inverse}}{\beta = \alpha^{-1}}
	\Say{(5)}{ \bd^{-1} \TYPE{NaturalIso} }{\big[\alpha : \Mor(X,\cdot) \iff F\big]}
	\Conclude{()}{ \bd^{-1}\TYPE{Representable}   }{\Big[ F : \TYPE{Representable}(\C) \Big] }
	\DeriveConclude{()}{ I(\iff)(1)I(\Rightarrow)  }{\LOGIC{This}}
	\EndProof
	\\
	\Theorem{RepresentableIffTerminalElements}{ 
		\forall \C \in \CAT \.  \forall F : \TYPE{Contra}(\C,\SET) \.  \NewLine \. 
		\Big[ F : \TYPE{Reprsentable}(\C) \Big] \iff \exists \TYPE{Terminal}\left( \int \!\!\! F \right)
	}
	& \text{Apply dual trick to previous theorem.} \\
	\EndProof
	\\
	\DeclareType{ContractibleGroupoid}{ ?\CAT}
	\DefineType{F}{ContractibleGoupoid}{\forall A,B \in \C \. \exists f : A \ToIso{\C} B \. \Mor_\C(A,B) = \{ f \}}
	\\
	\Theorem{RepresentationSpanCG}{ \forall \C \in \CAT \. \forall F : \TYPE{Representable}(\C) \.
			\NewLine \.
			\FUNC{cat}\left( \int \!\!\! F,   \TYPE{Representation}(F) \right) 
			: \TYPE{ContractibleGroupoid}
		}
	& \text{Use the fact that every representation corresponds to an initial object and all initial objects are isomotphic.} \\
	\EndProof
}\Page{
	\Theorem{ElementsAsComma2}{ \forall \C \in \mathsf{LSCAT} \. 
			\forall F : \Cov(\C,\SET) \.  \int \!\!\! F \cong_{\Cat} \mathrm{Const}\big(\{1\}\big) \downarrow F }
	\Assume{(X,x)}{\int \!\!\! F}
	\Conclude{G'(X,x)}{(1,X,x)}{ F \downarrow \mathrm{Const}\big(\{1\}\big)}
	\Derive{G'}{I(\to)}{ \int \!\!\! F \to F \downarrow \mathrm{Const}\big(\{1\}\big)}
	\Assume{(X,x),(Y,y)}{\int \!\!\! F}
	\Assume{f}{(X,x) \Arrow{\int \!\! F} (Y,y)}
	\Say{G''(f)}{(\id,f)}{(1 \Arrow{\mathbf{1}} 1) \times (X \Arrow{\C} Y)}
	\Conclude{()}{\bd f }{  y = f(x) }
	\Derive{G''}{I\left( \prod \right)I(\to)}{ \prod (X,x),(Y,y) \in \int \!\!\! F \. 
		\Big((X,x) \Arrow{\int \!\! F} (Y,y)\Big) \to 
		\Big( (1,X,x) \Arrow{ \mathrm{Const}(\{1\}) \downarrow F  } (1,Y,y)  \Big)}
	\Say{G}{(G',G'')}{\Cov\left( \int \!\!\! F, \mathrm{Const}\big(\{1\}\big) \downarrow F \right)}
	\Assume{(1,X,x)}{\mathrm{Const}\big(\{1\}\big) \downarrow F}
	\Conclude{H'(1,X,x)}{(X,x)}{\int \!\!\! F}
	\Derive{H'}{I(\to) }{ \Big( \mathrm{Const}\big(\{1\}\big) \downarrow  F \Big) \to \int \!\!\! F }
	\Assume{(1,X,x),(1,Y,y)}{\mathrm{Const}\big(\{1\}\big) \downarrow F }
	\Assume{(\id,f)}{ (1,X,x) \Arrow{} (1,Y,y)}
	\Say{H''(\id,f)}{ f }{X \Arrow{\C} Y}
	\Conclude{()}{\bd f}{f(x) = y}
	\Derive{H''}{I\left( \prod \right)I(\to)}{\prod (1,X,x),(1,Y,y) \in \mathrm{Const}\big( \{1\} \big) \downarrow F
		\.  \NewLine \. \Big( (1,X,x) \to (1,Y,y)  \Big) \to ( (X,x) \to (Y,y)   )
	}
	\Say{H}{(H',H'')}{\Cov\left( \mathrm{Const}(\{1\}) , \int \!\!\! F   \right)}
	\Say{(1)}{\bd H \bd G}{ H = G^{-1} }
	\Conclude{(*)}{\bd \TYPE{Isomorphic}(\CAT)}{ \int \!\!\! F \cong_{\CAT} \mathrm{Const}\big(\{1\}\big) \downarrow F  }
	\EndProof
	\\
	\DeclareFunc{twistedArrows}{\mathsf{LSCAT} \to \CAT}
	\DefineNamedFunc{twistedArrows}{\C}{\C^\leadsto}{\int \Mor_\C}
	\\
	\DeclareFunc{elemants}{\prod \C \in \CAT \. \Cov\left( \SET^\C,  \frac{\CAT}{\C}   \right)}
	\DefineNamedFunc{elements}{F}{\int F}{\left( \int F, \Pi\right)}
	\DefineNamedFunc{elements}{F,G,\alpha}{\int_F^G\alpha}
	{ \left( \Lambda (X,x) \in \int \!\!\! F \. (X,\alpha(X)(x)), \id \right)  }
}
\newpage
\section{Limits and Colimits}
\subsection{From Cones and Cocones to Limits and Colimits}
\Page{
	\DeclareFunc{ConstantFunctor}{ \prod \C,\I \in \CAT \. \C \to \I \Arrow{\CAT} \C}
	\DefineNamedFunc{ConstantFunctor}{\I,A}{ \mathrm{Const}_{\I}(A)}{ (X \mapsto A, f \mapsto {\id}_X)   } 
	\\
	\DeclareFunc{FunctorEmbedding}{\prod \C,\I \in \Cat \. \C \Arrow{\CAT} \C^\I}
	\DefineNamedFunc{FunctorEmbeddibg}{A}{ \Delta_{\I}(A)  }{
		\Big( X \mapsto \mathrm{Const}_{\I}(A), f \mapsto \Lambda i \in \I \. f \Big) }
	\\
	\Conclude{\TYPE{Cone}}{ \prod \C \in \CAT \. ?\sum  (\I, D) : \TYPE{Diagram}(\C) \. \sum A \in \C \. 
		 \Delta_{\I}(A) \Rightarrow D  }{ \CAT \to \Type}
	\\
	\DeclareFunc{summit}{\TYPE{Cone}(\C) \to  \C  }
	\DefineFunc{summit}{ (\I,D),A ,\lambda   }{A}
	\\
	\DeclareFunc{synecdoche}{\TYPE{Cone}(\C) \to \CAT}
	\DefineFunc{synecdoche}{(\I,D),A,\lambda}{\I}
	\\
	\DeclareFunc{synecdoche}{\prod \big((\I,D),A,\lambda\big) : \TYPE{Cone}(\C) \. \I \FUNC{\CAT} \C   }
	\DefineFunc{sunecdoche}{}{D}
	\\
	\DeclareFunc{legs}{\prod C : \TYPE{Cone}(\C) \. \Delta_C\big(\FUNC{summit}(C)\big) \Rightarrow C}
	\DefineNamedFunc{legs}{}{\lambda^C}{\lambda \quad \where \quad \big( (\I,D),A,\lambda \big) = C}
	\\
	\Conclude{\TYPE{Cocone}}{ \prod \C \in \CAT \. ?\sum  (\I, D) : \TYPE{Diagram}(\C) \. \sum A \in \C \. 
		 D \Rightarrow \Delta_{\I}(A)  }{ \CAT \to \Type}
	\\
	\DeclareFunc{nadir}{\TYPE{Cocone}(\C) \to  \C  }
	\DefineFunc{nadir}{ (\I,D),A ,\lambda   }{A}
	\\
	\DeclareFunc{synecdoche}{\TYPE{Cocone}(\C) \to \CAT}
	\DefineFunc{synecdoche}{(\I,D),A,\lambda}{\I}
	\\
	\DeclareFunc{synecdoche}{\prod \big((\I,D),A,\lambda\big) : \TYPE{Cocone}(\C) \. \C \FUNC{\CAT} \I   }
	\DefineFunc{sunecdoche}{}{D}
	\\
	\DeclareFunc{legs}{\prod C : \TYPE{Cocone}(\C) \. C \Rightarrow \Delta_C\big(\FUNC{summit}(C)\big) }
	\DefineNamedFunc{legs}{}{\lambda^C}{\lambda \quad \where \quad \big( (\I,D),A,\lambda \big) = C}
}
\Page{
	\DeclareFunc{coneCategory}{ \TYPE{Diagram}(\C) \to \CAT   }
	\DefineNamedFunc{coneCategory}{(\I,D)}{\mathsf{CONE}_\C(\I,D)}
	{ 
		\NewLine \de \Big( \{ C : \TYPE{Cone}(\C) : (\I,D) = (C,C)  \}, A,B \mapsto 
		\big\{ f : \FUNC{summit}(A) \Arrow{\C} \FUNC{summit}(B) 
		: \forall i \in \I  \. f\lambda_i^B = \lambda_i^A   \big\}, \cdot, \id  \Big)  
	}
	\\
	\DeclareFunc{coconeCategory}{ \TYPE{Diagram}(\C) \to \CAT   }
	\DefineNamedFunc{coconeCategory}{(\I,D)}{\mathsf{CONE}_\C(\I,D)}
	{ 
		\NewLine \de \Big( \{ C : \TYPE{Cocone}(\C) : (\I,D) = (C,C)  \}, A,B \mapsto 
		\big\{ f : \FUNC{nadir}(A) \Arrow{\C} \FUNC{nadir}(B) 
		: \forall i \in \I  \.  \lambda_i^A f = \lambda_i^B   \big\}, \cdot, \id  \Big)  
	}
	\\
	\DeclareFunc{cone}{ \prod \C \in \CAT \. \TYPE{Diagram}(\C) \to \C^\op \Arrow{\CAT} \SET }
	\DefineNamedFunc{cone}{\I,D}{\mathrm{Cone}_\I(\cdot,D)}
	{ 	\NewLine \de
		\Big( \Lambda X \in \C \. \big\{ C \in  \mathsf{CONE}_\C(\I,F)  : \FUNC{summit}(C) = X \big\}, 
		f \mapsto f^*\Big) 
	}
	\\
	\Conclude{\TYPE{Limit}}{\prod (\I,D) : \TYPE{Diagram}(\C) \. 
		\TYPE{Terminal}\left( \int \mathrm{Cone}_\I(\cdot,D)  \right) }
	{ \prod \C \in \CAT \. \TYPE{Diagram}(\C) \to \Type  }
	\\
	\DeclareFunc{ limit }{\prod (\I,D) : \TYPE{Diagram}(\C) \. \TYPE{Limit}(\I,D) \to \C}
	\DefineNamedFunc{limit}{L,\lambda}{ \lim D \quad (L,\lambda) }{ L }
	\\
	\DeclareFunc{universalCone}{\prod (\I,D) : \TYPE{Diagram}(\C) \. 
		   \TYPE{Limit}(\I,D) \to \TYPE{Cone}(\C) }
	\DefineFunc{universalCone}{L,\lambda}{ \lambda  }
	\\
	\DeclareFunc{cocone}{ \prod \C \in \CAT \. \TYPE{Diagram}(\C) \to \C \Arrow{\CAT} \SET }
	\DefineNamedFunc{cocone}{\I,D}{\mathrm{Cocone}_\I(\cdot,D)}
	{ 	\NewLine \de
		\Big( \Lambda X \in \C \. \big\{ C \in  \mathsf{COCONE}_\C(\I,F)  : \FUNC{nadir}(C) = X \big\}, 
		f \mapsto f_*\Big) 
	}
	\\
	\Conclude{\TYPE{Colimit}}{\prod (\I,D) : \TYPE{Diagram}(\C) \. 
		\TYPE{Initial}\left(  \int \mathrm{Cocone}_\I(\cdot,D)  \right) }
	{ \prod \C \in \CAT \. \TYPE{Diagram}(\C) \to \Type  }
	\\
	\DeclareFunc{ limit }{\prod (\I,D) : \TYPE{Diagram}(\C) \. \TYPE{Colimit}(\I,D) \to \C}
	\DefineNamedFunc{limit}{L,C}{ \colim D \quad (L,C) }{ C }
	\\
	\DeclareFunc{universalCocone}{\prod (\I,D) : \TYPE{Diagram}(\C) \. 
		 \TYPE{Colimit}(\I,D)   \to \TYPE{Cocone}(\C) }
	\DefineFunc{universalCocone}{L,C}{ C }
} \Page{
	\DeclareFunc{discreteCat}{\SET \to \TYPE{Discrete}}
	\DefineFunc{discreteCat}{ X  }
	{\Big(X, x,y \mapsto \If x == y \Then \{1\} \Else \emptyset, (1,1) \mapsto 1, x \mapsto 1\Big)}
	\\
	\Conclude{\TYPE{Product}}{\prod \C \in \Cat \. \prod \I : \TYPE{Discrete} \. \prod X : \I \Arrow{\CAT} \C \. 
		\TYPE{Limit}(\I,X) }
	{ \NewLine : \prod \C \in \Cat \. \prod \I : \TYPE{Discrete} \. \I \Arrow{\CAT} \C \to \Type   }
	\DefineType{(P,p)}{Product}{   (P,\pi) = \prod_{i \in \I} X_i }
	\\
	\DeclareFunc{synecdoche}{ \TYPE{Product}(\C)(\I,X) \to \C}
	\DefineFunc{synecdoche}{ P,p  }{ P }
	\\
	\DeclareFunc{projections}{\TYPE{Product}(\C)(\I,X) \to \TYPE{Cone}(\C)}
	\DefineNamedFunc{projections}{P,p}{(P)\quad\pi}{\lambda^p}
	\\
	\Conclude{\TYPE{Coproduct}}{\prod \C \in \Cat \. \prod \I : \TYPE{Discrete} \. \prod X : \I \Arrow{\CAT} \C \. 
		\TYPE{Colimit}(\I,X) }
	{ \NewLine : \prod \C \in \Cat \. \prod \I : \TYPE{Discrete} \. \I \Arrow{\CAT} \C \to \Type   }
	\DefineType{(S,s)}{Coproduct}{   (S,\iota) = \coprod_{i \in \I} X_i }
	\\
	\DeclareFunc{synecdoche}{ \TYPE{Coproduct}(\C)(\I,X) \to \C}
	\DefineFunc{synecdoche}{ S,s  }{ S }
	\\
	\DeclareFunc{inclusions}{\TYPE{Coproduct}(\C)(\I,X) \to \TYPE{Cone}(\C)}
	\DefineNamedFunc{inclusions}{S,s}{(S) \quad\iota}{\lambda^s}
	\\
	\DeclareFunc{parallelPair}{\TYPE{Small}}
	\DefineNamedFunc{parallelPair}{}{\bullet \paral \bullet}{\Big( \{1,2 \} 
		, \NewLine ,  
		\big\{ ((1,1),\{1\}),((2,2),\{1\}),((1,2),\{ 1,2 \}),((2,1),\emptyset) \big\}, 
		(f,1) \mapsto f | (1,f) \mapsto 1, x \mapsto 1 \Big)   }
	\\
	\Conclude{\TYPE{Equalizer}}{\prod \C \in \CAT \. \prod X : \bullet \paral \bullet \Arrow{\CAT} \C \. 
		\TYPE{Limit}(\bullet \paral \bullet,X )	}
	{\NewLine : \prod \C \in \CAT \. \bullet \paral \bullet \Arrow{\CAT} \C \to \Type}
	\\
	\Conclude{\TYPE{Coequalizer}}{\prod \C \in \CAT \. \prod X : \bullet \paral \bullet \Arrow{\CAT} \C \. 
		\TYPE{Colimit}(\bullet \paral \bullet,X )	}
	{\NewLine : \prod \C \in \CAT \. \bullet \paral \bullet \Arrow{\CAT} \C \to \Type}
} 
\Page{
	\DeclareFunc{wedgeCategory}{\TYPE{Small}}
	\DefineNamedFunc{wedgeCategory}{}{ \bullet \to \bullet \leftarrow \bullet }
	{ \Big(  \{1,2,3\}, \NewLine,  \big\{ ((1,1),{1}),((2,2),\{1\}),((3,3),\{1\}), ((1,2),\{1\}),((1,3),\emptyset),
		((2,3),\emptyset),((3,2),\{1\}),((3,1),\emptyset),((2,1),\emptyset)  \big\},\NewLine,
		1 \mapsto 1, x \mapsto 1 \Big) 
	}
	\\
	\Conclude{\TYPE{Pullback}}{ \prod \C \in \CAT \. 
		\prod X  : \bullet \to \bullet \leftarrow \bullet  \Arrow{\CAT} \C \. 
		\TYPE{Limit}(\bullet \to \bullet \leftarrow \bullet, X)
		}
	{\NewLine : \prod \C \in \CAT \.  \bullet \to \bullet \leftarrow \bullet  \Arrow{\CAT} \C \to \Type }
	\\
	\DeclareFunc{veeCategory}{  \TYPE{Small}     }
	\DefineNamedFunc{ veeCategory }{   }{ \bullet \leftarrow \bullet \to \bullet  }
	{ (\bullet \to \bullet \leftarrow \bullet )^\op  }
	\\
	\Conclude{\TYPE{Pushout}}{  
		\prod \C \in \CAT \.  \prod X : \VEE \Arrow{\CAT} \C \. \TYPE{Colimit}(\VEE, X)
		}
	{
		\NewLine : \prod \C \in \CAT \.  \VEE \Arrow{\CAT} \C \to \Type
	}
	\\
	\DeclareFunc{sequenceCategory}{\TYPE{Small}}
	\DefineNamedFunc{sequenceCategory}{}{\mathsf{NAT}}
	{(\Nat, \Lambda n,m \in \Nat \. \If n \ge m \Then \{1\} \Else \emptyset, (1,1) \mapsto 1, n \mapsto 1 )}
	\\
	\Conclude{\TYPE{InverseLimit}}
	{
		\prod \C \in \CAT \. \prod X : \mathsf{NAT} \Arrow{\CAT} \. 
			\TYPE{Limit}(\mathsf{NAT}, X)	
	}
	{ \NewLine : \prod \C \in \CAT \. \mathsf{NAT} \Arrow{\CAT} \C \to \Type}
	\DefineType{(L,C)}{ \TYPE{InverseLimit}}{ (L,C) = \lim_{\leftarrow} X  }
	\\
	\DeclareFunc{synecdoche}{ \TYPE{InverseLimit}(\C,X) \to \C  }
	\DefineFunc{synecdoche}{L,C}{L}
	\\
	\Conclude{\TYPE{DirectLimit}}
	{
		\prod \C \in \CAT \. \prod X : \mathsf{NAT}^\op \Arrow{\CAT} \. \TYPE{Colimit}(\mathsf{NAT}^\op,X)
	}
	{
	   \NewLine : \prod \C \in \CAT \. \mathsf{NAT} \Arrow{\CAT} \C \to \Type
	}
	\DefineType{(L,C)}{ \TYPE{DirectLimit}}{ (L,C) = \lim_{\to} X  }
	\\
	\DeclareFunc{synecdoche}{ \TYPE{DirectLimit}(\C,X) \to \C  }
	\DefineFunc{synecdoche}{L,C}{L}
}
\newpage
\subsection{Categories with Limits}
\Page{
	\DeclareType{WithLimit}{ \prod   \mathbb{T} : \prod \C \in \CAT \. ? \TYPE{Diagram}(\C) \. ?\CAT  }
	\DefineType{\C}{WithLimit}{ \forall D : \mathbb{T}(\C) \. \exists \TYPE{Limit}(D) }
	\\
	\DeclareType{Complete}{ ?\CAT }
	\DefineType{\C}{Complete}{\forall D : \TYPE{Diagram}(\C) \. \exists \TYPE{Limit}(D)}
	\\
	\Theorem{SetIsComplete}{[\SET : \TYPE{Complete} ] }
	\Assume{ (\I,X) }{ \TYPE{Diagram}(\SET)}
	\Say{L}
	{
		\left\{ x \in \prod_{i \in \I} X_i : \forall i,j \in \I \. \forall f \in i \Arrow{\I} j \. 
			X_{i,j}(f)(x_i) = x_j   \right\}
	}{\Set}
	\Say{\pi}{\Lambda i \in \I \. \Lambda x \in L \. x_i}{\prod i \in \I \. L \to X_i }
	\Assume{i,j}{\I}
	\Assume{f}{i \Arrow{\I} j}
	\Conclude{()}{\bd \pi_i \bd L \bd^{-1} \pi_j}
	{  \pi_i X_{i,j}(f) = \Lambda x \in L \. X_{i,j}(f)(x_i) =  \Lambda x \in L \. x_j = \pi_j  }
	\Derive{(1)}{\bd^{-1} \TYPE{Cone}  }{\Big[ \big((\I,X),L,\pi) : \TYPE{Cone}(\I,X) \Big] }
	\Assume{(C,c)}{\int \mathrm{Cone}(\cdot,X)}
	\Say{\lambda}{\lambda^c}{\Delta_{I}(C) \Rightarrow X}
	\Say{\phi}{\Lambda x \in C \. \Lambda i \in \I \. \lambda_i(x)}{ C \to \prod_{i \in \I} X_i   }
	\Conclude{()}{\bd \mathsf{CONE}(\I,X)(C)(\phi)\bd^{-1} L}{\im \phi \subset L }
	\DeriveConclude{()}{\bd^{-1} \TYPE{Limit}}{(L,\pi) : \TYPE{Limit}(\I, X) }
	\DeriveConclude{(*)}{\bd^{-1} \TYPE{Complete}}{ \big[X : \TYPE{Complete}(\SET)\big]  }
	\EndProof
	\\
	\DeclareType{WithColimit}{\prod \mathbb{T} : \prod \C \in \CAT \. ?\TYPE{Diagram}(\C) \. ?\CAT}
	\DefineType{\C}{WithColimit}{\forall D : \mathbb{T}(\C) \. \exists \TYPE{Colimit}(D)}
	\\
	\DeclareType{Cocomplete}{?\CAT}
	\DefineType{\C}{Cocomplete}{\forall D : \TYPE{Diagram}(\C) \. \exists \TYPE{Colimit}(D) }
}
\Page{
	\Theorem{SetIsCocomplete}{[\SET : \TYPE{Cocomplete}]}
	\Assume{(\I,X)}{\TYPE{Diagram}(\SET)}
	\Say{E}{ \FUNC{spanEq}
		\bigg\{ \big((i,x),(j,X_{i,j}(f)(x))\big) \in \bigsqcup_{i \in \I} X_i \times \bigsqcup_{i \in \I} X_i   
		\Big| i,j \in \I,  f : i \Arrow{\I} j   \bigg\}
	       }
		{  \TYPE{Equivalence} \; \bigsqcup_{i \in \I} X_i }
	\Say{L}{\frac{\bigsqcup_{i \in \I} X_i }{E}}{\Set}
	\Say{\iota}{\Lambda i \in \I \. \Lambda x \in X_i \. \big[(i,x)\big]_E}
	{ \prod i \in \I \. X_i \to L  }
	\Assume{i,j}{\I}
	\Assume{f}{i \Arrow{\I} j}
	\Conclude{()}{\bd \iota_j \bd\TYPE{quetient}(E) \bd^{-1} \iota_i}
	{ 
		X_{i,j}(f)\iota_j = 
		\Lambda x \in X_i \. \Big[\big((j,X_{i,j}(f)(x)\big)\Big]_E   = 
		[ (i,x) ]_E =
		\iota_i  
	} 
	\Derive{(1)}{\bd^{-1}\TYPE{Cocone}}{ \Big[ \big((\I,X),L,\iota\big) : \TYPE{Cocone}(\I,X) \big)\Big]   }
	\Assume{(C,c)}{\int \mathsf{Cone}_\I(\cdot,X)}
	\Say{\lambda}{\lambda^c}{  X \Rightarrow \Delta_\I(C)  }
	\Assume{y}{L}
	\Assume{(i,x,2),(j,x',3)}{ \sum i \in \I \. \sum  x \in X \. (i,x_i) \in y}
	\Say{(k,f,g,4)}{\bd y \bd L(3)}{ 
		\sum k \in \I \. \sum z \in X_k \. \sum  f : k \Arrow{\I} i \. \sum  g : k \Arrow{\I} j \. \NewLine \. 
		X_{k,i}(f)(z) = x \And  X_{k,j}(g)(z) = y 
	}
	\Conclude{()}{\bd \TYPE{Cocone}(C,c)\bd(\lambda)(4)}{ \lambda_i(x) = \lambda_j(y)}
	\Derive{(2)}{I(\forall)}{ \forall y  \in L  \. \forall (i,x,2),(j,x',3) : \sum i \in \I \. 
		\sum x \in X_i : (i,x') \in y \. \lambda_i(x)   = \lambda_j(x')  }
	\Say{\phi}{
		\Lambda y \in L  \. 
		\bd \TYPE{Singleton} \left\{ \lambda_i(x) 
		|  (i,x,\cdot) : \sum i \in \I : \sum x \in X_i : (i,x_i) \in y   \right\}  
	}
	{
                L \to C 
	}
	\Conclude{()}{\bd \phi}{\forall i,j \in \I \. \forall f : i \Arrow{\I} j \.  \iota_i \phi = \lambda_j}
	\DeriveConclude{()}{\bd^{-1} \TYPE{Colimit}}{\Big[(L,\iota) : \TYPE{Limit}(\I,X)\Big]}
	\Conclude{(*)}{\bd \TYPE{Cocomplete}}{[\SET : \TYPE{Cocomplete}]}
	\EndProof
}
\newpage
\subsection{Limits under Functors}
\Page{
	\DeclareFunc{mapDiagram}{\prod \A,\B \in \CAT \. \A \Arrow{\CAT} \B \to \TYPE{Diagram}(\A) \to \TYPE{Diagram}(\B)}
	\DefineNamedFunc{mapDiagram }{F,(\I,D) }{F(\I,D)}{(\I,DF) }
	\\
	\DeclareFunc{mapDiagramType}{ \prod \A,\B \in \CAT \. \A \Arrow{\CAT} \B \to 
		?\TYPE{Diagram}(\A) \to ?\TYPE{Diagram}(\B)  }
	\DefineNamedFunc{mapDiagramType}{ F, \mathbb{T}  }{  F\mathbb{T}   }
	{  \Big\{ FD : D \in \mathbb{T}       \Big\}      }
	\\
	\DeclareType{PreservesLimits}{\prod \A, \B \in \CAT \. ?\TYPE{Diagram}(\A) \to ?(\A \Arrow{\CAT} \B)}
	\DefineType{F}{PreservesLimits}{
		\Lambda \mathbb{T} : ?\TYPE{Diagram}(\A) \.
		\forall  D \in \mathbb{T} \. 
		\forall  L : \TYPE{Limit}(\A)(D) \. \NewLine \.
		\Big[FL  : \TYPE{Limit}(\B)(D) \Big]
	}
	\\	
	\DeclareType{ReflectsLimits}{\prod \A, \B \in \CAT \. ?\TYPE{Diagram}(\A) \to ?(\A \Arrow{\CAT} \B)}
	\DefineType{F}{ReflectsLimits}{
		\Lambda \mathbb{T} : ?\TYPE{Diagram}(\A) \.
		\forall  D \in \mathbb{T} \. 
		\forall  L : \TYPE{Cone}(\A)(D) \. \NewLine \. 
		\Big[FL  : \TYPE{Limit}(\B))(D) \Big] \Rightarrow
		\Big[ L : \TYPE{Limit}(\A)(D) \Big ]
	}
	\\
	\DeclareType{CreatesLimits}{\prod \A, \B \in \CAT \. ?\TYPE{Diagram}(\A) \to ?(\A \Arrow{\CAT} \B)}
	\DefineType{F}{CreatesLimits}{
		\Lambda \mathbb{T} : ?\TYPE{Diagram}(\A) \.
		\forall  D \in \mathbb{T} \. 
		\forall  L : \TYPE{Limit}(\B)(D) \. \NewLine \.
		\exists  L' : \TYPE{Limit}(\A)(D) : FL' = L 
	}
	\\
	\DeclareType{PreservesColimits}{\prod \A, \B \in \CAT \. ?\TYPE{Diagram}(\A) \to ?(\A \Arrow{\CAT} \B)}
	\DefineType{F}{PreservesColimits}{
		\Lambda \mathbb{T} : ?\TYPE{Diagram}(\A) \.
		\forall  D \in \mathbb{T} \. 
		\forall  L : \TYPE{Colimit}(\A)(D) \. \NewLine \.
		\Big[FL  : \TYPE{Colimit}(\B)(FD) \Big]
	}
	\\	
	\DeclareType{ReflectsColimits}{\prod \A, \B \in \CAT \. ?\TYPE{Diagram}(\A) \to ?(\A \Arrow{\CAT} \B)}
	\DefineType{F}{ReflectsColimits}{
		\Lambda \mathbb{T} : ?\TYPE{Diagram}(\A) \.
		\forall  D \in \mathbb{T} \. 
		\forall  L : \TYPE{Cocone}(\A)(D) \. \NewLine \. 
		\Big[FL  : \TYPE{Colimit}(\B))(FD) \Big] \Rightarrow
		\Big[ L : \TYPE{Colimit}(\A)(D) \Big ]
	}
	\\
	\DeclareType{CreatesLimits}{\prod \A, \B \in \CAT \. ?\TYPE{Diagram}(\A) \to ?(\A \Arrow{\CAT} \B)}
	\DefineType{F}{CreatesLimits}{
		\Lambda \mathbb{T} : ?\TYPE{Diagram}(\A) \.
		\forall  D \in \mathbb{T} \. 
		\forall  L : \TYPE{Colimit}(\B)(FD) \. \NewLine \. 
		\exists  L' : \TYPE{Colimit}(\A)(D) : FL' = L 
	}
}\Page{
	\Theorem{ExistanceOfLimitsByFunctor}{   
		\forall \A, \B \in \CAT \. 
		\forall \mathbb{T} : ?\TYPE{Diagram}(\A) \. 
		\forall F : \TYPE{CreatesLimit}(\A,\B)(\mathbb{T}) \. \NewLine \.
		\forall (1) : \Big[ \B : \TYPE{WithLimit}(F\mathbb{T}) \Big] \.
		\Big[ \A : \TYPE{WithLimit}(\mathbb{T}) \Big] \And
		\Big[ F : \TYPE{PreservesLimit}(\mathbb{T})  \Big]
	}
	\Assume{D}{\mathbb{T}}
	\Say{L}{(1)(FD)}{\TYPE{Limit}(\B)(FD)}
	\Conclude{(L',2)}{\bd \TYPE{CreatesLimit}((\A,\B)F)}{ \sum L' : \TYPE{Limit}(D) \. FL' = L   }
	\Derive{(2)}{\bd^{-1} \TYPE{WithLimit}}{\Big[ \A : \TYPE{WithLimit}\mathbb{T} \Big]}
	\Assume{D}{\mathbb{T}}
	\Assume{L}{\TYPE{Limit}(D)}
	\Say{M}{(1)(FD)}{\TYPE{Limit}(\B)(FD)}
	\Say{(M',3)}{\bd \TYPE{CreatesLimit}((\A,\B)F)}{ \sum M' : \TYPE{Limit}(D) \. FM' = M   }
	\Say{(4)}{\THM{IsomorphicTerminal}\bd \TYPE{Limit}(D)(L,M')}{L \cong_\A M'}
	\Say{(5)}{\THM{FunctorPreservesIso}(4)(3)}{FL \cong M }
	\Conclude{(6)}{\bd^{-1} \TYPE{Limit}\THM{IsomorphicTerminal}(5)   }{  \Big[FL : \TYPE{Limit}(\B) \Big] }
	\EndProof
	\\
	\Theorem{FullyFaithfulReflectsLimits}{ 
		\forall \A : \TYPE{WithLimit}(\mathbb{T}) \. \forall \B \in \CAT \.  
		\forall  F : \TYPE{FullyFaithul}(\A,\B) \. \NewLine \.
		\Big[ F : \TYPE{ReflectsLimits}(\A,\B)(\mathbb{T}) \Big]
	}
	\Assume{\I,D}{\mathbb{T}}
	\Assume{(C,\lambda)}{\TYPE{Cone}(\I,D)}
	\Assume{(1)}{\Big[(FC,F\lambda) : \TYPE{Limit} F(\I,D)\Big]}
	\Say{(L,\mu)}{  \bd \TYPE{WithLimit}(\mathbb{T})(\A) (\bd)(\I,D) }{\TYPE{Limit}(\I,D)}
	\Assume{i,j}{\I}
	\Assume{f}{i \Arrow{\I} j}
	\Conclude{()}{ \bd \Cov(\A,\B)(F) \bd \TYPE{Cone}(L,\mu) }
	{ F_{L,D_i}(\mu_i)DF_{i,j}(f) = F_{L, D_j}\Big(\mu_i D_{i,j}(f) \Big) = F_{L.D_j}(\mu_j)}
	\Derive{(1)}{\bd^{-1} \TYPE{Cone}}{ \Big[ (FL,F\mu) \Big] : \TYPE{Cone}F(\I,D) }
	\Say{\phi}{\bd \TYPE{Limit}(L,\mu)(C,\lambda)}{  C  \Arrow{\int \mathrm{Cone}_\I(\cdot,D)}  L  }
	\Say{\psi}{\bd \TYPE{Limit}(FC,F\lambda)(FL,F\mu)}{FL \Arrow{\int \mathrm{Cone}_\I(\cdot,FD)} FC }
	\Assume{i}{\I}
	\Conclude{ ()  }{ \bd \phi \bd \Cov(\A,\B)(F) }{F(\lambda_i) =  F(\phi \mu_i) =  F(\phi)F(\mu_i)}
	\Derive{ (1)}{  \bd \int \mathrm{Cone}_\I(\cdot,FD)  }{ 
		   \Big[ F(\phi) : FC \Arrow{\int\mathrm{Cone}_\I(\cdot,FD)} \Big]   
		}
	\Say{(1)}{ \bd \TYPE{Terminal}(FC,\lambda)}{ \psi F(\phi)  = e}
	\Say{(2)}{\bd \TYPE{FullyFaithul}(F)(1) }{ (C,\lambda) \cong_{\int \mathrm{Cone}(\cdot,D)} (L,\mu) }
	\Conclude{()}{\bd^{-1} \TYPE{Limit}(\I,D)(2)  }{ \Big[ (C,\lambda) : \TYPE{Limit}(\I,D) \Big]  }
	\DeriveConclude{(*)}{\bd^{-1} \TYPE{ReflectsLimitis}}{\Big[ F : \TYPE{ReflectsLimits}(\A,\B)(\mathbb{T}) \Big]}
	\EndProof
}
\Page{
	\DeclareType{StrictlyCreatesL}{\prod \A,\B \in \CAT \. \prod \mathbb{T} : ?\TYPE{Diagram}(\A) \.  
		?\TYPE{CreatesLimits}(\A,\B)}
	\DefineType{F}{StrictlyCreatesL}{ \forall D \in \mathbb{T} \. \forall  C : \TYPE{Limit}(FD) \. 
		\exists! C' : \TYPE{Limit}(D) \. C = FC'    }
	\\
	\DeclareType{Connected}{?\TYPE{Diagram}(\C)}
	\DefineType{(\I,D)}{Connected}{[\I : \TYPE{Connected}]}
	\\
	\DeclareFunc{forgetfulDemorph}{  \prod \C \in \CAT \. \prod X \in \C \. \frac{\C}{X} \Arrow{\CAT} \C   }
	\DefineNamedFunc{forgetfulDemorph}{A,f}{\Pi^X (A,f) }{A}
	\DefineNamedFunc{forgetfulDemorph}{ (A,f),(B,g),(h)}{\Pi_{(A,f),(B,g)}^X (h)}{h}
	\\
	\Theorem{ForgetfulDemorphStrictlyCreatesL}{ 
		\forall \C \in \CAT \. 
		\forall Y \in \C \. \NewLine 
		\left[\Pi^Y : \TYPE{StrictlyCreatesL}\left(\TYPE{Connected}\left( \frac{\C}{Y}\right)\right) \right]          
	}
	\Assume{\Big(\I,\big((X,f),\phi\big)\Big)}{  \TYPE{Connected}\left( \frac{\C}{Y}\right)  }
	\Say{D}{\Big(\I,\big((X,f),\phi\big)\Big)}{ \TYPE{Connected}\left( \frac{\C}{Y}\right) }
	\Say{(1)}{\bd D}{ \forall i,j \in \I \. \Mor_\I(i,j) \neq \emptyset \Rightarrow \phi_{i,j} f_j = f_i }
	:\Assume{(L,\lambda)}{\TYPE{Limit}\Big(\Pi^Y D\Big)}
	\Say{(2)}{\bd \TYPE{Cone}(C,\lambda) }{ \forall i,j \in \I \. 
		\Mor_{\I}(i,j) \neq \emptyset \Rightarrow  \lambda_i \phi_{i,j} = \lambda_j }
	\Assume{ i,j}{  \I }
	\Say{(n,k,h)}{(00)(D)\bd \TYPE{Connected}(D)}{\TYPE{MorphismChain}(i,j)}
	\Assume{l}{n}
	\Conclude{()}{(1)(2)(l,l+1)}{ \lambda_{k_l} f_{k_l} = \lambda_i \phi_{k_l,k_{l+1} }(h) f_{k_{l+1}} 
		= \lambda_{k_{l+1}} f_{k_{l+1}} }
	\Derive{(1)}{I(\forall)}{ \forall l \in n \. \lambda_{k_l} f_{k_l} = \lambda_{k_{l+1}}f_{k_{l+1}}}
	\Conclude{()}{\THM{EqChain}(1)\bd \TYPE{MorphismChain}(i,j)(n,k,h)}{\lambda_i f_i = \lambda_j f_j}
	\Derive{(1)}{I(\forall)}{\forall i,j \in \I \. \lambda_i f_i = \lambda_j f_j}
	\Say{g}{\bd \TYPE{Singleton} \{ \lambda_i f_i  | i \in \I  \}}{ L  \Arrow{\C} Y  }
	\Say{(2)}{\bd g \bd(L.\lambda)\bd^{-1} \TYPE{Cone}(D)}{\Big[ \big( (L,g),\lambda\big) : \TYPE{Cone}(D)  \Big]}
	\Assume{\big( (C,h),\mu)}{\TYPE{Cone}(D)}
	\Say{(3)}{\bd^{-1} \TYPE{Cone}(\Pi^Y F)}{ \Big[(C,\mu) : \TYPE{Cone}\big(\Pi^Y D\big)\Big]}
	\Say{(\psi,4)}{\bd^{-1} \TYPE{Limit}\Big(\Pi^Y D \Big)(L,\lambda) }
	{ \sum \psi : C \Arrow{\C} L \. \forall i \in \I \. \mu_i = \psi \lambda_i }
	\Say{(5)}{ \forall i \in I \. \bd \TYPE{Cone}(C,\mu)(i)(4)\bd \TYPE{Cone}(L,\lambda)(i)  }
	{ \forall i \in I \. h = \mu_i f_i = \psi \lambda_i f_i = \psi g }
	\Say{(6)}{\bd \TYPE{Connected}(D)\bd \TYPE{NonEmpty}(\I)(5)}{ h = \psi g  }
	\Conclude{(7)}{\bd \left( \frac{\C}{Y} \right)}{\Big[ \psi : (C,h) \Arrow{\frac{\C}{Y}} (L,g) \Big]}
	\DeriveConclude{()}{\bd^{-1} \TYPE{Limit}}{\Big[ \big((L,g),\lambda) : \TYPE{Limit}(D)  \Big]}
	\DeriveConclude{(*)}{\bd^{-1} \TYPE{StrictlyCreates}}{\Big[ \Pi^Y : \TYPE{StrictlyCreates}(\mathbb{T})\Big]}
	\EndProof
}
\Page{
	\DeclareType{StrictlyCreatesC}{\prod \A,\B \in \CAT \. \prod \mathbb{T} : ?\TYPE{Diagram}(\A) \.  
		?\TYPE{CreatesColimits}(\A,\B)}
	\DefineType{F}{StrictlyCreatesC}{ \forall D \in \mathbb{T} \. \forall  C : \TYPE{Colimit}(FD) \. 
		\exists! C' : \TYPE{Colimit}(D) \. C = FC'    }
	\\	
	\Theorem{ForgetfulDemorphStriclyCreatesC}{ 
		\forall \C i\in \CAT \. 
		\forall Y \in \CAT \. \NewLine \.
		\left[ \Pi^Y : \TYPE{StrictlyCreatesC}\left(\TYPE{Diagram}\left( \frac{\C}{Y} \right)\right) \right]
	}
	\Assume{\Big( \I,\big( (X,f),\phi\big)\Big)}{\TYPE{Diagram}\left( \frac{\C}{Y} \right)}
	\Say{D}{\Big(\I,\big((X,f),\phi\big)\Big)}{\TYPE{Diagram}\left( \frac{\C}{Y} \right)}
	\Say{(1)}{\bd \frac{\C}{Y}(D)}{ \forall i,j \in \I \. \forall h : i \Arrow{\I} j \. \phi_{i,j}(h)f_j = f_i }
	\Say{(2)}{\bd^{-1} \TYPE{Cocone} (1) }{ (Y,f) \in \int \mathrm{Cocone}_\I\Big(\cdot,(X,\phi)\Big)   }
	\Assume{(L,\lambda)}{\TYPE{Colimit}\Big( \Pi^Y D \Big)}
	\Say{(\psi,3)}{\bd \TYPE{Colimit}\Big(\Pi^Y D\Big)(L.\lambda)(Y,f)}{
		\sum \psi : L \Arrow{\C} Y \. \forall i \in \I \.  \lambda_i \psi = f_i }
	\Say{(4)}{\bd^{-1} \TYPE{Cocone}(D)(3)}{\Big[ \big((L,\psi),\lambda) : \TYPE{Cocone}(D) \Big]}
	\Assume{\Big( (C,h),\mu \Big)}{ \TYPE{Cocone}(D) }
	\Say{(5)}{ \bd \TYPE{Cocone}\Big( \Pi^Y D \Big)(C,\mu) }{ \Big[ (C,\mu) : \TYPE{Cocone}(D) \Big]  }
	\Say{(\chi,6)}{  \bd \TYPE{Colimit}\Big( \Pi^Y D \Big) }{  \sum \chi : L \Arrow{\C} C \.
		\forall i \in \I \.  \lambda_i \chi = \mu_i  }
	\Conclude{()}{\bd \TYPE{Unique} \bd \TYPE{Colimit} \bd \TYPE{Initial} \bd \psi }{ \chi h = \psi  }
	\DeriveConclude{()}{ \bd^{-1} \TYPE{Colimit} \bd \TYPE{Unique} \bd \TYPE{Colimit} \bd \TYPE{Initial} I(\exists) }
	{ \Big[  \big( (L,\psi), \lambda \big) : \TYPE{Colimit}(D) \Big]     }
	\Conclude{(*)}{\bd^{-1} \TYPE{StrictlyCreatesC} \bd \Pi_Y \bd \TYPE{Unique} \bd \TYPE{Colimit} \bd \TYPE{Initial}}
	{\Big[ \Pi^Y : \TYPE{StrictlyCreatesC} \Big]}
	\EndProof
	\\
	\DeclareFunc{objectCategory}{\CAT \to \CAT}
	\DefineNamedFunc{objectCategory}{\C}{\C^\obj}{\Big( \Obj(\C), \Lambda X,Y \in \C \. \If X == Y \Then \{{\id}_X\} 
		\Else \emptyset , \cdot_\C, \id_\C \Big)}
	\\
	\DeclareFunc{functorRelaxation}{\prod \C,\A \in \CAT \. \C^\A \Arrow{\CAT} \C^{\A^\obj}}
	\DefineNamedFunc{functorRelaxation}{F}{\mathrm{R} \; F}{F}
	\DefineNamedFunc{functorRelaxation}{F,G,\alpha}{\mathrm{R}_{F,G} \; \alpha }{\alpha }
	\\
	\DeclareFunc{evaluateFunctorAt}{\prod \C,\A \in \CAT \. \A \to  \C^\A \Arrow{\CAT} \C}
	\DefineNamedFunc{evaluateFunctorAt}{F}{\mathrm{Ev}_A \; F}{F(A)}
	\DefineNamedFunc{evaluateFunctorAt}{F,G,\alpha}{(\mathrm{Ev}_A)_{F,G} \; \alpha }{\alpha(A) }
} \Page{
	\Theorem{EvaluationPreservesLimits}
	{
		\forall \A,\C : \CAT \.
		\forall A \in \A \.
		\Big[\mathrm{Ev}_A : \TYPE{PreservesLimits}\big( \C^{\A^\obj}, \A  \big)\Big]
	}
	\Assume{\big(\I,(F,\alpha)\big)}{ \TYPE{Diagram}(\C^\A) }
	\Say{D}{\big(\I,(F,\alpha)\big)}{\TYPE{Diagram}(\C^\A)} 
	\Assume{(L,\lambda)}{\TYPE{Limit}(D)}
	\NoProof
	\\
	\Theorem{FunctorLimitFibration}{          
		\forall \C \in \CAT \. 
		\forall \A : \TYPE{Small} \. 
		\forall \mathbb{T} : ?\TYPE{Diagrm}(\C^\A) \. \NewLine \.
		\forall (0) :   \forall A \in \A \.  
			\Big[\C : \TYPE{WithLimit}( \mathrm{Ev}_A \mathbb{T} ) \Big] \. 
		\R : \TYPE{StrictlyCreatesL}\Big( \mathbb{T} \Big)
	}
	\Assume{\Big(\I, (F,\alpha)\Big)}{ \mathbb{T}}
	\Say{D}{\Big(\I,(F,\alpha)\Big)}{\mathbb{T}}
	\Assume{A}{\A}
	\Say{(1)}{\mathrm{Ev}_A \; \bd D}{\Big[ \mathrm{Ev}_A \;  D : \mathrm{Ev}_A \; \mathbb{T} \Big]}
	\Conclude{\Big(L'(A),\lambda'(A)\Big)}{(0)(\mathrm{Ev}_A \; D)}{\TYPE{Limit}(\mathrm{Ev}_A \; D)}
	\Derive{(L',\lambda')}{I\left( \prod \right)}{ \prod A \in \A \. \TYPE{Limit}\Big( \mathrm{Ev}_A \; D \Big) }
	\Assume{X,Y}{\A}
	\Assume{f}{ X \Arrow{\A} Y}
	\Say{\mu}{  \Lambda i \in \I \. \lambda_i(X)(F_i)_{X,Y}(f) }{ \prod i \in \I \. L(X) \Arrow{\C} F_i(Y) }
	\Assume{i,j}{\I}
	\Assume{ h  }{ i \Arrow{\I} j}
	\Conclude{()}{ \bd \mu_i \bd \NT(F_i,F_j) \alpha_{i,j}(h) \bd \TYPE{Cone}(\mathrm{Ev}_X \; D)(L(X),\lambda(X)) 
		\bd^{-1} \mu_j   }
	{
		\NewLine :
		\mu_i \alpha_{i,j}(h)(Y) =
		\lambda_i(X)(F_i)_{X,Y}(f)\alpha_{i,j}(h)(Y) =
		\lambda_i(X)\alpha_{i,j}(h)(X)(F_j)_{X,Y}(f) =
		\lambda_j(X) (F_j)_{X,Y}(f) =
		\mu_j
	}
	\Derive{(1)}{\bd^{-1} \TYPE{Cone}(\mathrm{Ev}_Y \; D)}{ \Big[ \big( L'(X),\mu  ) : 
		\TYPE{Cone}(\mathrm{Ev}_Y \; D) \Big]   }
	\Conclude{\big(L''_{X,Y}(f),2)}{\bd \TYPE{Limit}(\mathrm{Ev}_Y \; D)(L'(Y),\lambda'(Y))  }
	{   \sum L''_{X,Y}(f) : L'(X) \Arrow L'(Y) \. \forall i \in \I \.   L''_{X,Y}(f) \lambda_i'(Y) = \mu_i}
	\Derive{(L'',1)}{I\left(\prod\right)}
	{  
		\prod X,Y \in \A \. \prod f : X \Arrow{\A} Y \. 
		\sum L'_{X,Y}(f) : L(X) \Arrow{\C} L(Y) \. \NewLine \. 
		\forall i \in \I \.  L''_{X,Y}(f) \lambda_i'(Y) = \lambda_i'(X) (F_i)_{X,Y}(f)
	}
	\Assume{ X,Y,Z  }{\A}
	\Assume{f}{X \Arrow{\A} Y}
	\Assume{g}{Y \Arrow{\B} Z}
	\Assume{i}{\I}
	\Conclude{()}{ (1)(Y,Z,g,i)(1)(X,Y,f,i)\bd\Cov(\A,\C)(F_i) }
	{
		\NewLine :
		L''_{X,Y}(f)L''_{Y,Z}(g) \lambda_i'(Z)  = 
		L''_{X,Y}(f)\lambda_i'(Y)(F_i)_{X,Y}(f) =
		 \lambda_i'(X)   (F_i)_{X,Y}(f) (F_i)_{Y,Z}(g) =
		 \lambda_i'(X) (F_i)_{X,Z}(fg)
	}
	\Derive{(2)}{I(\forall)}{\forall i \in \I \. L''_{X,Y}(f)L''_{Y,Z}(g) \lambda_i'(Z) = \lambda_i'(X)(F_i)_{X,Z}(fg)}
	\Conclude{()}{\bd \TYPE{Unique} \bd L''(2)}{L''_{X,Y}(f)L''_{Y,Z}(g) = L''_{X,Z}(fg)}
	\Derive{(2)}{\bd^{-1}\Cov}{\Big[ (L',L'') : \Cov(\A,\C) \Big]}
	\Say{L}{(L',L'')}{\Cov(\A,\C)}
	\Say{\lambda}{\Lambda i \in \I \. \Lambda A \in \A \. \lambda_i'(A)}{\prod i \in \I \. L \Rightarrow F_i}
}\Page{
	\Assume{i,j}{\I}
	\Assume{h}{i \Arrow{\I} j}
	\Assume{A}{\A}
	\Conclude{()}{\bd \TYPE{Cone}(L(A),\lambda(A))}{\alpha_{i,j}(h)(A)\lambda_j(A) = \lambda_i(A)}
	\DeriveConclude{()}{I(\to,=) }{ \alpha_{i,j}(h)\lambda_j = \lambda_i    }
	\Conclude{(3)}{\bd^{-1} \TYPE{Cone}}{\Big[  (L,\lambda) : \TYPE{Cone}(D)  \Big]}
	\Assume{(M,\mu)}{\TYPE{Cone}(\R D)}
	\Assume{A}{\A}
	\Say{(5)}{\THM{EvaluationPreservesLimits}(A)(4)}{\Big[  (M(A),\mu(A)) : \TYPE{Limit}(\mathrm{Ev}_A D)   \Big]}
	\Conclude{()}{\THM{Terminalisomprphic}\bd L' (5)}{ (M(A),\mu(A)) 
		\cong_{\int_\C \mathrm{Cone}(x,\mathrm{Ev}_A D) \mathrm{d}  x} (L(A),\mu(A))}
	\Derive{(6)}{\bd \A^\obj \bd L}{ 
		(M,\mu) \cong_{\int_{\C^{\A^\obj}} \mathrm{Cone}(x,\R D) \mathrm{d} x}   (L,\lambda)  }
	\Say{(7)}{\bd^{-1} \TYPE{Limit}\;\THM{TerminalIsomorphic}(6)}{\Big[ (L,\lambda) : \TYPE{Limit}(\R\; D) \Big] }
	\Say{\phi}{\bd^{-1}\TYPE{Isomorphic}(6)}{ \sum \phi : L \ToIso{\C^{\A^\obj}} M \. 
		\forall i \in \I \.  \phi \mu_i  = \lambda_i    }
	\Say{M^*}{(M,\Lambda X,Y \in \A \. \Lambda f : X \Arrow{\A} Y \. \phi^{-1}(X)L_{X,Y}(f)\phi(Y))}
	{ \Cov(\A,\C)  }
	\Say{(8)}{\bd \phi \bd M^*}{ (M^*,\mu) \cong_{\int_{\C^\A} \mathrm{Cov}(x,D) \mathrm{d}x} (L,\lambda)  }
	\Assume{(C,\beta)}{\TYPE{Cone}(D)}
	\Say{(\psi,9)}{\bd \TYPE{Limit}(L,\lambda)\R(C,\beta)}
	{ \sum \.  C  \Arrow{\C^{\A^\obj}} L \. \forall i \in \I \.  \psi \lambda_i = \beta_i }
	\Assume{ X,Y }{\A}
	\Assume{f}{X \Arrow{\A} Y}
	\Say{\rho}{ \beta(X)F_{X,Y}(f)  }{ C(X)  \Rightarrow F(Y)  }
	\Assume{i,j}{\I}
	\Assume{h}{i \Arrow{\I} j}
	\Conclude{()}{\bd \rho_i \bd \alpha \bd \TYPE{Cone}(D)(C,\beta) \bd^{-1} \rho_j}{ 
		\rho_i \alpha_{i,j}(h)(Y) = 
		\beta_i(X) (F_i)_{X,Y}(f) \alpha_{i,j}(h)(Y) =      
		\beta_i(X) \alpha_{i,j}(h)(X) (F_j)_{X,Y}(f) =
		\beta_j(X) (F_j)_{X,Y}(f) =
		\rho_j  
		}
	\Derive{(10)}{\bd^{-1} \TYPE{Cone}}{\Big[ (C(X),\rho) : \TYPE{Cone}(\mathrm{Ev}_Y \; D ) \Big]}
	\Assume{i}{\I}
	\Say{()_1}{\bd \rho_i\bd \beta (9)}{  
		\rho_i =
		\beta_i(X)(F_i)_{X,Y}(f) = 
		C_{X,Y}(f) \beta_i = 
		C_{X,Y}(f) \psi \lambda_i(Y) 
		}
	\Conclude{()_2}{\bd \rho_i (9)\bd \lambda}
	{
		\rho_i =
		\beta_i(X)(F_i)_{X,Y}(f) = 
		\psi \lambda_i(X) (F_i)_{X,Y}(f) =
		\psi L_{X,Y}(f) \lambda_i(Y)
	}
	\Derive{(11)}{\bd \int_\C \mathrm{Cone}(x,\mathrm{Ev}_Y D)\mathrm{d}x}
	{ C_{X,Y}(f)\psi(Y),\psi(X)L_{X,Y}(f) : (C,\rho) 
		\Arrow{\int_\C \mathrm{Cone}(x,\mathrm{Ev}_Y D)\mathrm{d}x} (L,\lambda)   }
	\Conclude{()}{\bd \TYPE{Limit}(\R D)(L,\lambda)}{C_{X,Y}(f)\psi(Y) = \psi(X)L_{X,Y}(f)}
	\DeriveConclude{()}{\bd \C^\A}{ \Big[\psi : (C,\beta) \Arrow{\C^\A} (L,\lambda)\Big]}
	\Derive{(9)}{\bd^{-1} \TYPE{Limit}}{ \Big[(L,\lambda) : \TYPE{Limit}(D) \Big]  }
	\Conclude{()}{\THM{TerminalIso}(8,9)}{ \Big[ (M^*,\mu)  : \TYPE{Limit}(D)  \Big]        }
	\DeriveConclude{(*)}{\bd^{-1} \TYPE{StrictlyCreatesL}}{\Big[ R : \TYPE{StrictlyCreatesL}(\mathbb{T}) \Big]}
	\EndProof
}
\Page{
	\Theorem{ExistanceOfColimitsByFunctor}{\forall \A,\B \in \CAT \. 
		\forall \mathbb{T} : ? \TYPE{Diagram}(\CAT) \. 
		\forall F : \TYPE{CreatesColimits}(\mathbb{T}) \. \NewLine \.
		\forall (1) : \Big[ \B : \TYPE{WithColimit}(F\mathbb{T}) \Big] \.
		\Big[\A : \TYPE{Colimit}(F\mathbb{T})\Big] \And
		\Big[ F : \TYPE{CreatesLimits}(F\mathbb{T}) \Big] 
	}
	\NoProof
	\\
	\Theorem{FullyFaithfulReflectsColimits}{
		\forall \A : \TYPE{WithColimit}(\mathbb{T})\.
		\forall \B \in \CAT \.
		\forall F : \TYPE{FullyFaithful}(\A,\B) \. \NewLine
		\Big[ F : \TYPE{ReflectsColimits}(\mathbb{T}) \Big]
	}
	\NoProof
	\\
	\DeclareFunc{forgetfufulDemorph2}{\prod \C \in \CAT \. \prod X \in \C \. \frac{X}{\C} \Arrow{\CAT} \C}
	\DefineNamedFunc{forgetfulDemorph2}{A,f}{\Pi_X(A,f)}{A}
	\DefineNamedFunc{forgetfulDemorph2}{(A,f),(B,g),h}{(\Pi_X)_{(A,f),(B,g)}(h)}{h}
	\\
	\Theorem{ForgetfulDemorph2StrictlyCreatesC}{
		\forall \C \in \CAT \.
		\forall X \in \C \. \NewLine \.
		\left[ \Pi_X : \TYPE{StrictlyCreatesC}\left( \TYPE{Connected}\left( \frac{X}{\C} \right) \right) \right]
	}
	\NoProof
	\\
	\Theorem{ForgetfulDemorph2StrictlyCreatesL}{
		\forall \C \in \CAT \.
		\forall X \in \C \. \NewLine \.
		\left[ \Pi_X : \TYPE{StrictlyCreatesL}\left( \TYPE{Diagram}\left( \frac{X}{\C} \right) \right) \right]
	}
	\NoProof
	\\
	\Theorem{EvaluationPreservesColimits}{
		\forall C,A \in \CAT \.
		\Big[ \mathrm{Ev}_A : \TYPE{PreservesColimits}\big( \C^{\A^\obj},\C \big)  \Big]
	}
	\\
	\Theorem{FunctorColimitFibration}{
		\forall C \in \CAT \. 
		\forall \A : \TYPE{Small} \.
		\forall \mathbb{T} : ? \TYPE{Diagram}(\C^\A) \. \NewLine \.
		\forall (0) : \forall A \in \A \. \Big[ \C : \TYPE{WithColimit}(\mathrm{Ev}_A \mathbb{T}) \Big] \.
		\R : \TYPE{StrictlyCreatesC}(\mathbb{T}) \.
	}
	\NoProof
}
\subsection{Representation and Limits}
\Page{
	\Theorem{ConeRepresentation}
	{ 
		\forall \C  : \TYPE{LocallySmall} \. 
		\forall (\I,X) : \TYPE{Diagram}(\A) \. 
		\lim_{i \in \I} \Mor_\C(\cdot,X_i) \iff \mathrm{Cone}_\I(\cdot,X) 
	}
	\Assume{A}{\C}
	\Say{(L,\lambda)}{\lim_{i \in \I} \Mor_\C(A,X_i)}{ \sum L : \Set \. \lambda : L \Rightarrow \Mor_\C(A,X)  }
	\Assume{x}{L}
	\Say{\alpha(A)(x)}{ (A,\lambda(x))  }{  \sum A \in \C \. \prod i \in \I  \. A \Arrow{C} X_i      }
	\Assume{i,j}{\I}
	\Assume{f}{i \Arrow{\I} j}
	\Conclude{()}{ \bd \NT (\lambda) }{   \lambda_i(x) X_{i,j}(f) = \lambda_j(x)   }
	\DeriveConclude{()}{\bd^{-1} \TYPE{Cone}}{\Big[\alpha(A)(x) \in \mathrm{Cone}_\I(A,X)\Big]}
	\Derive{\alpha(A)}{I(\to)}{L \to \mathrm{Cone}_\I(A,X)}
	\Assume{(A,\mu)}{\mathrm{Cone}_\I(A,X)}
	\Say{(1)}{\bd \TYPE{Cone}(\I,X)(A,\mu)}{\Big[ \Big( \Endo_\C(A),\mu^* \Big) : \TYPE{Cone}( \I, \Mor_\C(A,X)  )   \Big]}
	\Say{(\phi,2)}{\bd \TYPE{Limit}(L)(C,\mu)}{  
		\sum \phi : \Endo_\C(A) \to L \.  \forall i \in \I \.  \phi \lambda_i = \mu_i^*
	}
	\Conclude{\beta(A)(A,\mu)}{ \phi({\id}_A)  }{ L }
	\Derive{\beta(A)}{I(\to)}{ \mathrm{Cone}_\I(A,X) \to L}
	\Say{(1)}{\bd \TYPE{Cone}(L,\lambda) \bd \frac{L}{\lambda} \bd^{-1} \TYPE{Cone}}
	{\left[ \left(  \frac{L}{\lambda}  , \lambda \right) : \TYPE{Cone}\Big(\I,\Mor_\C(A,X)\Big) \right]}
	\Say{(2)}{\bd \TYPE{Limit}(L,\lambda)}
		{\exists! \psi : \frac{L}{\lambda} \to L : \forall i \in \I \. \psi \lambda_i = \lambda_i}
	\Say{(3)}{\bd^{-1} \TYPE{Injection} \bd \frac{L}{\lambda}}
	{\left[ \lambda : L \ToInj \prod i \in \I \. A \Arrow{\C} X_i \right]}
	\Say{()_1}{\bd \alpha(A) \bd \beta(A)  \bd \TYPE{Limit}(L,\lambda)\THM{InjectionRetracts}(3) \bd^{-1} {\id}_L  }
	{
		\NewLine :
		\alpha(A)\beta(A) = 
		\Lambda x \in L \.  \beta(A)(A,\lambda(x)) =
		\Lambda x \in L \.  \phi_{\lambda(x)}({\id}_A) =
		\Lambda x \in L \. x =
		{\id}_L
	}
	\Conclude{()_2}{ \bd \beta(A) \bd \alpha(A)  }
	{
		\NewLine :
		\beta(A)\alpha(A) = 
		\Lambda (A,\mu) \in \mathrm{Cone}_\I(A,X) \. \Big(A,\lambda\big(\phi_\mu({\id}_A)\big)\Big) =
		\Lambda (A,\mu) \in \mathrm{Cone}_\I(A,X) \. (A,\mu) =
		\id
	}
	\Derive{\alpha}{ I\left(\prod\right)   }{ \prod A \in \C \. \lim_\I \Mor_\C(A,X_i) \ToBij \mathrm{Cone}_\I(A,X)    }
	\Assume{A,B}{\C}
	\Assume{f}{B \Arrow{\C} A}
	\Say{(L^A,\lambda^A)}{\lim_{i \in \I} \Mor_{\C}(A,X_i) }{ \TYPE{Limit}\big(\I, \Mor_{\C}(A,X)\big)}
	\Say{(L^B,\lambda^B)}{\lim_{i \in \I} \Mor_{\C}(B,X_i)}{ \TYPE{Limit}\big(\I,\Mor_{\C}(B,X)\big)}
	\Say{\mu}{ f_*\lambda^A}{ \prod i \in \I \.  L^A \to \Mor_{\C}(B,X) }
}\Page{
	\Assume{i,j}{\I}
	\Assume{h}{i \Arrow{\I} j }
	\Conclude{()}{  \bd \mu_i \bd \Lambda_A  \bd^{-1} \mu_j     }
	{  \mu_i X_{i,j}^*(h) =  f_* \lambda^A_i X_{i,j}^*(h) = f_*  \lambda^A_j = \mu_j   }
	\Derive{(1)}{\bd^{-1} \TYPE{Cone}}{ \Big[ (L^A,\mu) : \TYPE{Cone}\big(\I,\Mor_{\C}(B,X) \big) \Big]   }
	\Say{(\psi,2)}{\bd \TYPE{Limit}(\I,\Mor_{\C}(A,X))(1)}{ \sum \psi : L^A \to L^B \. \psi\lambda^B = f_*\lambda^A  }
	\Conclude{()}{ \bd \alpha(A)  (2)  \bd^{-1}\alpha(B)}
	{    
		\NewLine :
		\alpha(A) \mathrm{Cone}_{\I;A,B}(f,X)  = 
		\Lambda x \in \lim_{i \in \I} \Mor_{\C}(A,X_i) \. (B, f(\lambda^A(x)) \Big) =  \NewLine =
		\Lambda x \in \lim_{i \in \I} \Mor_{\C}(A,X_i) \.  (B,  \lambda^B(\psi(x)) ) 
								  =	
		\lim_{i \in I;A,B} \Mor_{\C} (f,X_i) \alpha(B)
	}
	\DeriveConclude{(*)}{\bd^{-1}\NT}
	{ \Big[ \alpha : \lim_{i \in \I} \Mor_C(\cdot,X) \iff \mathrm{Cone}_\I(\cdot,X) \Big]  }
	\EndProof
	\\
	\Theorem{RepresentationCommutesWithLimit}{
			\forall \C : \TYPE{LocallySmall} \.
			\forall (\I,X) : \TYPE{Diagram}(\C) \. \NewLine \.
			\forall (0) : \Big[ \C : \TYPE{WithLimit}\{ (\I,X) \} \Big] \.
			\Mor_\C(\cdot, \lim_{i \in \I} X_i) \iff \lim_{i \in \I} \Mor_\C(\cdot,X_i)
		}
	\Say{(L.\lambda)}{\bd(0)}{\TYPE{Limit}(\I,X)}
	\Assume{A}{\C}
	\Assume{f}{A \Arrow{\C} L}
	\Say{\mu}{f\lambda}{\prod i \in \I \. A \Arrow{\C} X_i}
	\Assume{i,j}{\I}
	\Assume{h}{i \Arrow{\I} j}
	\Conclude{ ()  }{ \bd \mu_i \bd \lambda \bd^{-1} \mu_j  }
	{ \mu_i X_{i,j}(h) = f \lambda_i X_{i,j}(h)  = \lambda_j X_{i,j}(h)     }
	\Derive{(1)}{\bd^{-1} \TYPE{Cone}}{\Big[(A,\mu) : \TYPE{Cone} \Big]}
	\Conclude{\alpha(A)(f)}{\I(\to}{ \Mor_\C(A,L) \to \mathrm{Cone}_\I(A,X) }
	\Assume{(A,\mu)}{\mathrm{Cone}_\I(A,X)}
	\Say{(\phi,2)}{\bd \TYPE{Limit}(L,\lambda)(A,\mu)}{ 
		\sum \phi : A \Arrow{\C} L \. \forall i \in \I \. \phi \lambda_i = \mu_i  }
	\Conclude{\beta(A)(A,\mu)}{\phi}{A \Arrow{\C} L}
	\Derive{\beta(A)}{I(\to)}{\mathrm{Cone}_\I(A,X) \to A \Arrow{\C} L}
	\Say{()_1}{ \bd \alpha(A) \bd \beta(A) \bd \TYPE{Limit} \bd \TYPE{unique}}
	{   
		\alpha(A)\beta(A) = 
		\Lambda f : A \Arrow{\C} L \.   \beta(A)(A,f\lambda) = 
		\Lambda f : A \Arrow{\C} L \. f = 
		\id  
	}
	\Conclude{()_2}{\bd \beta(A)\alpha(A) \bd \TYPE{Limit}}
	{
		\beta(A) \alpha(A) =
		\Lambda (A,\mu) : \mathrm{Cone}_\I(A,X) \.  (A,\phi_\mu \lambda) =
		\Lambda (A,\mu) : \mathrm{Cone}_\I(A,X) \. (A,\mu) =
		\id
	}
	\Derive{\alpha}{I\left(\prod\right)}{ \prod A \in \C \. \alpha(A) : \Mor_\C(A,L) \ToBij \mathrm{Cone}_\I(A,X)}
	\Assume{A,B}{\C}
	\Assume{f}{B \Arrow{\C} A}
	\Conclude{}{\bd \alpha(A) \bd f^* \bd^{-1} f^8 \bd^{-1}}
	{ \alpha(A) f^* = \Lambda g : A \Arrow{\C} L \. (B,fg\lambda) = f_*\alpha(B)   }
	\Derive{(1)}{\bd \NT}{\Big[ \alpha : \Mor(\cdot,L) \iff \mathrm{Cone}_\I(\cdot,L)  \Big]}
	\Conclude{(*)}{(1)\THM{ConeRepresentation}\bd L}
	{ \Mor_\C(\cdot,\lim_{i \in \I} X_i) \iff \lim_{i \in  \I} \Mor_\C(\cdot,X_i) }
	\EndProof
} \Page{
	\Theorem{LimRepInterpretation1}{ \forall \C : \TYPE{LocallySmall} \. \forall A \in \C \. 
		\Big[\Mor_\C(A,\cdot) : \TYPE{PreservesLimits}(\C,\SET) \Big]  }
	& \text{Trivially follows from previous therorem.} \\
	\EndProof
	\\
	\Theorem{LimRepInterpretarion2}{
		\forall \C : \TYPE{LocallySmall} \. 
		\forall (\I,X) : \TYPE{Diagram}(\C) \.
		\Mor_\C(\cdot,\lim_{i \in \I} X) =  \lim_{i \in \I} X_i\mathrm{y}
	}
	& \text{Trivially follows from previous therorem.} \\
	\EndProof
	\\
	\Theorem{YonedasEmbeddingOnRepresentation}{
		\forall \C : \TYPE{LocallySmall} \. \NewLine \.
		\mathrm{y} : \TYPE{PreservesLimits} \And \TYPE{ReflectsLimits}(\C,\SET^{\C^\op}) }
	& \text{Use the fact that Yoneda's embedding is fully faithful embedding and apply the to second interpretation. } \\
	\EndProof
	\\
	\Theorem{ColimitAndCorepresentationCocommute}{
			\forall \C : \TYPE{LocallySmall} \.  
			\forall (\I,X) : \TYPE{Diagram} \. \NewLine \.
			\forall (0) :  \Big[ \C : \TYPE{WithColimit}\{ (\I,X) \} \Big]  \.
			\lim_{i \in \I^\op} \Mor_\C(X_i,\cdot) \iff \Mor_{\C}(\colim_{i \in \I} X_i,\cdot) 
		}
	& \text{Use dual tricks in the proofs simmilar to one in the begining of this chapters.   } \\
	\EndProof
	\\
	\Theorem{ColimRepInterpretation1}{ \forall \C : \TYPE{LocallySmall} \. \forall A \in \C \. 
		\Big[\Mor_\C(\cdot,A) : \TYPE{PreservesLimits}(\C,\SET) \Big]  }
	& \text{Trivially follows from previous therorem.} \\
	\EndProof
	\\
	\Theorem{ColimRepInterpretarion2}{
		\forall \C : \TYPE{LocallySmall} \. 
		\forall (\I,X) : \TYPE{Diagram}(\C) \.
		\Mor_\C(\colim_{i \in \I} X, \cdot) =  \lim_{i \in \I^\op} X_i\mathrm{y}
	}
	& \text{Trivially follows from previous therorem.} \\
	\EndProof
	\\
	\Theorem{YonedasEmbeddingOnRepresentation2}{
		\forall \C : \TYPE{LocallySmall} \. \NewLine \.
		\mathrm{y} : \TYPE{PreservesLimits} \And \TYPE{ReflectsLimits}(\C^\op,\SET^\C) }
	& \text{Use the fact that Yoneda's embedding is fully faithful embedding and apply the to second interpretation. } \\
	\EndProof
	\\
	\DeclareType{WithProducts}{ ?\CAT }
	\DefineType{\C}{WithProducts}{
		\forall I \in \SET \. 
		\forall X : I \to \C \. 
		\exists \TYPE{Limit}(\FUNC{discrete}(X),\mathrm{Id}) 
		}
}
\Page{
	\DeclareType{WithCoproducts}{?\CAT}
	\DefineType{\C}{WithCoproducts}{
		\forall I \in \SET \.
		\forall X : I \to \C \.
		\exists \TYPE{Limit}(\FUNC{discrete}(X),\mathrm{Id})
	}
	\\
	\DeclareType{WithEqualizers}{?\CAT}
	\DefineType{\C}{WithEqualizers}{
		\forall A,B \in \C \. 
		\forall f,g : A \Arrow{\C} B \.
		\exists \TYPE{Equalizer}(A,B,f,g)
	}
	\\
	\DeclareType{WithCoequalizer}{?\CAT}
	\DefineType{\C}{WithCoequalizers}{
		\forall A,B \in \C \.
		\forall f,g : A \Arrow{\C} B \.
		\exists \TYPE{Coequalizer}(A,B,f,g)
	}
	\\
	\Theorem{WithProductsAndEqualizersIsComplete}
	{
		\forall \C : \TYPE{WithProducts} \And \TYPE{WithEqualizers} \And \TYPE{LocallySmall} \.
		\NewLine \.
		\C : \TYPE{Complete}
	}
	\Assume{(\I,X)}{\TYPE{Diagram}(\C)}
	\Say{A}{\prod_{i \in \I} X_i}{\C}
	\Say{B}{\prod_{i,j \in \I} \prod_{h \in \Mor_\I(i,j)} X_j  }{\C}
	\Say{f}{ \prod_{i,j \in \I} \prod_{h \in \Mor_\I(i,j)} \pi_j  }{ A \Arrow{\C} B}
	\Say{g}{\prod_{i,j \in \I} \prod_{h \in \Mor_\I(i,j)} \pi_iX_{i,j}(h)}{A \Arrow{\C} B}
	\Say{C}{\bd \TYPE{WithEqualizer}(\C)(A,B,f,g)}{\TYPE{Equalizer}(A,B,f,g)}
	\Assume{Y}{\C}
	\Say{(1)}{\mathrm{Ev}_X \mathrm{y} \THM{EvaluationPreserveslimits} \bd C}
	{ \Big[ \Mor_{\C}(X,C) : \TYPE{Equalizer}( \Mor_{\C}(Y,A),\Mor_{\C}(Y,B),f_*,g_*  ) \Big]  }
	\Say{(2)}{\THM{RepresentationCommutesWithLimit}(1)}
	{ \NewLine : \left[ \Mor_{\C}(Y,C) : \TYPE{Equalizer}\left( \prod_{i \in \I }\Mor_{\C}\left(  Y,X_i \right),
	    \prod_{i,j \in \I} \prod_{f \in \Mor_\I(i,j)}  \Mor_{C}\left( Y,X_i\right) \right),  
	   f_*,g_*   \right] }
	\Conclude{(3)}{\bd \TYPE{Complete}(\SET)(2)}{\Big[ \Mor_\C(Y,X) : \TYPE{Limit}\big( \I, \Mor_\C(Y,X)) \Big]}
	\Derive{(1)}{I(\forall)}{\forall Y \in \C \. \Mor_\C(Y,C) : \TYPE{Limit}\big(\I,\Mor_\C(Y,X)\big)  }
	\Say{(2)}{\THM{LimitFibration}(1)}{\Big[ \Mor_\C(C,\cdot) : \TYPE{Limit}\big(\I,\Mor_\C(Y,X)\big) \Big] }
	\Conclude{()}{\THM{YonedasEmbeddingRepresentation}(2)}{\Big[ C : \TYPE{ Limit }(\I, X) \Big]}
	\DeriveConclude{(*)}{\bd^{-1} \TYPE{Complete}}{\Big[ \C : \TYPE{Complete} \Big]}
	\EndProof
	\\
	\Theorem{WithCoproductsAndCoequalizersIsCocomplete}
	{
		\NewLine  ::
		\forall \C : \TYPE{WithCoproducts} \And \TYPE{WithCoequalizer} \And \TYPE{LocallySmall} \.
		\NewLine \.
		\C : \TYPE{Cocomplete}
	}
	\NoProof
} \Page{
	\DeclareType{FinetlyComplete}{?\CAT}
	\DefineType{\C}{FinetlyComplete}{
		\forall (\I,X) : \TYPE{Diagram}(\C) \.  
		\left| \sum i,j \in \I \.   i \Arrow{\I} j  \right| < \infty \Rightarrow
		\exists  \TYPE{Limit}(I.X)
		}
		\\
	\DeclareType{FinetlyCocomplete}{?\CAT}
	\DefineType{\C}{FinetlyCocomplete}{
		\forall (\I,X) : \TYPE{Diagram}(\C) \.  
		\left| \sum i,j \in \I \.   i \Arrow{\I} j  \right| < \infty \Rightarrow
		\exists  \TYPE{Colimit}(I.X)
		}
		\\
	\DeclareType{WithPullbacks}{?\CAT}
	\DefineType{\C}{WithPullbacks}{
			\forall X : \WEDGE \Arrow{\CAT} \C \. 
			\exists \TYPE{PullBack}(X) 
		}
	\\
	\DeclareType{WithTerminal}{?\CAT}
	\DefineType{\C}{WithTerminal}{\exists X : \TYPE{Terminal}(\C)}
	\\
	\DeclareFunc{terminal}{\prod \C : \TYPE{WithTerminal}}
	\DefineNamedFunc{terminal}{}{0_\C }{\bd \TYPE{WithTerminal}}
	\\
	\DeclareType{WithFiniteProducts}{?\CAT}
	\DefineType{\C}{WithFiniteProducts}{ \forall I : \TYPE{Finite} \. \forall X : I \to \C \. \exists \TYPE{Product}(X) }
	\\
	\DeclareType{WithPushouts}{?\CAT}
	\DefineType{\C}{WithPushouts}{
			\forall X : \VEE \Arrow{\CAT} \C \. 
			\exists \TYPE{Pushout}(X) \.  
		}
	\\
	\DeclareType{WithInitial}{?\CAT}
	\DefineType{\C}{With}{\exists X : \TYPE{Initial}(\C)}
	\\
	\DeclareFunc{initial}{\prod \C : \TYPE{WithInitial} \. \TYPE{Initial}(\C)}
	\DefineNamedFunc{initial}{}{0_\C}{\bd \TYPE{Withinitial}}
	\\
	\DeclareType{WithFiniteCoproducts}{?\CAT}
	\DefineType{\C}{WithFiniteCoroducts}{ \forall I : \TYPE{Finite} \. \forall X : I \to \C \. \exists \TYPE{Coproduct}(X) }
	\\
	\Theorem{ProductAsPullBack}{ 
		\forall \C : \TYPE{WithPullbacks} \And \TYPE{WithTerminal} \.  
		\forall A,B \in \C \.  \NewLine \. 
		\exists A \times B : \TYPE{Product}(A,B) :
		\Big[A \times B : \TYPE{PullBack}(B \to 1 \leftarrow A)\Big]
		}
	\Say{(A \times B,\pi_A,\pi_B)}
	{ \bd \TYPE{WithPullback}(A,B)(B \to 1 \leftarrow A) }{  \TYPE{Pullback}(B \to 1 \leftarrow A)} 
	\Say{(1)}{\bd^{-1} \TYPE{Cone}(A \times B,\pi_A,\pi_B)\bd \TYPE{Pushout}}
	{  \Big[  (A \times B,\pi_A,\pi_B) : \TYPE{Cone}(A,B) \Big]  }
	\Assume{(C,\lambda_A,\lambda_B)}{\TYPE{Cone}(A,B)}
	\Say{f}{\bd \TYPE{Terminal}(1)}{ C \Arrow{\C} 1 }
	\Say{(2)}{\bd^{-1}\TYPE{Cone}\bd \TYPE{Teminal}(1)\bd \TYPE{Cone}(C,\lambda_A,\lambda_B)}
	{\Big[ (C,\lambda_A,\lambda_B,f) : \TYPE{Cone}(A \to 1 \leftarrow B) \Big] }
	\Conclude{(\phi,3)}{\bd \TYPE{Pullback}(A \times B)(2)  }
	{  \sum \phi : C \to A \times B \. \phi \pi_A = \lambda_A \And \phi p_B = \lambda_B   }
	\DeriveConclude{(*)}{\bd^{-1}\TYPE{Product} \TYPE{Terminal}(1)}
	{  \Big[ A \times B : \TYPE{Product}(A.B)  \Big]   }
	\EndProof
} \Page{
	\Theorem{EqualizerAsPullBack}{
		\forall \C : \TYPE{WithPullbacks} \And \TYPE{WithTerminal} \.
		\forall A,B \in \C \.
		\forall f,g : A \Arrow{\C} \. \NewLine \.
		\exists E : \TYPE{Equalizer}(f,g) :
		\Big[ E : \TYPE{Pullback}(A \Arrow[(f,g)]{} B \times B \xleftarrow[(\id,\id)]{} B)  \Big]
	}
	& \text{For any wedge Cone $(C,\lambda_A,\lambda_B, \lambda_{A \times B} )$ 
		it holds that $\lambda_Af =\lambda_Ag = \lambda_B $,} \\
	& \text{Hence it is also a parralel cone for $f$ and $g$.  } \\
	& \text{For any parallel Cone $(C,\lambda_A,\lambda_B)$ it is possible to define 
		$\lambda_{B \times B} = (\lambda_B,\lambda_B) $ making it into wedge-cone.  }\\
	& \text{Hence the limits for these cone agree a limitis for pullbacks exists in the category.}\\
	\EndProof
	\\
	\Theorem{TerminalAndPullbacksGiveFiniteProduct}{
		\forall \C : \TYPE{WithPullbacks} \And \TYPE{WithTerminal} \.  \NewLine \.
		[\C : \TYPE{WithFiniteProducts}]
	}
	\NoProof
	\\
	\Theorem{TerminalAndPullbacksFinitelyComplete}{
		\forall \C : \TYPE{WithPullbacks} \And \TYPE{WithTerminal} \And \NewLine \And
		\TYPE{LocallyFinite}(\C) \. [\C : \TYPE{FinitelyComplete}]
	}
	\NoProof
	\\
	\Theorem{CoproductAsPushout}{ 
		\forall \C : \TYPE{WithPushouts} \And \TYPE{WithInitial} \.  
		\forall A,B \in \C \.  \NewLine \. 
		\exists A \sqcup B : \TYPE{Coproduct}(A,B) :
		\Big[A \sqcup B : \TYPE{Pushout}(B \leftarrow 0 \to A)\Big]
		}
	\NoProof
	\\	
	\Theorem{CoequalizerAsPushout}{
		\forall \C : \TYPE{WithPushout} \And \TYPE{WithInitial} \.
		\forall A,B \in \C \.
		\forall f,g : A \Arrow{\C} \. \NewLine \.
		\exists E : \TYPE{Coequalizer}(f,g) :
		\Big[ E : \TYPE{Pushout}(A \xleftarrow[f|g]{} B \times B \Arrow[\id|\id]{} B)  \Big]
	}
	\NoProof
	\\
	\Theorem{IsnitalAndPushoutssGiveFiniteCoroduct}{
		\forall \C : \TYPE{WithPushouts} \And \TYPE{WithInitial} \.  \NewLine \.
		[\C : \TYPE{WithFiniteCoproducts}]
	}
	\NoProof
	\\
	\Theorem{TerminalAndPushoutsFinitelyCocomplete}{
		\forall \C : \TYPE{WithPushoutss} \And \TYPE{WithInitial} \And \NewLine \And
		\TYPE{LocallyFinite}(\C) \. [\C : \TYPE{FinitelyCocomplete}]
	}
	\NoProof
	\\
}
\subsection{Working with Complete Categories}
\Page{ 
	\DeclareType{Continuous}{\prod \A,\B \in \CAT \. ?(\A \Arrow{\CAT} \B)}
	\DefineType{ F   }{Continuous}{F : \TYPE{PreserveLimits}\Big( \TYPE{Diagram}(\A)  \Big)}
	\\
	\DeclareType{Cocontinuous}{\prod \A,\B \in \CAT \. ?(\A \Arrow{\CAT} \B)}
	\DefineType{F}{Cocontinuous}{F : \TYPE{PreserveColimits}\Big( \TYPE{Diagram}(\A) \Big)}
	\\
	\Theorem{CompleteSlice}{\forall \C : \TYPE{Complete} \.  \forall X \in \C \.  \frac{X}{\C} : \TYPE{Complete}}
	\Assume{\Big(\I,\big((Y,f),\phi\big)\Big)}{\TYPE{Diagram}\;\frac{X}{\C}}
	\Say{O}{ \Obj(\I) \cup \{X\}}{\SET}
	\Say{M(X,X)}{\{{\id}_X\}}{\SET}
	\Say{M}{ \Lambda a,b \in O \. \If b == X != a  \Then \emptyset \Else \If a == X \Then \{f_b\} \Else \Mor_{\I}(a,b) }
	{ O \times O \to \SET  }
	\Say{C(X,X,\cdot)({\id}_X,\cdot)}{\Lambda b \in O \. \Lambda g \in M(X,b) \. g }{\prod b \in O \.  M(X,b) \to M(X,b)}
	\Say{C(X,\cdot,\cdot)}{\Lambda a,b \in \Obj(\I) \. \Lambda g \in M(X,a) \. \Lambda h \in M(a,b) \.  f_b}
	{\prod a,b \in O . M(X,a) \times M(a,b) \to M(X,b)}
	\Say{C}{\Lambda a,b,c \in \Obj(\I) \. \Lambda g \in M(a,b) \. \Lambda h \in M(b,c) \. gh}
	{\prod a,b,c \in O \. M(a,b) \times M(b,c) \to M(a,c)}
	\Say{I(X)}{{\id}_X}{M(X,X)}
	\Say{I}{ \Lambda a \in \Obj(\I) \.{\id}_a  }{\prod a \in O \. M(a,a)}
	\Say{\I'}{(O,M,C,I)}{\TYPE{Small}}
	\Say{F'(X)}{X}{\C}
	\Say{F'}{\Lambda i \in \I \. Y_i}{\I' \to \C}
	\Say{F''(X,\cdot)}{\Lambda a \in \I' \. \Lambda g : X \Arrow{\I'} a \. g }
	{ \prod a \in \I' \. X \Arrow{\I'} a \to X \Arrow{\C} Y_a   }
	\Say{F''}{\Lambda a,b \in \I \. \Lambda h \in a \Arrow{\I} b \. \phi_{a,b}(h)}
	{\prod a,b \in \I' \. a \Arrow{\I'} b \to Y_a \Arrow{\C} Y_b}
	\Say{F}{(F',F'')}{\Cov(\I',\C)}
	\Say{(L,\lambda)}{\bd \TYPE{Complete}}{\TYPE{Limit}(\C)(\I',F)}
	\Say{(1)}{\bd^{-1}\TYPE{Cone} \frac{X}{\C} \bd(L,\lambda) \bd(\I,F)}
	{\bigg[ \big((L,\lambda_X),\lambda_{|\I}\big) :  \TYPE{Cone}\Big(\I,\big((Y,f),\phi\big)\Big)  \bigg]}
	\Assume{\big((C,g),\mu\big)}{\TYPE{Cone}\Big(\I,\big( (Y,f),\phi\big) \Big)}
	\Say{(2)}{\bd^{-1} \TYPE{Cone} \bd \big((C,g),\mu\big)}
	{(C,(\mu_i)_{i \in \I} \oplus (g)_{i=X} ) : \TYPE{Cone}(\I',F) }
	\Say{(\varphi,3)}{\bd \TYPE{Limit}(L,\lambda)(2)}
	{  \sum \varphi : C \Arrow{\C} L \. 
		\Big(\forall i \in \I \. \mu_i = \varphi \lambda_i \Big) \And g = \varphi \lambda_X   }
	\Conclude{()}{\bd^{-1} \int \big((Y,f),\phi)(3)}{\Big[\varphi : 
		\big((C,g),\mu \big) \Arrow{\int ((Y,f),\phi)} \big((L,\lambda_X),\lambda_{|\I}\big)   \Big]}
	\DeriveConclude{()}{\bd^{-1} \TYPE{Limit}}
	{\bigg[ \big((L,\lambda_X),\lambda_{|\I}\big) : \TYPE{Limit}\Big(\I,\big((Y,f),\phi)\Big) \bigg]}
	\DeriveConclude{(*)}{\bd^{-1} \TYPE{Complete}}{\left[ \frac{X}{\C} : \TYPE{Complete} \right]}
	\EndProof
}
\Page{
	\Theorem{CocompleteSlice}{\forall \C : \TYPE{LocallySmall} \. \forall X \in \CAT \.  \frac{X}{\C} : \TYPE{Cocomplete}}
	\Say{(1)}{\THM{ForgetfulDemorph2StrictlyCreatesC} \bd \Pi_X  }
	{\left[ \frac{\C}{X} : \TYPE{WithLimits}(\TYPE{Connected}) \right]}
	\Say{(2)}{ \bd \frac{X}{\C} \bd {\id}_X \bd^{-1} \TYPE{Initial}}
	{\left[ (X,{\id}_X) : \TYPE{Initial}\;\frac{C}{\C}  \right]}
	\Say{(3)}{\THM{CoproductsAsPushouts}^\omega(1)(2)}{\left[ \frac{X}{\C} : \TYPE{WithCoproducts} \right]}
	\Conclude{(*)}{\THM{WithCoproductsAndCoequalizersIsCocomplete}(1,3)}
	{\left[ \frac{X}{\C} : \TYPE{Cocomplete} \right]}
	\EndProof
	\\
	\Theorem{CompleteCoslice}{\forall \C : \TYPE{LocallySmall} \. \forall X \in \CAT \.  \frac{\C}{X} : \TYPE{Complete}}
	\NoProof
	\\
	\Theorem{CocompleteCoslice}{\forall \C \in \CAT \. \forall X \in \CAT \.  \frac{\C}{X} : \TYPE{Cocomplete}}
	\NoProof
	\\
	\Conclude{\TYPE{Subobject}}{\prod \C \in \CAT \. \prod A \in \C \. \sum X \in \C \. A \ToMono{\C} X}
	{ \prod \C \in \CAT \. \prod A \in \C \. \Type }
	\\
	\Conclude{\TYPE{KernelPair}}{\prod \C : \TYPE{WithPullbacks} \. \prod X,Y \in \C \. \prod f : X \Arrow{\C} Y \. 
		\TYPE{Pullback}(X \Arrow[f]{\C} Y \xleftarrow[f]{\C} X)}
	{ \NewLine : \prod \C : \TYPE{WithPullbacks} \.  \prod X,Y \in \C \. X \Arrow{\C} Y \to \Type}
	\\
	\DeclareType{EquivalenceObject}{\prod \C : \TYPE{FinetlyComplete} \. \prod X \in \C \. ?\TYPE{Subobject}(X \times X) }
	\DefineType{(R,\phi)}{EquivaenceObject}{
		\exists \rho : X \Arrow{\C} R : \rho \phi \pi_1 = \rho \phi \pi_2 = {\id}_X \And \NewLine \And
		\exists \sigma : R \Arrow{\C} R : \phi \pi_1 = \sigma \phi \pi_2 \And \phi \pi_2 = \sigma \phi \pi_1
		\And \NewLine \And
		\exists \tau : R \times R \Arrow{\C} R :\pi_1\phi \pi_1 = \tau \phi \pi_1 \And \pi_2 \phi \pi_2 = \tau \phi \pi_2
	}
	\\
	\DeclareFunc{quetientObject}{\TYPE{EquivalenceObject}(\C,X) \to \C}
	\DefineNamedFunc{quetientObject}{R,\phi}{\frac{X}{R}}{\bd \TYPE{FinetlyComplete}(\C)
		(R  \Arrow[\phi\pi_1]{\C} X \xleftarrow[\phi\pi_2]{\C} R   )}
}
\subsection{Functoriality of Limits}
\Page{ 
	\DeclareType{LimitFunctor}{\prod \C : \TYPE{Complete} \. \prod \I : \TYPE{Small} \. ?\big( \C^\I \Arrow{\CAT} \C\big)}
	\DefineNamedType{L}{LimitFunctor}{L = \lim_\I}{\forall X \in \C^\I \. 
		\exists \lambda : \mathrm{Const}_\I(L(X)) \Rightarrow X : \Big[(L(X),\lambda) : \TYPE{Limit}(\I,X)\Big]}
	\\
	\Theorem{LimitFunctorExists}{\forall \C : \TYPE{Complete} \. \forall \I : \TYPE{Small} \. 
		\exists \TYPE{LimitFunctor}(\C,\I)}
	\Assume{X}{\I \Arrow{\CAT} \C}
	\Say{(L,\lambda)}{\bd \TYPE{Complete}(\C)(\I,X)}{\TYPE{Limit}(\I,X)}
	\Say{(F'(X),\lambda^X)}{(L,\lambda)}{ \TYPE{Limit}(\I,X)  }
	\Conclude{(F',\lambda)}{I\left(\prod\right)}{ \prod X : \I \Arrow{\CAT} \C \. \TYPE{Limit}(\I,X) }
	\Assume{X,Y}{\I \Arrow{\CAT} \C}
	\Assume{\alpha}{X \Rightarrow Y}
	\Say{\mu}{ \lambda^X \alpha }{\prod i \in \I \. F(X) \to Y_i}
	\Assume{i,j}{\I}
	\Assume{h}{ i \Arrow{\I} j  }
	\Conclude{()}{\bd \mu_i \bd \NT(\alpha) \bd \TYPE{Cone}(F(X),\lambda^X)\bd^{-1} \mu_j}{ 
		\NewLine :
		\mu_i Y_{i,j}(h) = 
		\lambda^X_i \alpha_i Y_{i,j}(h) = 
		\lambda^X_i X_{i,j}(h) \alpha_j =
		\lambda^X_j \alpha_j =
		\mu_j
	}
	\Derive{(1)}{ \bd^{-1} \TYPE{Cone} }{ \Big[ \big(F'(X),\mu\big) : \TYPE{Cone}(\I,Y) \Big]  }
	\Conclude{\big(F_{X,Y}(\alpha),(2)\big) }{\bd \TYPE{Limit}(F('Y),\lambda^Y)(1)}
	{ \sum F_{X,Y}''(\alpha) : F'(X) \Arrow{\C} F'(Y) \. \lambda^X \alpha = F_{X,Y}''(\alpha)\lambda^Y }
	\Derive{F''}{I\left(\prod\right)}
	{
		\NewLine :
		\prod X,Y : \I \Arrow{\CAT} \C \. \sum F''_{X,Y} :  (X \Rightarrow Y) \to (F'(X) \Arrow{\C} F'(Y))
	 	\. \forall \alpha : X \Rightarrow Y \. \lambda^X \alpha = F_{X,Y}''(\alpha)\lambda^Y
	}
	\Assume{X,Y,Z}{\I \Arrow{\CAT} \C}
	\Assume{\alpha}{X \Rightarrow Y}
	\Assume{\beta}{Y \Rightarrow Z}
	\Say{(1)}{\bd F''}{
		\lambda^X \alpha \beta = 
		F_{X,Y}''(\alpha) \lambda^Y \beta  =
		F_{X,Y}''(\alpha) F_{Y,Z}''(\beta) \lambda_X }
	\Conclude{()}{\bd F'' \bd \TYPE{Limit} (1)}{F_{X,Y}''(\alpha)F_{Y,Z}''(\beta) = F''_{X,Z}(\alpha \beta)}
	\DeriveConclude{(*)}{\bd^{-1} \TYPE{LimitFunctor} \bd (F',F'') \bd^{-1} \Cov}
	{\Big[ (F',F'') : \TYPE{LimitFunctor}(\C,\I) \Big]}
	\EndProof
	\\
	\DeclareType{ColimitFunctor}{\prod \C : \TYPE{Cocomplete} \. 
		\prod \I : \TYPE{Small} \. ?\big( \C^\I \Arrow{\CAT} \C\big)}
	\DefineNamedType{L}{LimitFunctor}{L = \colim_\I}{\forall X \in \C^\I \. 
		\exists \lambda : \mathrm{Const}_\I(L(X)) \Leftarrow X : \Big[(L(X),\lambda) : \TYPE{Colimit}(\I,X)\Big]}
	\\
	\Theorem{ColimitFunctorExists}{\forall \C : \TYPE{Cocomplete} \. \forall \I : \TYPE{Small} \. 
		\exists \TYPE{ColimitFunctor}(\C,\I)}
	\NoProof
} \Page{
	\Theorem{AssociativeProducts}{\forall \C : \TYPE{WithFiniteProducts} \.  \forall X,Y,Z \in \C \.
		(X \times Y) \times Z \cong X \times (Y \times Z) }
&    (X \times Y) \times Z \cong X \times Y \times Z \cong X \times (Y \times Z)      \\
\EndProof
}
\newpage
\subsection{Freyd Theorem}
\Page{
	\Theorem{SelfLimitIsInitial}{ \forall \I : \TYPE{Small} \. \forall (L,\lambda) = \lim_{\I} \mathrm{Id} \.
		L : \TYPE{Initial}  }
	\Say{(1)}{\bd \TYPE{Cone}(\I,\mathrm{Id})(\lambda_L)}{\forall X \in \I \. 
		 \.
		\lambda_L \lambda_X = \lambda_X
	}
	\Say{(2)}{\bd \int_\I \mathrm{Id} (1)}{ \lambda_L : (L,\lambda) \Arrow{\int_{\I} \mathrm{Id}} (L,\lambda)}
	\Say{(3)}{\bd \TYPE{Limit}(L,\lambda)(2)}{ \lambda_L = {\id}_L}
	\Assume{X}{\I}
	\Assume{f}{L \Arrow{\I} X}
	\Conclude{()}{\bd \TYPE{Cone}(L,\lambda)(X,f)(3)}{  \lambda_X =  \lambda_L f  = f  }
	\DeriveConclude{(*)}{\bd^{-1} \TYPE{Initial} \bd \lambda}{ [X : \TYPE{Initial}(\I)]}
	\EndProof
	\\
	\Theorem{SelfColimitIsTerminal}{\forall \I : \TYPE{Small} \. \forall (L,\lambda) = \colim_{\I} \mathrm{\id} \. 
		L : \TYPE{Terminal}}
	\\
	\DeclareType{WeaklyInitial}{\prod \C \in \CAT \. ?\C}
	\DefineType{A}{WeaklyInitial}{\forall X \in \C \. \exists A \Arrow{\C} X}
	\\
	\DeclareType{WeaklyTerminal}{\prod \C \in \CAT \. ?\C}
	\DefineType{A}{WeaklyTerminal}{\forall X \in \C \. \exists X \Arrow{\C} A}
	\\
	\DeclareType{KComplete}{\mathsf{CARD} \to ?\CAT}
	\DefineNamedType{\C}{KComplete}{\C : \kappa\hyph\TYPE{Complete}}{
		\Lambda \kappa \in \mathsf{CARD} \. 
		\forall (\I,X) : \TYPE{Diagram}(\C) \. \NewLine \. 
		\left| \sum i,j \in \I \. i \Arrow{\I} j   \right| \le \kappa \Rightarrow
		\exists \TYPE{Limit}(\I,X)
	}
	\\
	\DeclareType{KCocomplete}{\mathsf{CARD} \to ?\CAT}
	\DefineNamedType{\C}{KCocomplete}{\C : \kappa\hyph\TYPE{Cocomplete}}{
		\Lambda \kappa \in \mathsf{CARD} \. 
		\forall (\I,X) : \TYPE{Diagram}(\C) \. \NewLine \. 
		\left| \sum i,j \in \I \. i \Arrow{\I} j   \right| \le \kappa \Rightarrow
		\exists \TYPE{Colimit}(\I,X)
	}
	\\
	\DeclareType{KSmall}{\mathsf{CARD} \to ?\CAT}
	\DefineNamedType{\C}{KSmall}{\C : \kappa\hyph\TYPE{Small}}{\left| \sum X,Y \in \C \. X \Arrow{\I} Y   \right| \le \kappa}
	\\
	\DeclareFunc{KPower}{\prod \kappa \in \mathsf{CARD} \. \prod \C : \kappa\hyph\TYPE{Complete} \. \C \to \kappa \to \C}
	\DefineNamedFunc{KPower}{X,\omega}{X^\omega}{\prod_{i \in \omega} X }
	\\
	\DeclareFunc{KTensor}{\prod \kappa \in \mathsf{CARD} \. \prod \C : \kappa\hyph\TYPE{Cocomplete} \. \C \to \kappa \to \C}
	\DefineNamedFunc{KTensor}{X,\omega}{\omega X}{\coprod_{i \in \omega} X }
} \Page{
	\Theorem{FreydTheorem}{\forall \kappa \in \mathsf{CARD} \. 
		\forall \C : \kappa\hyph\TYPE{Small} \And \kappa\hyph\TYPE{Completete} \. \C : \TYPE{Preorder}}
	\Say{\omega}{\left| \sum X,Y \in \C \. X \Arrow{\C} Y \right|}{ \mathsf{CARD}}
	\Say{(1)}{\bd \kappa\hyph \TYPE{Small}(\C)\bd \omega}{\omega \le \kappa}
	\Assume{X,Y}{\C}
	\Assume{f,g}{X \Arrow{\C} Y}
	\Assume{(2)}{f \neq g}
	\Say{(3)}{\bd \TYPE{Product} \bd Y^\omega\bd \kappa\hyph\TYPE{Complete}(\C)(1)}
	{\Big| X \Arrow{\C} Y^\omega \Big| \le 2^\omega}
	\Say{(4)}{\bd^{-1} \TYPE{CardLess}(\bd \omega)(2)\THM{CantorTHM}(\omega)}{\omega < 2^\omega \le \omega}
	\Say{(5)}{\bd \TYPE{CardGreater}(4)}{ \omega \neq \omega  }
	\Conclude{(6)}{I(\bot)(5)}{\bot}
	\DeriveConclude{(*)}{E(\bot) \bd \TYPE{Preorder}}{[\C : \TYPE{Preorder}]}
	\EndProof
	\\
	\Theorem{FreydTheorem2}{\forall \kappa \in \mathsf{CARD} \. 
		\forall \C : \kappa\hyph\TYPE{Small} \And \kappa\hyph\TYPE{Cocompletete} \. \C : \TYPE{Preorder}}
	\NoProof
}
\newpage
\subsection{Interaction of Limits and Colimits}
\Page{
	\Theorem{DoubleLimit}{
			\forall \I,\J : \TYPE{Small} \. \forall \C : \TYPE{Complete} \And \TYPE{LocallySmall} \. 
			\forall F : \I \times \J \Arrow{\CAT} \C \. \NewLine \.
			\forall X : \prod i \in \I \. \TYPE{Limit}\big(\J,F(i,\cdot)\big) \.
			\forall Y : \prod j \in \J \. \TYPE{Limit}\big(\I,F(\cdot,j)\big) \. \NewLine
			\lim_{i \in \I} X_i \cong_\C \lim_{(i,j) \in \I \times \J} F(i,j) \cong_\C \lim_{j \in \J} Y_j
		}
		\Assume{A}{\C}
		\Say{H}{ \Lambda i,j \in \I \. \Mor_{\C}\big(A,F(i,j)\big) }{\I \times \J \Arrow{\CAT} \SET }
		\Say{(1)}{\bd H \THM{LimCommutes}(F)}
		{
			\lim_{i \in \I} \lim_{j \in \J} H(i,j) \cong_\SET
			\lim_{i \in \I} \lim_{j \in \J} \Mor_\C\big(A,F(i,j)\big) =
			\Mor_\C\big(A, \lim_{i \in \I} \lim_{i \in \J }F(i,j)\big)
		}
		\Say{(2)}{ \THM{LimCommutes}(F)}
		{ 
			\lim_{(i,j) \in \I \times \J } H(i,j) \cong_\SET
			\Mor_\C\big( A , \lim_{(i,j) \in \I \times \J} F(i,j)  \big)
		}
		\Say{(3)}{\THM{LimitRepresentation}(H)}{\lim_{(i,j) \in \I \times \J} H(i,j) \cong_{\SET} \mathrm{Cone}_{H}(1)}
		\Say{(4)}{ \THM{LimitReprsentatuin}(\lim_{i \in \I} \lim_{j \in \I} H(i,j))}
		{ \lim_{i \in \I} \lim_{j \in \I} H(i,j) \cong_{\SET} \mathrm{Cone}_{\lim_{j \in \J} H(\cdot,j)}(1) }
		\Assume{(1,\lambda)}{\mathrm{Cone}_{H}(1)}
		\Assume{i}{\I}
		\Say{(5)}{\bd \TYPE{Cone}(1,\lambda)}{\Big[(1,\lambda_{|\{i\} \times \J}i) :\TYPE{Cone}(\J, H(i,\cdot))\Big]}
		\Conclude{\mu_i}{\bd \TYPE{Limit}(\lim_{j \in \J} H(i,j))}{ 1 \to \lim_{j \in \J} H(i,j)}
		\Derive{\mu}{I\left(\prod\right)}{\prod i \in \I \. \mu_i : 1 \to \lim_{j \in \J} H(i,j) }
		\Assume{i,i'}{\I}
		\Say{\eta}{\FUNC{legs}(\lim_{j \in \J} H(i,j ))}{\prod j \in \J \. \lim_{k \in \J} H(i,k) \to H(i,j) }
		\Say{\eta'}{\FUNC{legs}(\lim_{j \in \J}  H(i',j) )}{\prod j \in \J \. \lim_{k \in \J} H(i',k) \to H(i',j)}
		\Assume{h}{i \Arrow{\I} i'}
		\Assume{j}{\J}
		\Say{(5)}{\bd  \lim_{j \in \J } H\big((i,i'),j \big)(h)\bd \mu}
		{   \mu_i \lim_{j \in \J} H\big((i,i'),j \big)(h)\eta'_j = \mu_i \eta_j = \lambda_{i,j}  }
		\DeriveConclude{()}{\bd \TYPE{Limit} \bd \mu (5)(i,i')}
		{ \mu_i \lim_{j \in \J} H\big( (i,i'),j\big)(h) = \mu_{i'}  }
		\Derive{(5)}{\bd^{-1} \TYPE{Cone}}{\Big[  (1,\mu) :  \mathrm{Cone}_{\lim_{j \in \J} H(\cdot,j)}(1)   \Big]}
		\Conclude{\varphi(1,\lambda)}{(1,\mu)}{\mathrm{Cone}_{\lim_{j \in \J} H(\cdot,j)}(1)}
		\Derive{\varphi}{I(\to)}{\mathrm{Cone}_H(1) \to \mathrm{Cone}_{\lim_{j \in \J} H(\cdot,j)}(1) }
		\Assume{(1,\lambda)}{\mathrm{Cone}_{\lim_{j \in \J} H(\cdot,j)}(1) }
		\Assume{i}{\I}
		\Say{\eta}{\FUNC{legs}(\lim_{j \in \J} H(i,j ))}{\prod j \in \J \. \lim_{k \in \J} H(i,k) \to H(i,j) }
		\Assume{j}{\J}
		\Conclude{\mu_{i,j}}{\lambda_i \eta_j}{1 \to H(i,j)}
		\Derive{\mu}{I\left( \prod \right)}{\prod (i,j) \in \I \times \J \. 1 \to H(i,j)}
}\Page{
		\Assume{i,i'}{\I}
		\Assume{j,j'}{\J}
		\Say{\eta}{\FUNC{legs}(\lim_{j \in \J} H(i,j ))}{\prod j \in \J \. \lim_{k \in \J} H(i,k) \to H(i,j) }
		\Say{\eta'}{\FUNC{legs}(\lim_{j \in \J}  H(i',j) )}{\prod j \in \J \. \lim_{k \in \J} H(i',k) \to H(i',j)}
		\Assume{h}{(i,i') \Arrow{\I \times \J} (j,j')}
		\Conclude{()}{ 
			\bd \mu_{i,j} \bd \Cov(\I \times \J,\SET)(H)\bd \I \times \J \bd \eta 
			\bd^{-1} \lim_{k \in \J} H\big((i,i'),k\big)(\pi_1 h) \bd \lambda \bd^{-1} \mu_{i',j'} 
		}
		{  
			\NewLine :
			\mu_{i,j} H_{(i,j),(i',j')}(h) =
			\lambda_i \eta_j H_{(i,j),(i,j')}(\id \times \pi_2 h) H_{(i,j'),(i',j')}(\pi_1 h \times \id) 
			= \NewLine =
			\lambda_i \eta_{j'} H_{(i,j'),(i',j')}(\pi_1 h \times \id) =   
			\lambda_i \lim_{k \in \J} H\big((i,i'),k\big)(\pi_1 h) \eta'_{j'} = 
			\lambda_{i'} \eta'_{j'} =
			\mu_{i',j'}    
		}
		\Derive{(5)}{\bd^{-1} \TYPE{Cone}}{\Big[ (1,\mu) : \mathrm{Cone}_{H}(1) \Big] }
		\Conclude{\psi(1,\lambda)}{(1,\mu)}{ \mathrm{Cone}_{H}(1)  }
		\Derive{\psi}{I(\to)}{\mathrm{Cone}_{H}(1) \to \mathrm{Cone}_{\lim_{j \in \J} H(\cdot,j)}(1) }
		\Say{(5)}{ \bd \varphi \bd \TYPE{Limit} \bd^{-1} \id  }
		{  \varphi \psi = \Lambda (1,\lambda) : \mathrm{Cone}_{H}(1) \. (1,\lambda) = \id        }
		\Say{(6)}{\bd \psi}{  \psi \varphi = \id  }
		\Say{(7)}{\bd \TYPE{Inverse}\bd \TYPE{Isomorphis}(\SET)}
		{ \mathrm{Cone}_{H}(1) \cong \mathrm{Cone}_{\lim_{j \in \J} H(\cdot,j)}(1) }
		\Conclude{(*)}{\THM{YonedasLemma}(1)(2)(3)(4)(7)}{\LOGIC{This}}
		\EndProof
		\\
		\Theorem{DoubleColimit}{
			\forall \I,\J : \TYPE{Small} \. \forall \C : \TYPE{Cocomplete} \And \TYPE{LocallySmall} \. 
			\forall F : \I \times \J \Arrow{\CAT} \C \. \NewLine \.
			\forall X : \prod i \in \I \. \TYPE{Colimit}\big(\J,F(i,\cdot)\big) \.
			\forall Y : \prod j \in \J \. \TYPE{Colimit}\big(\I,F(\cdot,j)\big) \. \NewLine
			\colim_{i \in \I} X_i \cong_\C \colim_{(i,j) \in \I \times \J} F(i,j) \cong_\C \colim_{j \in \J} Y_j
		}
		\NoProof
		\\
		\Theorem{ColimLimTHM}{
			\forall \I,\J : \TYPE{Small} \. 
			\forall \C : \TYPE{Complete} \And 
			\TYPE{Cocomplete} \.
			\forall F : \TYPE{Bifunctor}(\I,\J,\C) \. \NewLine \. 
			\exists  k : \colim_{i \in \I} \lim_{j \in \J} F(i,j) \Arrow{\C} \lim_{j \in \J} \colim_{i \in \I} F(i,j)
		}
		\Assume{i}{\I}
		\Say{\lambda}{\FUNC{legs}(\lim_{k \in \J} F(i,k)) }{\prod k \in \J \. \lim_{l \in \J} F(i,l) \Arrow{\C} F(i,k) }
		\Assume{j}{\J}
		\Say{\mu}{\FUNC{legs}(\lim_{k \in \I}F(k,j))}{\prod k \in \I \. F(k,j) \Arrow{\C} \colim_{l \in \I} F(l,j)}
		\Conclude{\eta_j}{\lambda_j\mu_i}{ \lim_{k \in \J} F(i,k) \Arrow{\C} \colim_{k \in \I} F(k,j)  }
		\Derive{\eta}{I\left(\prod\right)}{\prod j \in \J \. \lim_{k \in \J}  F(i,k) \Arrow{\C} \colim_{k \in \I} F(k,j)}
		\Assume{j,j'}{\J}
		\Assume{h}{j \Arrow{\J} j'}
		\Conclude{()}{ \bd \eta_j \bd \colim \bd \lambda \bd^{-1} \eta_{j'} }
		{       
			\NewLine :
			\eta_j \colim_{k \in \I} F\big(k,(j,j')\big)(h) =              
			\lambda_j \mu^j_i \colim_{k \in \I} F\big(k,(j,j')\big)(h) =
			\lambda_j  F\big(i,(j,j')\big)(h) \mu^{j'}_i =
			\lambda_{j'} \mu^{j'}_i  =
			\eta_{j'}
		}
} \Page{
	\Derive{(1)}{\bd^{-1} \TYPE{Cone}}
	{ \Big[ \big(\lim_{j \in \J} F(i,j),\eta\big) : \TYPE{Cone}\big(\J, \colim_{i \in \I} F(i,\cdot) \big)  \Big]}
	\Conclude{(\phi_i,2)}{\bd^{-1} \TYPE{Limit}}
	{ \sum \phi_i : \lim_{j \in \J} F(i,j) \Arrow{\C} \lim_{j \in \J} \colim_{i \in \I} F(i,j) \. 
	   \forall j \in \J \. \phi_i \nu_j = \eta_j }
	\Derive{\phi}{I\left(\prod\right)}
	{\prod i \in \I \.\sum \phi_i : \lim_{j \in \J} F(i,j) \Arrow{\C} \lim_{j \in \J} \colim_{i \in \I} F(i,j)
		\. \forall j \in \J \. \phi_i \nu_j = \eta_j
	}
	\Assume{i,i'}{\I}
	\Assume{h}{i \Arrow{\I} i'}
	\Assume{j}{\J}
	\Conclude{()}{\bd \phi \bd \eta}{  
		\lim_{j \in \J} F\Big( (i,i'),j \Big)(h)\phi_{i'} \nu_j = 
		\lim_{j \in \J} F\Big( (i,i'), j \Big)(h)\eta_j^{i'} = \eta_j^i
		}
	\Derive{(1)}{\bd \int \mathrm{Cone}}{\Big[ \lim_{j \in \J} F\big((i,i'),j\big)\phi_i : 
		\lim_{j \in \J} F(i',j)   \Arrow{\int \mathrm{Cone}} \lim_{j \in \J} F(i,j) \Big] }
	\Conclude{()}{\bd \TYPE{Limit}\bd\phi}{ \lim_{j \in \J} F\big((i,i'),j\big)(h)\phi_{i} = \phi_{i'} }
	\Derive{(1)}{\bd^{-1}\TYPE{Cocone}}
	{\Big[ (\lim_{j \in \J} \colim_{i \in \I} F(i,j),\phi) :  \TYPE{Cocone}(\I,\lim_{j \in \J} F(\cdot,J)) \Big]   }
	\Conclude{\psi}{\bd \TYPE{Colimit}(1)}
	{\colim_{i \in \I} \lim_{j\in \J} F(i,j) \Arrow{\C} \lim_{j \in \J} \colim_{i \in \I} F(i,j)  }
	\EndProof
	\\
	\DeclareType{KFiltered}{\mathsf{CARD} \to ?\CAT}
	\DefineNamedType{\I}{KFilterded}{\I : \kappa\hyph\TYPE{Filtered}}{  
		\forall \J \in \Cat \. 
		\forall () : |\J^\to| < \kappa \. 
		\forall I : \J \Arrow{\CAT} \I \. \NewLine \.       
		\exists \TYPE{Cocone}(\J,I)
	}
	\\
	\Theorem{FilteredColimitStructure}{
		\forall \I : \TYPE{Small} \And \TYPE{Filtered} \.
		\forall X : \I \Arrow{\CAT} \SET \.
		\colim_{i \in \I} X_i = \frac{\bigsqcup_{i \in \I} X_i}{R} \NewLine \where \NewLine
			R = \left\{  
				\Big( (i,x),(j,y) \Big) \in \bigsqcup_{i \in \I} X_i \times \bigsqcup_{i \in \I} X_i :
				\exists t \in \I : 
				\exists f : i \Arrow{\I} t : 
				\exists g : j \Arrow{\I} t :
				X_{i,t}(f)(x) = X_{j,t}(g)(y)
			\right\}
		}
&	\text{Inspect the definition of equivalence relation $(\sim)$ in $\THM{SetIsCocomplete}$.} \\
&	\text{ $(\sim) = \FUNC{eqclosure}(T)$ end it is easy to see that $T \subset R \subset (\sim)$, }  \\
&	\text{ and hence, as $R$ is equivalence by property of $\I$ of being filtered, $R =(\sim)$.   } \\
	\EndProof
} \Page{
	\Theorem{FilterdColimCommutesWithLim}{
		\forall \I : \aleph_0\hyph\TYPE{Filtered} \And \TYPE{Small} \.
		\forall n \in \Nat \.
		\forall \J : n\hyph\TYPE{Small} \. \NewLine \.
		\forall F : \I \times \J \Arrow{\CAT} \SET \. 
		\colim_{i \in \I} \lim_{j \in \J} F(i,j) \cong_{\SET} \lim_{i \in \I} \lim_{j \in \J} F(j,i)
	}
	\Say{\kappa}{\THM{ColimLimTHM}(F)}
	{\colim_{i \in \I} \lim_{j \in \J} F(i,j) \to \lim_{j \in \J} \colim_{i \in \I} F(i,j) }
	\Say{(1)}{\THM{LimRepresentation}( \colim_{i \in \I} F(i,\cdot) )}
	{ \lim_{j \in \J} \colim_{i \in \I} F(i,j) \cong \mathrm{Cone}_{\colim_{i \in \I} F(i,\cdot)}(1)}
	\Assume{(1,\lambda)}{\mathrm{Cone}_{\colim_{i \in \I} F(i,\cdot)}(1)}
	\Assume{j}{\J}
	\Conclude{((t_j,x_j),2)}{\THM{SetIsCocomplete}\lambda_j(1)}
	{\sum (t_j,x_j) \in \bigsqcup_{i \in \I} F(i,j) \. [t_j,x_j] = \lambda_j(1)  }
	\Derive{(t,x,2)}{I\left(\prod\right)}{ \prod j \in \J \. \sum t_j \in \I \. \sum x \in  F(i,j) \. [x] =  \lambda_j(1)}
	\Assume{j,j'}{\J}
	\Assume{h}{j \Arrow{\J} j'}
	\Say{ f }{ \colim_{i \in \I} F(i,(j,j'))(h)  }{ \colim_{i \in \I} F(i,j) \to \colim_{i \in \I} F(i,j')  }
	\Say{(3)}{\bd \TYPE{Cone}(1,\lambda)}{f[t_j,x_j] =[t_{j'},x_{j'}]}
	\Say{(4)}{\bd \colim_{i \in \I} F(i,j)\bd f}{\forall i \in \I \. \Big[F(i,(j,j'))(h)\Big] = f[\cdot]}
	\Say{(5)}{(4)(3)}{ \big[ F(t_j,(j,j'))(h)(x_j) \big] = [t_{j'},x_{j'}]   }
	\Say{(\tau,g,g',6)}{\THM{FilteredColimitStructure}(5)}
	{       \NewLine :  
		\sum \tau \in \I \. 
		\sum g : t_{j} \to \tau \. 
		\sum g' : t_{j'} \to \tau \. 
		F(t_{j},(j,j'))(h)F((t_{j},\tau),j')(g)(x_j) = F((t_{j'},\tau),j')(g')(x_{j}')           
	} 
	\Say{(t_{j},x_{j})  }{  \Big(\tau, F\big((t_{j},\tau),j\big)(g)(x)\Big)}
	{ \sum t_{j} \in \I \. H(\tau,j) \quad !\LOGIC{Redefine}!} 
	\Conclude{(t_{j'},x_{j'})  }{ \Big(\tau, F\big((t_{j'},\tau),j'\big)(g)(x)\Big)}
	{\sum t_{j'} \in \I \.  H(\tau,j') \quad !\LOGIC{Redefine}! }
	\Derive{(3)}{I(\forall)}{\forall j,j' \in \J \. \forall h : j \Arrow{\J} j' \. t_{j} = t_{j'}}
	\Say{(s,\mu)}{\bd \TYPE{Filtered}(\I)(t)}{\TYPE{Cocone}(\J,(t,\id))}
	\Say{\lambda'}{ \Lambda j \in \J \. \Lambda 1 \in 1 \.  F((t_j,s),j)(\mu_j)(x_j) }
	{ \prod j \in \J \. 1 \to F(s,j) }
	\Say{(4)}{\bd^{-1}\TYPE{Cone}\bd \lambda' \bd x}{\Big[ (1,\lambda') : \TYPE{Cone}\big( \J, F(s,\cdot) \big)\Big]}
	\Conclude{()}{\bd \kappa}{\kappa[1,\lambda']  = (1,\lambda)}
	\Derive{(2)}{\bd^{-1} \TYPE{Surjective}}
	{\Big[ \kappa : \colim_{i \in \I} \lim_{j \in \J} F(i,j) \ToSurj \lim_{j \in \J} \colim_{i \in \I} F(i,j)\Big] }
	\Assume{\big[i,(1,\alpha)\big],\big[i',1,\beta\big]}{\colim_{i \in \I} \lim_{j \in \J} F(i,j)}
	\Assume{(3)}{ \kappa\big[i,(1,\alpha)\big] = \kappa\big[i',(1,\beta)\big]  }
	\Say{(t,h,h',4)}{\bd \kappa (3)}{
		\prod j \in \J \. 
		\sum t_j \in \I \. 
		\sum h_j : i \Arrow{\I} t_j \.  
		\sum h'_j : i' \Arrow{\I} t_j \.
		F((i,t_j),j)(h_j)(\alpha_{j}(1)) = F((i,t_j),j)(h_j')(\beta_{j}(1)) }
	\Say{(s,\mu)}{\bd \TYPE{Filtered \I}(t,h,h')}{ \TYPE{Cocone}(\J + 2, t + (i,i')) }
	\Say{(5)}{\bd \TYPE{Cocone}(s,\mu)(4)}{ 
		\forall j \in \J \. F((i,s),j)( h_j\mu_j )(\alpha_j(1)) =  F((i',s),j)(h_j'\mu_j)(\beta_j(1)) }
	\Conclude{(6)}{ \THM{FilteredColimitStructure}(5)}{ \big[ i, (1,\alpha) \big] = \big[i',(1,\beta)\big]   }
	\Derive{(3)}{\bd^{-1} \TYPE{Bijective}\bd^{-1} \TYPE{Surjective}}
	{\Big[ \kappa : \colim_{i \in \I} \lim_{j \in \J} F(i,j) \ToBij \lim_{j \in \J} \colim_{i \in \I} F(i,j)\Big] }
	\Conclude{(*)}{\bd \TYPE{Isomorphic}(\SET)(3)}
	{\Big[  \colim_{i \in \I} \lim_{j \in \J} F(i,j) \cong_\SET \lim_{j \in \J} \colim_{i \in \I} F(i,j)\Big] }
	\EndProof
}
\newpage
\subsection{Exponentiation}
\Page{
	\DeclareType{Exponent}{\prod \C : \TYPE{WithFiniteProduct} \. \prod A,B \in \C \. 
		\sum A^B \in \C \. A^B \times B \Arrow{\C} A}
	\DefineType{(A^B,\epsilon)}{Exponent}{
		\forall X \in \C \. 
		\forall f : X \times B \Arrow{\C} A \. 
		\exists! \tau :  X \Arrow{\C} A^B :
		   (\tau \times {\id}_\B) \epsilon = f
		}
	\\
	\DeclareFunc{implicit}{\TYPE{Exponent}(\C,A,B) \to \C}
	\DefineFunc{implicit}{A^B,\epsilon}{A^B}
	\\
	\DeclareFunc{evaluation}{ \prod E : \TYPE{Exponent}(\C,A,B) \. E \times B \Arrow{\C} A }
	\DefineNamedFunc{evaluation}{}{\mathrm{ev}_E}{\epsilon \quad \where \quad  (A^B,\epsilon) = E}
	\\
	\DeclareFunc{curry}{\prod E : \TYPE{Exponent}(\C,A,B) \. \prod X \in \C \. (X \times B \Arrow{\C} A) \to X \Arrow{\C} E}
	\DefineNamedFunc{curry}{}{\lambda^E}{\bd \TYPE{Exponent}(\C,A,B)(E)} 
	\\
	\DeclareType{WithExponentiation}{?\CAT}
	\DefineType{\C}{WithExponentiation}{\forall A,B \in \C \. \exists \TYPE{Exponentiation}(A,B,\C)}
	\\
	\DeclareFunc{exponent}{ \prod \C : \TYPE{WithExponent} \. \prod A, B \in \C \. \TYPE{Exponent}(\C,A,B)}
	\DefineNamedFunc{exponent}{}{A^B}{\bd \TYPE{WithExponent}(\C)(A,B)}
}
\newpage
\section{Adjunctions}
\subsection{Adjoint Functors}
\Page{
	\DeclareType{Adjoint}{\prod \A, \B \in \mathsf{LSCAT} \. ?\Big((\A \Arrow{\CAT} \B) \times (\B \Arrow{\CAT} \A)\Big)}
	\DefineNamedType{(F,G)}{Adjoint}{F \dashv G}
	{
		\exists  \alpha : \prod A \in \A \.  
			\prod B \in \B \.
			\bigg( \Mor_\B\Big( F(A),B \Big)  \ToBij \Mor_\A\Big(A,G(B)\Big) \bigg) : 
			\NewLine :
		\bigg( \forall B \in \B \.
			\alpha : \Mor_\B\Big(F(\cdot),B\Big) \iff \Mor_\A \Big( \cdot,G(B)\Big) \bigg) \And \NewLine \And
		\bigg( \forall A \in \A \. 
			\alpha : \Mor_\B\Big( F(A),\cdot) \iff \Mor_\A \Big( A, G(\cdot)\Big) \bigg)
	}
	\\
	\DeclareFunc{transpose}{
		\prod \A,\B \in \mathsf{LSCAT} \.
		\prod \sum  F : \A \Arrow{\CAT} \B \.
		 \sum  G : \A \Arrow{\CAT} \B \.
		  F \dashv G   \. \NewLine \.
		\prod A \in \A \.
		\prod B \in \B \.
		\Mor_{\B}(F(A),B) \to \Mor_{\A}(A,G(B))
	}
	\DefineNamedFunc{transpose}{f}{f^{\top_{F,G}}}{\bd \TYPE{Adjoint}(F,G)(f)}
	\\
	\DeclareFunc{antitranspose}{
		\prod \A,\B \in \mathsf{LSCAT} \.
		\prod \sum  F : \A \Arrow{\CAT} \B \.
		 \sum  G : \A \Arrow{\CAT} \B \.
		  F \dashv G   \. \NewLine \.
		\prod A \in \A \.
		\prod B \in \B \.
		\Mor_{\A}(A,G(B)) \to \Mor_{\B}(F(A),B)
	}
	\DefineNamedFunc{antitranspose}{f}{f^{\bot_{F,G}}}{\bd \TYPE{Adjoint}(F,G)(f)}
	\\
	\Theorem{AdjointFunctorsChar}{
		\forall \A,\B \in \mathsf{LSCAT} \.
		\forall F  : \A \Arrow{\CAT} \B \.
		\forall G : \B \Arrow{\CAT} \A  \.
		\NewLine \forall \alpha : 
			\prod A \in \A \. 
			\prod B \in \B \. 
			(\Mor_\B(F(A),B) \ToBij \Mor_\A(A,G(B))) \.
		(F \dashv G,\alpha) \iff \NewLine \iff:
		\Big(	\forall A,A' \in \A \.
			\forall B,B' \in \B \.
			\forall f : F(A) \Arrow{\B} B \.
			\forall g : F(A') \Arrow{\B} B' \.
			\forall h : A \Arrow{\A} A'  \.
			\forall k : B \Arrow{\B} B' \.  \NewLine \. 
				fk = F(h) g \iff \alpha(A,B)(f)G(k) = h \alpha(A',B')(g) 
		\Big)
	}
	\Assume{(1)}{ (F \dashv G, \alpha )  }
	\Assume{A,A'}{\A}
	\Assume{B,B'}{\B}
	\Assume{f}{F(A) \Arrow{\B} B}
	\Assume{g}{F(A') \Arrow{\B} B'}
	\Assume{h}{A \Arrow{\A} A'}
	\Assume{k}{B \Arrow{\B} B'}
	\Say{(2)}{  \bd^{-1} k^*  \bd^{-1} \Mor_\B\Big((F(A),F(A),(B,B'))\Big)  \bd \NT(\alpha) \bd^{-1} G(k)}{
		\NewLine :
		\alpha(A,B')fk =  
		\alpha(A,B')k^* f = 
		\alpha(A,B')\Mor_\B\Big((F(A),F(A)),(B,B')\Big)(\id \times k)(f) = \NewLine =
		\Mor_\A\Big((A,A),(G(B),G(B'))\Big)(\id \times k) \alpha(A,B)(f)  =  
		\alpha(A,B)(f)G(k)
	}
	\Say{(3)}{   \bd^{-1} F_*(h)  \bd^{-1} \Mor_\B\Big((F(A),F(A)),(B,B'))\Big) \bd \NT(\alpha) \bd^{-1} h_* \bd h_*}{
		\NewLine :
		\alpha(A,B') F(h) g  = 
		\alpha(A,B') F(h)_* g =
		\alpha(A,B')\Mor_\B\Big((F(A),F(A')),(B',B'))(h)(g) = \NewLine =
		\Mor_\A\Big((A,A), (G(B'),G(B'))\Big)(h \times \id)\alpha(A',B')(g) =
		h \alpha(A',B')(g)
	}
} \Page{
	\Conclude{()}{\bd \TYPE{Bijection}\alpha(A,B')(1)(2)}{    fk = F(h) g \iff \alpha(A,B)(f)G(k) = h \alpha(A',B')(g)    }
	\Derive{(2)}{I(\Rightarrow)I(\forall)}{\LOGIC{Left} \Rightarrow \LOGIC{Right}}
	\Assume{R}{\LOGIC{Right}}
	\Assume{B}{\B}
	\Assume{A,A'}{\A }
	\Assume{ h}{ A \Arrow{\A^\op} A'}
	\Assume{z}{F(A) \to B}
	\Say{k}{{\id}_B}{B \Arrow{\B} B}
	\Say{f}{ F(h)z}{ F(A') \Arrow{\B} B   }
	\Say{g}{z}{F(A) \Arrow{\B} B}
	\Say{(3)}{\bd F(h)g \bd fk}{fk = F(h)g}
	\Conclude{()}{R(3)}{ h\alpha(A,B)(z)  =  h\alpha(A,B)(g)  = \alpha(A',B)(g)G(k)  = \alpha(A',B)(F(h)z)   }    
	\Derive{(3)}{ I(\forall)\bd^{-1}\NT    }
	{  \forall B \in \B \.  \alpha(\cdot,B) : \Mor_\B(F(\cdot),B) \iff \Mor_\A(\cdot,G(B))    }
	\Assume{A}{\A}
	\Assume{B,B'}{\B }
	\Assume{ k }{ B \Arrow{\A^\op} B'}
	\Assume{z}{F(A) \to B}
	\Say{h}{{\id}_A}{A \Arrow{\A} A}
	\Say{f}{ F(h)z}{ F(A) \Arrow{\B} B   }
	\Say{g}{zk}{F(A) \Arrow{\B} B'}
	\Say{(4)}{\bd F(h)g \bd fk}{fk = F(h)g}
	\Conclude{()}{R(3)}{ \alpha(A,B)(z)G(k)  =  h\alpha(A,B)(g)  = \alpha(A',B)(g)G(k)  = \alpha(A',B)(zk)   }    
	\Derive{(4)}{ I(\forall)\bd^{-1}\NT  }
	{  \forall A \in \A \.  \alpha(A,\cdot) : \Mor_\B(F(A),\cdot) \iff \Mor_\A(A,G(\cdot))    }
	\Conclude{()}{\bd^{-1} \TYPE{Adjoint}(3,4)}{(F \dashv G,\alpha)}
	\DeriveConclude{(*)}{I(\Leftarrow)I(\iff)}{\LOGIC{This}}
	\EndProof
	\\
	\Theorem{AdjointTriple}{\forall \A,\B \in \CAT \. \forall R,S : \A \Arrow{\CAT} \B \. 
		\forall U : \B \Arrow{\CAT} \A \. R \dashv U \dashv S  \Rightarrow  RU \dashv SU  }
	\Say{ \alpha }{\bd R \dashv U}{\prod A \in \A \. \prod B \in \B \. \Mor_\B(R(A),B) \ToBij \Mor_\A(A,U(B))}
	\Say{\beta }{ \bd  U \dashv S }{ \prod B \in \B \. \prod A \in \A \. \Mor_\A(U(B),A) \ToBij \Mor_\B( B, S(A)  ) }
	\Assume{X,Y}{ \A }
	\Conclude{\omega(X,Y)}{ \beta(R(X),Y) \alpha(X,S(Y))  }{\Mor_\A(RU(X),Y) \ToBij \Mor_\B(X,SU(Y))}
	\Derive{\omega}{I\left(\prod\right)}{\prod X \in \A \. \prod Y \in \B \. \Mor_\A(RU(X),Y) \ToBij \Mor_\B(X,SU(Y))}
	\Conclude{(*)}{\bd \omega \bd R \dashv U \bd S \dashv U}{RU \dashv SU}
	\EndProof
} \Page{
	\Theorem{CommaIsomorphismByAdjunction}{ 
			\forall \A,\B \in \CAT \. \forall (F,G) : \TYPE{Asjoint}(\A,\B)  \.  \NewLine \.
			\exists T :  F \downarrow {\id}_\B \ToIso{\CAT}  {\id}_\A \downarrow G : \Pi_1 = T\Pi_2
			\NewLine \where \NewLine 
			\Pi_1 =  (\Lambda (X,Y,f) \in F \downarrow {\id}_\B \. (X,Y), \id)    \NewLine
			\Pi_2 = (\Lambda (X,Y.f) \in {\id}_\A \downarrow G \. (X,Y), \id)
		}
	\Say{T}{\Lambda (X,Y,f) \in F \downarrow {\id}_\B \. (X,Y,f^\top)}{ F \downarrow {\id}_\B \ToBij 
		{\id}_\A  \downarrow G }
	\Conclude{(*)}{\THM{AdjointFunctorsChar}\bd T}{ \Big[ T : F \downarrow {\id}_\B \ToIso{\CAT} {\id}_\A \downarrow G \Big]  }
	\EndProof
}
\newpage
\subsection{Category of Fractions[!]}
\Page{	
	\Conclude{\TYPE{Quiver}}{\sum A,B : \Class \. \sum O : A \. O \times O \to B}{\Type}
	\\
	\DeclareFunc{implicit}{\CAT \to \TYPE{Quiver}}
	\DefineFunc{implicit}{\C}{ (\Obj_\C,\Mor_\C) }
	\\
	\DeclareType{Cogrounded}{?(\mathsf{LSCAT} \times \mathsf{LSCAT})}
	\DefineType{(\A,\B)}{Cogrounded}{ \Obj_\A = \Obj_\B  }
	\\
	\DeclareFunc{catUnion}{\TYPE{Cogrounded} \to \TYPE{Quiver}}
	\DefineNamedFunc{catUnion}{\A,\B}{\A \cup \B}
	{\Big(\Obj_\A, \Lambda A,B \in \Obj_\A \. \Mor_\A(A,B ) \cup\Mor_\B(A,B) \Big)}
	\\
	\DeclareType{Chain}{\prod (O,M) : \TYPE{Quiver} \. \prod A,B \in O \. 
		?\sum n \in \Nat \. n \to \sum X,Y \in O \. M(X,Y) }
	\DefineType{(l,(X,Y,f))}{Chain}{X_1 = A \And Y_l = B \And \forall i \in (l-1) \. Y_i = X_{i+1}}
	\\
	\Conclude{\TYPE{Pseudochain}}{ \Lambda (O,M) : \TYPE{Quiver} \. \Lambda A, B \in O \.
		 \NewLine
		 \If A == B \Then \TYPE{Chain}((O.M),A,A) | [ \text{empty} ]_{\mathrm{atom}} \Else \TYPE{Chain}((O,M),A,B)}
		 { \NewLine : \prod (O,M) : \TYPE{Quiver} \. O^2 \to \Type }
	\\
	\DeclareFunc{categoryOfFractions}{\mathsf{LSCAT} \to \mathsf{LSGROUPOID}}
	\DefineFunc{categoryOfFractions}{\C}
	{ 
		\Bigg(   \Obj_\C, \Lambda A,B \in \C \. \frac{ \Mor_{\C_+}(A,B) }{R(A,B)}, 
			\Big([\alpha], [\beta]\Big) \mapsto [\alpha\beta] , A \mapsto [({\id}_{A})^1_{i=1}]
		\Bigg) \NewLine \where \NewLine 
		\C_+ = \Big( \Obj_\C, \TYPE{Chain}(\C \cup \C^\op,A,B), 
			(a,b) \mapsto a \oplus b, A \mapsto ({\id}_A) \Big) \NewLine
		R(A,B) = \FUNC{eqclosure}(C_1(A,B) \cup C_2(A,B) \cup O_1(A,B) \cup O_2(A,B) \cup I(A,B)) \NewLine
		C_1(A,B) = \Big\{ \big(\alpha (X,Y,f)(Y,Z,g) \beta, \alpha(X,Z,fg)\beta\big) \big| X,Y,Z \in \C, 
			f : X \Arrow{\C} Y, g : G \Arrow{\C} Z, \NewLine \quad, 
			\alpha : \TYPE{Pseudochain}(\C \cup \C^\op,A,X), \beta : \TYPE{Pesudochain}(\C \cup \C^\op, Z, B) \Big\}
		\NewLine
		C_2(A,B) = \Big\{ \big(\alpha (X,Y,f^\op)(Y,Z,g^\op) \beta, \alpha(X,Z,(gf)^\op)\beta\big) \Big| X,Y,Z \in \C, 
			f : X \Arrow{\C} Y, g : G \Arrow{\C} Z, \NewLine \quad, 
			\alpha : \TYPE{Pseudochain}(\C \cup \C^\op,A,X), \beta : \TYPE{Pesudochain}(\C \cup \C^\op, Z, B) \Big\}
		\NewLine
		O_1(A,B) = \Big\{ \big(\alpha (X,Y,f)(Y,X,f^\op) \beta, \alpha(X,X,{\id}_X)\beta\big) \Big| X,Y \in \C, 
			f : X \Arrow{\C} Y  \NewLine \quad, 
			\alpha : \TYPE{Pseudochain}(\C \cup \C^\op,A,X), \beta : \TYPE{Pesudochain}(\C \cup \C^\op, X, B) \Big\}
		\NewLine
		O_2(A,B) = \Big\{ \big(\alpha (X,Y,f^\op)(Y,X,f) \beta, \alpha(X,X,{\id}_X)\beta\big) \Big| X,Y \in \C, 
			f : X \Arrow{\C} Y   \NewLine \quad, 
			\alpha : \TYPE{Pseudochain}(\C \cup \C^\op,A,X), \beta : \TYPE{Pseudochain}(\C \cup \C^\op, X, B) \Big\}
		\NewLine
		I(A,B) = \Big\{ \big(\alpha (X,Y,f^{-1}) \beta, \alpha (X,Y,f^\op) \beta\big)  \Big| X,Y \in \C, \NewLine \quad, 
			 \alpha : \TYPE{Pseudochain}(\C \cup \C^\op,A,X), \beta : \TYPE{Pseudochain}(\C \cup \C^\op,Y,B)  \Big\}
	}
} \Page{
	\DeclareFunc{fracCatFunctor}{\mathsf{LSCAT} \Arrow{\CAT} \mathsf{LSGroupoid}}
	\DefineNamedFunc{fracCatFunctor}{\C}{\mathrm{Frac}(\C)}{\FUNC{categoryOfFractions}(\C)}
	\DefineNamedFunc{fracCatFunctor}{\A,\B,F}{\mathrm{Frac}_{\A,\B}(F)}
	{ \NewLine \de \bigg(\Lambda A \in \mathrm{Frac}(\A) \. F(A), 
		\Lambda [f_i]^n_{i=1} :X \Arrow{\mathrm{Frac}(\A)} \mathrm{Frac}(\B) \. \Big[ F(f_i) \Big]^n_{i=1}\bigg)}
	\\
	\Theorem{GroupoidEmbeddingAjoint}{\mathrm{MG} \dashv \mathrm{E} \dashv \mathrm{Frac}}
	\NoProof
}
\newpage
\subsection{Unit and Counit}
\Page{
	\DeclareFunc{unit}{ \prod (F,G) : \TYPE{Adjoint}(\A,\B) \. \prod A \in \A \. A \Arrow{\A} FG(A)}
	\DefineNamedFunc{unit}{}{\eta_A^{F,G}}{{\id}^\top_{F(A)}}
	\\
	\Theorem{UnitIsNatural}{\forall (F,G) : \TYPE{Adjoint}(\A,\B) \. \eta^{F,G} : {\id}_\A \Rightarrow FG}
	\Assume{X,Y}{\A}
	\Assume{f}{X \Rightarrow{\A} Y}
	\Say{(1)}{I(=)F(f)}{F(f) = F(f)}
	\Conclude{()}{\THM{AdjointFunctorChar}(F,G)(\id,\id,F(f),F(f))(1)}
	{  	\eta_X FG(f)  =  f \eta_Y
	}
	\DeriveConclude{(*)}{\bd^{-1} \NT}{ \eta^{F,G} : {\id}_\A \Rightarrow FG}
	\EndProof
	\\
	\DeclareFunc{counit}{ \prod (F,G) : \TYPE{Adjoint}(\A,\B) \. \prod B \in \B \. GF(B) \Arrow{\A} B}
	\DefineNamedFunc{counit}{}{\epsilon_B^{F,G}}{{\id}^\bot_{G(B)}}
	\\
	\Theorem{CounitIsNatural}{\forall (F,G) : \TYPE{Adjoint}(\A,\B) \. \epsilon^{F,G} : GF \Rightarrow {\id}_\B}
	\Assume{X,Y}{\B}
	\Assume{f}{X \Rightarrow{\A} Y}
	\Say{(1)}{I(=)G(f)}{G(f) = G(f)}
	\Conclude{()}{\THM{AdjointFunctorChar}(F,G)(\id,\id,G(f),G(f))(1)}
	{  	\epsilon_X f  =  FG(f) \epsilon_Y
	}
	\DeriveConclude{(*)}{\bd^{-1} \NT}{ \epsilon^{F,G} : GF \Rightarrow {\id}_\B}
	\EndProof
	\\
	\DeclareType{TriangleId}{\prod F : \A \Arrow{\C} \B \. \prod G : \B \Arrow{\C} \A \. 
		?({\id}_\A \Rightarrow  FG \times GF \Rightarrow {\id}_\B)  }
	\DefineType{(\alpha,\beta)}{TriangleId}
	{F(\alpha(\cdot)) \beta(F(\cdot)) = {\id}_F \And   \alpha( G(\cdot))G(\beta(\cdot))  = {\id}_G}
}
\newpage
\Page{
	\Theorem{AdjointFunctorsChar2}
	{\forall F : \A \Arrow{\C} \B \. \forall G : \B \Arrow{\C} \A \. F \dashv G \iff \exists \TYPE{TriangleId}(F,G)}
	\Assume{(1)}{F \dashv G}
	\Assume{A}{\A}
	\Assume{B}{\B}
	\Say{()_1}{  \bd \eta(A) \bd \epsilon(F(A))\bd \NT(\FUNC{antitranspose}) (1)  }{
		\NewLine :
		F(\eta(A))\epsilon(F(A)) = 
		F\Big({\id}_{F(A)}^\top\Big){\id}_{FG(A)}^\bot =
		\Big(   {\id}_{F(A)}^\top \Big)^\bot = 
		{\id}_{F(A)}
	}
	\Conclude{()_2}{\bd \eta(A) \bd \epsilon(F(A)) \bd \NT (\FUNC{transpose})(1)}{   
		\NewLine :
		\eta(G(B))G(\epsilon(B)) =   
		{\id}_{GF(B)}^\top G( {\id}_{G(B)}^\bot) =
		\Big(  {\id}_{G(B)}^\bot \Big)^\top = 
		{\id}_{G(B)}
	}
	\DeriveConclude{()}{\bd^{-1} \TYPE{TriangleId}}{ \Big[  (\eta,\epsilon) : \TYPE{TriangleId}(F,G) \Big]    }
	\Derive{(1)}{I(\Rightarrow)}{\LOGIC{Left} \Rightarrow \LOGIC{Right}}
	\Assume{(\mu,\nu)}{\TYPE{TriangleId}(F,G)}
	\Assume{A}{\A}
	\Assume{B}{\B}
	\Assume{f}{F(A) \Arrow{\B} B}
	\Assume{g}{A \Arrow{\A} G(B)}
	\Say{\alpha(A,B)(f)}{  \mu(A)G(f) }{ A \Arrow{\A} G(B) }
	\Say{ \beta(A,B)(g)}{  F(g)\nu(B) }{ F(A) \Arrow{\B} B    }
	\Say{()_1}{ \bd \Cov(F) \bd \NT \nu \bd \TYPE{Triangleid}(\mu,\nu)}{  
			F\Big(\mu(A)G(f)\Big) \nu(B)  =
			F(\mu(A))GF(f) \nu(B) =
			F(\mu(A))\nu(F(A))f =
			f
		}
	\Conclude{()_2}{ \bd \Cov(G) \bd \NT \mu \bd \TYPE{TriangleId}(\mu,\nu)}{  
			\mu(A)G\Big(  F(g)\nu(B) \Big) =
			\mu(A) FG(g)F(\nu(B)) =
			g \mu(F(A))F(\nu(B)) =
			g
		}
	\Derive{\alpha }{I\left(\prod\right) }{ \prod A \in \A \. \prod B \in \B \. \Mor_{\B}(F(A),B) \ToBij \Mor_{\A}(A,G(B))}
	\Assume{A,A'}{\A}
	\Assume{B,B'}{\B}
	\Assume{f}{F(A) \Arrow{\B} B}
	\Assume{g}{F(A') \Arrow{\B} B'}
	\Assume{h}{A \Arrow{\A} A'}
	\Assume{k}{B \Arrow{\B} B'}
	\Say{(2)}{\bd\Cov(G)\bd^{-1} \alpha }{\NewLine : \mu(A)G(fk) = \mu(A)G(f)G(k) = \alpha(A,B)(f)G(k)}
	\Say{(3)}{ \bd \Cov(G) \bd \NT \mu \bd^{-1} \alpha  }
	{  \NewLine : \mu(A)G(F(h)g) =   \mu(A)FG(h)G(g)   = h \mu(A')G(g) =  h \alpha(A',B')(g)   }
	\Say{(4)}{ F(2)\nu(B') \bd \Cov(F) \bd \NT (\nu) \bd \TYPE{TriangleId}(\mu,\nu)  }
	{  \NewLine : F\Big(\alpha(A,B)(f)G(k)\Big)\nu(B')  = F(\mu(A))GF(fk)\nu(B') = F(\mu(A))\nu(F(A))fk = fk}
	\Say{(5)}{F(3)\nu(B')\bd \Cov(F) \bd \NT \nu \bd \TYPE{TriangleId}(\mu,\nu)}
	{ 
		\NewLine :
		F\Big( h \alpha(A',B')(g) \Big) \nu(B') = 
		F\Big( \mu(A)G(F(h)g) \Big) \nu(B') =
		F\Big( \mu(A) \Big) GF(F(h)g) \nu(B') = \NewLine =
		F\Big( \mu(A) \Big) \nu(F(A)) F(h)g  =
		F(h)g
	}
}\Page{ 
	\Conclude{ () }{ \THM{MapEq}(2,3,4,5)   }{  fk = F(h)g \iff \alpha(A,B)(f)G(k) = h \alpha(A',B')(g)    }
	\DeriveConclude{()}{\THM{AdjointFunctorsChar}}{F \dashv G}
	\DeriveConclude{(*)}{I(\Leftarrow)I(\iff)}{\LOGIC{This}}
	\EndProof
	\\
	\DeclareFunc{unitalSubcategory}{\prod \C \in \mathsf{SCAT} \. 
		\prod F : \Endo_{\CAT}(\C) \.  (\id_{\C} \Rightarrow F) \to \CAT    }
	\DefineNamedFunc{unitalSubcategory}{ \alpha }{\C^\alpha}
	{   \Big( \{ X \in \Obj_\C(\C) : \alpha(X) : X \ToIso{\C} F(X) \}, \Mor_\C, \cdot_\C, \id_{\C}  \Big)}
	\\
	\Theorem{ EqSubcategoriesFromAdjunction }{ \forall (F,G) : \TYPE{Adjoint}(\A,\B) \.  \A^\eta \simeq \B^\epsilon }
	\Assume{A}{\A^\eta}
	\Say{(1)}{\THM{AdjointFunctorsChar2}(F,G)\bd \TYPE{TriangleId}(\nu,\epsilon)}{ F(\eta(A))\epsilon(F(A)) = {\id}_{F(A)} }
	\Say{(2)}{F(\eta^{-1}(A))(1)F(\eta)}{\epsilon(F(A))F(\eta(A)) =  {\id}_{F(A)} }
	\Conclude{()}{\bd^{-1} \TYPE{Inverse}(\epsilon(F(A)))(F(\eta(A)))(1)(2)}{F(A) \in \B^\epsilon}
	\Derive{(1)}{I(\forall)}{\forall A \in  \A^\eta \. F(A) \in \B^\epsilon }
	\Assume{B}{\B^\epsilon}
	\Say{(2)}{\THM{AdjointFunctorsChar2}(F,G)\bd \TYPE{TriangleId}(\nu,\epsilon)}{ \eta(G(B))G(\epsilon(B)) = {\id}_{F(A)} }
	\Say{(3)}{G(\epsilon^{-1}(A))(1)G(\epsilon)}{G(\epsilon(B))\eta(G(B)) =  {\id}_{F(A)} }
	\Conclude{()}{\bd^{-1} \TYPE{Inverse}(\eta(G(B)))(G(\epsilon(B)))(2)(3)}{G(B) \in \A^\eta}
	\Derive{(2)}{I(\forall)}{\forall B \in  \B^\epsilon \. G(B) \in \A^\eta }
	\Say{(3)}{\THM{AdjointFunctorsChar2}(F,G)\bd \A^\eta \bd \B^\epsilon}
	{ \eta_{|A^\eta} : {\id}_{\A^\eta} \iff  F_{|\A^\epsilon}G_{|\B^\epsilon}   }
	\Say{(4)}{\THM{AdjointFunctorsChar2}(F,G)\bd \B^\epsilon \bd \A^\eta}
	{ \epsilon_{|B^\epsilon} : G_{|\B^\epsilon}F_{\A^\eta}  \iff {\id}_{\B^\epsilon}  }
	\Conclude{(*)}{ \bd^{-1} \TYPE{CatEq}(3,4)  }{ \A^\eta \simeq \B^\epsilon}
	\EndProof
}
\newpage
\subsection{Morphisms of Adjunctions}
\Page{
	\DeclareType{ MorphismOfAdjoints }{ 
		\prod (F,G) : \TYPE{Adjoint}(\A,\B) \. \prod (F',G') : \TYPE{Adjoint}(\A',\B') \.  \NewLine \. 
		?( \A \Arrow{\CAT} \A' \times \B \Arrow{\CAT} \B'   )	
	}
	\DefineType{(H,K)}{MorphismOfAdjoints}{  \forall A \in \A \. \forall B \in \B \.  
		HG = G'K \And KF = F'H  \And \NewLine 
		\Big(K_{F(A),B}(\cdot) \Big)^\top =  H_{A,G(B)}\Big( \cdot \Big)^\top  }
	\\
	\Theorem{MorphismOfAdjointsChar1}{  
			\forall (F,G) : \TYPE{Adjoint}(\A,\B) \. 
			\forall (F',G') : \TYPE{Adjoint}(\A',\B') \. \NewLine \.
			\forall H : \A \Arrow{\CAT} \A' \.
			\forall K : \B \Arrow{\CAT} \B' \.
			\forall (0) : HG = G'K \And kF = F'H   \. \NewLine \.
			(H,K) : \TYPE{MorphismOfAdjoints}(\A,\B) \iff 
			H(\eta) = \eta'(H)  \NewLine
			\quad \where \NewLine
			\quad \quad \eta = \eta^{F,G} \NewLine 
			\quad \quad \eta' = \eta^{F',G'}
		}
	\Assume{(1)}{\Big[ (H,K) : \TYPE{MorphismOfAdjoint}\Big]}
	\Assume{A}{\A}
	\Conclude{()}{ \bd \eta(A) \bd \TYPE{MorphismOfAdjoint}(H,K)\bd \Cov(K) \bd \TYPE{MorphismOfAsjoints}(H,K)\bd^{-1}\eta'}{ 
			\NewLine :
			H\Big(\eta(A)\Big) = 
			H_{A,FG(A)}\Big( {\id}^{\top}_{F(A)} \Big) =
			\Big(   K_{F(A),F(A)}({\id}_{F(A)})\Big)^\top =
			{\id}^\top_{KF(A)} =
			{\id}^\top_{F'H(A)} = 
			\eta'(H(A))
		}
	\Derive{(1)}{I(\forall)I(\Rightarrow)}{ \LOGIC{Left} \Rightarrow \LOGIC{Right} }
	\Assume{(2)}{H\eta = \eta'H}
	\Assume{A}{\A}
	\Assume{B}{\B}
	\Assume{f}{F(A) \Arrow{\B} B}
	\Say{(3)}{I(=)(f)}{f = f}
	\Say{(4)}{\THM{AdjointFunctorsChar}(\id,f,\id,f)(3)}{\eta(A)G(f) = f^\top}
	\Say{(5)}{I(=)(K(f))}{K(f) = K(f)}
	\Say{(6)}{\THM{AdjointFunctorsChar}(\id,K(f),K(f),\id)}{\eta'(H(A))G'K(f) = (Kf)^\top}
	\Conclude{()}{ (6)(0)(2)\bd \Cov H (4)    }{  \NewLine :
			\Big( K_{F(A),B}(f)  \Big)^\top  = 
			\eta'(H(A))G'K(f) = 
			\eta'(H(A))HG(f)  =
			H(\eta(A))HG(f)   =
			H( \eta(A)G(f) )   =
			H( f^\top )
		}
	\DeriveConclude{(*)}{I(\iff)I(\Leftarrow)\bd^{-1} \TYPE{MorphismOfAdjunctions}}{\LOGIC{This}}
	\EndProof
	\\
	\Theorem{MorphismOfAdjointsChar2}{  
			\forall (F,G) : \TYPE{Adjoint}(\A,\B) \. 
			\forall (F',G') : \TYPE{Adjoint}(\A',\B') \. \NewLine \.
			\forall H : \A \Arrow{\CAT} \A' \.
			\forall K : \B \Arrow{\CAT} \B' \.
			\forall (0) : HG = G'K \And kF = F'H   \. \NewLine \.
			(H,K) : \TYPE{MorphismOfAdjoints}(\A,\B) \iff 
			K(\epsilon) = \epsilon'(K)  \NewLine
			\quad \where \NewLine
			\quad \quad \epsilon = \epsilon^{F,G} \NewLine 
			\quad \quad \epsilon' = \epsilon^{F',G'}
		}
	\NoProof
}
\newpage
\subsection{Contravariant Adjunctions}
\Page{
	\DeclareType{LeftAdjoint}{\prod \A,\B \in \mathsf{LSCAT} \. 
		?\Big( (\A^\op \Arrow{\CAT} \B) \times (\B^\op \Arrow{\CAT} \A)  \Big)  }
	\DefineType{(F,G)}{LeftAdjoint}{ 
		\exists \alpha : 
			\prod A \in \A \. 
			\prod B \in \B \. 
			\Mor_\B(F(A),B) \ToBij \Mor_\A(G(B),A) :  \NewLine : 
		\forall A \in \A \. 
			 \Lambda B \in \B \. 
			 \alpha(A,B) : \Mor_\B(F(A),\cdot) \Rightarrow \Mor_\A(G(\cdot),\cdot) 
		\And \NewLine \And
		\forall B \in \B \.
			\Lambda A \in \A \.
			\alpha(A,B) : \Mor_\B(F(\cdot),B) \Rightarrow \Mor_\A(G(B),\cdot)
	}
	\\
	\DeclareType{RightAdjoint}{\prod \A,\B \in \mathsf{LSCAT} 
		\. ?\Big( (\A^\op \Arrow{\CAT} \B) \times (\B^\op \Arrow{\CAT} \A)  \Big)  }
	\DefineType{(F,G)}{RightAdjoint}{ 
		\exists \alpha : 
			\prod A \in \A \. 
			\prod B \in \B \. 
			\Mor_\B(B,F(A)) \ToBij \Mor_\A(A,G(B)) :  \NewLine : 
		\forall A \in \A \. 
			 \Lambda B \in \B \. 
			 \alpha(A,B) : \Mor_\B(\cdot,F(A)) \Rightarrow \Mor_\A(A,G(\cdot)) 
		\And \NewLine \And
		\forall B \in \B \.
			\Lambda A \in \A \.
			\alpha(A,B) : \Mor_\B(B, F(\cdot)) \Rightarrow \Mor_\A(\cdot,G(B))
	}
	\\
	\DeclareFunc{transposeLeft}{
		\prod \A,\B \in \mathsf{LSCAT} \.
		\prod (F,G) : \TYPE{LeftAdjoint}(\A,\B)   \. 
		\prod A \in \A \.
		\prod B \in \B \. \NewLine \.
		\Mor_{\B}(F(A),B) \to \Mor_{\A}(G(B),A)
	}
	\DefineNamedFunc{transpose}{f}{f^{\top_{F,G}}}{\bd \TYPE{LeftAdjoint}(F,G)(f)}
	\\
	\DeclareFunc{antitransposeLeft}{
		\prod \A,\B \in \mathsf{LSCAT} \.
		\prod   (F,G) : \TYPE{LeftAdjoint}
		\prod A \in \A \.
		\prod B \in \B \.  \NewLine \.                     
		\Mor_{\A}(G(B).A) \to \Mor_{\B}(F(A),B)
	}
	\DefineNamedFunc{antitransposeLeft}{f}{f^{\bot_{F,G}}}{\bd \TYPE{LeftAdjoint}(F,G)(f)}
	\\
	\DeclareFunc{transposeRight}{
		\prod \A,\B \in \mathsf{LSCAT} \.
		\prod  (F,G) : \TYPE{RightAdjoint} \.
		\prod A \in \A \.
		\prod B \in \B \. \NewLine
		\Mor_{\B}(B, F(A)) \to \Mor_{\A}(A,G(B))
	}
	\DefineNamedFunc{transposeRight}{f}{f^{\top_{F,G}}}{\bd \TYPE{RightAdjoint}(F,G)(f)}
	\\
	\DeclareFunc{antitransposeRight}{
		\prod \A,\B \in \mathsf{LSCAT} \.
		\prod   (F,G) : \TYPE{RightAdjoint}  \. 
		\prod A \in \A \.
		\prod B \in \B \. \NewLine
		\Mor_{\A}(A,G(B)) \to \Mor_{\B}(B,F(A))
	}
	\DefineNamedFunc{antitransposeRight}{f}{f^{\bot_{F,G}}}{\bd \TYPE{RightAdjoint}(F,G)(f)}
	\\
	\Theorem{LeftAdjointFunctorsChar1}{
		\forall \A,\B \in \mathsf{LSCAT} \.
		\forall F  : \A^\op \Arrow{\CAT} \B \.
		\forall G : \B^\op \Arrow{\CAT} \A  \.
		\NewLine \forall \alpha : 
			\prod A \in \A \. 
			\prod B \in \B \. 
			(\Mor_\B(F(A),B) \ToBij \Mor_\A(G(B),A)) \.
		(F, G,\alpha) : \TYPE{LeftAdjoint} \iff \NewLine \iff:
		\Big(	\forall A,A' \in \A \.
			\forall B,B' \in \B \.
			\forall f : F(A') \Arrow{\B} B \.
			\forall g : F(A) \Arrow{\B} B' \.
			\forall h : A \Arrow{\A} A'  \.
			\forall k : B \Arrow{\B} B' \.  \NewLine \. 
				fk = F(h) g \iff G(k)\alpha(A',B)(f) =  \alpha(A,B')(g)h  
		\Big)
	}
	\NoProof
}\Page{
	\Theorem{RightAdjointFunctorsChar1}{
		\forall \A,\B \in \mathsf{LSCAT} \.
		\forall F  : \A^\op \Arrow{\CAT} \B \.
		\forall G : \B^\op \Arrow{\CAT} \A  \.
		\NewLine \forall \alpha : 
			\prod A \in \A \. 
			\prod B \in \B \. 
			(\Mor_\B(B,F(A)) \ToBij \Mor_\A(A,G(B))) \.
		(F, G,\alpha) : \TYPE{RightAdjoint} \iff \NewLine \iff:
		\Big(	\forall A,A' \in \A \.
			\forall B,B' \in \B \.
			\forall f : B \Arrow{\B} F(A') \.
			\forall g : B' \Arrow{\B} F(A) \.
			\forall h : A \Arrow{\A} A'  \.
			\forall k : B \Arrow{\B} B' \.  \NewLine \. 
				f F(h) =  kg \iff h\alpha(A',B)(f) =  \alpha(A,B')(g)G(k)  
		\Big)
	}
	\NoProof
	\\
	\DeclareFunc{counit1}{ \prod (F,G) : \TYPE{LeftAdjoint}(\A,\B) \.  GF \Rightarrow {\id}_\B}
	\DefineNamedFunc{counit1}{}{\epsilon_1^{F,G}}{{\id}^\bot_{G(B)}}
	\\
	\DeclareFunc{counit2}{ \prod (F,G) : \TYPE{Adjoint}(\A,\B) \.  \. FG  \Rightarrow {\id}_\A}
	\DefineNamedFunc{counit2}{}{\epsilon_2^{F,G}}{{\id}^\bot_{F(A)}}
	\\
	\DeclareFunc{unit1}{ \prod (F,G) : \TYPE{RightAdjoint}(\A,\B) \. \prod A \in \A \. {\id}_\A \Rightarrow FG}
	\DefineNamedFunc{unit1}{}{\eta_1^{F,G}}{{\id}^\top_{F(A)}}
	\\
	\DeclareFunc{unit2}{ \prod (F,G) : \TYPE{RightAdjoint}(\A,\B) \. {\id}_\B \Rightarrow GF}
	\DefineNamedFunc{unit2}{}{\eta^{F,G}_2}{{\id}^\top_{G(B)}}
	\\
	\DeclareType{LeftTriangleId}{ 
		\prod F : \A^\op \Arrow{\CAT} \B \. 
		\prod G : \B^\op \Arrow{\CAT} \A \. 
		?( GF \Rightarrow {\id}_\B \times FG \Rightarrow {\id}_\A )  
	}
	\DefineType{(\alpha,\beta)}{LeftTriangleId}{  F\alpha \beta F = {\id}_{F} \And   G \beta \alpha G = {\id}_G }
	\\
	\DeclareType{RightTriangleId}{ 
		\prod F : \A^\op \Arrow{\CAT} \B \. 
		\prod G : \B^\op \Arrow{\CAT} \A \. 
		?(  {\id}_\B \Rightarrow GF \times  {\id}_\A \Rightarrow  FG )  
	}
	\DefineType{(\alpha,\beta)}{LeftTriangleId}{  \beta F F \alpha  = {\id}_{F} \And \alpha G G \beta = { \id}_G  }
	\\
	\Theorem{LeftAdjointFunctorsChar2}
	{\forall F : \A^\op \Arrow{\C} \B \. \forall G : \B^\op \Arrow{\C} \A \. (F,G) : \TYPE{LeftAdjoint}(\A,\B) 
		\iff \NewLine \iff \exists \TYPE{LeftTriangleId}(F,G)}
	\NoProof
	\\
	\Theorem{RightAdjointFunctorsChar2}
	{\forall F : \A^\op \Arrow{\C} \B \. \forall G : \B^\op \Arrow{\C} \A \. (F,G) : \TYPE{RightAdjoint}(\A,\B) 
		\iff \NewLine \iff \exists \TYPE{RightTriangleId}(F,G)}
	\NoProof
}
\subsection{Extension to Adjoint Functor}
\Page{ 
	\Theorem{FunctorAdjointExtension}{ 
		\forall \A,\B \in \mathsf{LSCAT} \. 
		\forall F : \A \Arrow{\CAT} \B \. 
		\forall G : \B \to \A \. \NewLine \. 
		\forall \alpha : \prod A \in \A \. \prod B \in \B \. \Mor_{\B}(F(A),B) \ToBij \Mor_{\A}(A,G(B)) \. \NewLine \.
		\forall (0) : \forall B \in \B \. \Lambda A \in \A \. \alpha(A,B) : 
			\Mor_{\B}(F(\cdot),B) \iff \Mor_{\A}(\cdot,G(B)) \. \NewLine \.
		\exists! G^\star : \A \Arrow{\CAT} \B :
		 G^\star_1 = G \And 
		 \forall A \in \A \. \Lambda B \in \B \. \alpha(A,B) : \Mor(F(A),\cdot) \iff \Mor_{\A}(A,G(\cdot))
		}
		\Assume{B,B'}{\B}
		\Assume{f}{B \Arrow{\B} B'}
		\Say{(1)}{\bd f_*}{\Big[  f_* : \Mor_{\B}(F(\cdot),B) \Arrow{\SET^\A} \Mor_{\B}(F(\cdot),B') \Big]}
		\Say{\gamma(B')(f)}{ \alpha^{-1}(\cdot,B) f_* \alpha(\cdot,B')  }
		{ \Mor_{\A} ( \cdot, G(B)  ) \Arrow{\SET^\A} \Mor_\A( \cdot,G(B')) }
		\Conclude{G'_{B,B'}(f)}{\THM{ContravariantYonedaLemma}(\A)(G(B))(\gamma)}{ G(B) \Arrow{\C} G(B')   }
		\Derive{(G',1)}{ I\left(\prod \right)  }{
			\prod B,B' \in \B \. 
			\sum G_{B,B'} : (B \Arrow{\B} B') \to (G(B) \Arrow{\B} G(B') ) \. \NewLine \.
			\forall f : B \Arrow{B'} B' \.  G^{*}_{B,B',*}(f) =  \alpha^{-1}(B)(f_*)\alpha(B')
			}
		\Say{G^\star}{\Big(G,(G',(1)) \THM{PushforwardReflectsEquality})\Big)}{ \B \Arrow{\CAT} \A   }
		\Assume{A}{\A}
		\Assume{B,B'}{\B}
		\Assume{f}{B \Arrow{\B} B'}
		\Conclude{()}{\alpha(B)(1)(B,B',f)\bd \TYPE{Inverse}\alpha(B)}
		{  \alpha(B)G^\star_{B,B',*}(f) = \alpha(B)\alpha^{-1}(B)f_*\alpha(B') = f_*\alpha(B')}
		\Derive{(2)}{I(\forall)\bd^{-1}\NT}
		{\forall A \in \A \. \Lambda B \in \B \. \alpha(A,B) : \Mor(F(A),\cdot) \iff \Mor_{\A}(A,G(\cdot))}
		\Assume{H}{\B \Arrow{\CAT} \A}
		\Assume{(3)}{H_1 = G}
		\Assume{(4)}{\forall A \in \A \. \Lambda B \in \B \. \alpha(A,B) : \Mor(F(A),\cdot) \iff \Mor_{\A}(A,H(\cdot))}
		\Assume{B,B'}{\B}
		\Assume{f}{B \Arrow{\B} B'}
		\Say{(5)}{(2)\bd \NT(\alpha)(3) \bd \NT(\alpha)(4)}
		{\alpha(B)G^\star_{B,B',*}(f) = f_*\alpha(B) = \alpha(B)H_{B,B',*}(f)}
		\Conclude{()}{ \alpha^{-1}(B)(5) }{  G^\star_{B,B',*}(f) =  H_{B,B',*}(f) }
		\DeriveConclude{()}{I\left(=,\prod \right)}{G^\star = H}
		\DeriveConclude{(*)}{\bd^{-1} \TYPE{Unique}}{ \LOGIC{This}  }
		\EndProof
}
\newpage
\Page{
	\Theorem{MultivariableFunctorAdjointExtensionRight}{
		\forall \A, \B, \C \in \mathsf{LSCAT} \.
		\forall F : \A \times \B \Arrow{\CAT} \C \. \NewLine \.
		\forall G  : \prod A \in \A \. 
			\sum G_A :  \C \Arrow{\CAT} \B \.  
			F_A \dashv G_A \. \NewLine \.
		\exists!  G^\star : \A^\op \times \C \Arrow{\CAT} \B :
		\forall A \in \A \. \forall C \in \C \. G^\star(A,C) = G_A(C) \And \NewLine \And
		\exists \alpha : \prod A \in \A \. 
			\prod B \in \B \. 
			\prod C \in \C \.  
			\Mor_\C\big(F(A,B),C\big) \ToBij \Mor_\B\big(B,G^\star(A,C)\big) : \NewLine :
			\Big(	\forall A \in \A \. 
				\forall B \in \B \.
				\Lambda C \in \C  \. 
				\alpha(A,B,C) :  \Mor_{\C}\big( F(A,B),\cdot\big) \iff  \Mor_{\C}\big(B,G^\star(A,\cdot)\big)
			\Big) \And \NewLine \And
			\Big(	\forall C \in \C \.
				\forall B \in \B \.
				\Lambda A \in \A  \. 
				\alpha(A,B,C) :  \Mor_{\C}\big( F(\cdot,B),C\big) \iff  \Mor_{\C}\big(B,G^\star(\cdot,C)\big)
			\Big) \And \NewLine \And
			\Big(	\forall A \in \A \.
				\forall C \in \B \.
				\Lambda B \in \B  \. 
				\alpha(A,B,C) :  \Mor_{\C}\big( F(A,\cdot),C\big) \iff  \Mor_{\C}\big(\cdot,G^\star(A,C)\big)
			\Big) 
		}
		\Assume{A,A'}{\A}
		\Assume{C,C'}{\C}
		\Assume{f}{A' \Arrow{\A} A}
		\Assume{h}{C \Arrow{\C} C'}
		\Say{k}{h_*F_{A',A}^*(f \times \id)}{  \Mor_\C(F(A,\cdot),C) \Arrow{\SET^\B} \Mor_\C(F(A',\cdot),C') }
		\Say{\gamma}{ \Lambda B \in \B \.  \FUNC{antitranspose}(F_A,G_A,B,C) k \FUNC{transpose}(F_{A'},G_{A'},B,C')}
		{   \Mor(\cdot,G_A(C)) \Arrow{\SET^\B}  \Mor(\cdot,G_{A'}(C)) }
		\Conclude{G'_{(A,B),(A',B')}(f \times h)}{\THM{ControvariantYonedaLemma}(\B,G_A(C),\gamma)}
		{  G_A(C) \Arrow{\B} G_{A'}(C')  }
		\Derive{G'}{I\left( \prod \right)}{ \prod A,A' \in \A \. \prod C,C' \in \C \. 
			\Big( (A, C) \Arrow{\A^\op \times \C } (A',C') \Big) \to (G_A(C) \Arrow{\B} G_{A'}(C'))  }
		\Say{G^\star}{(G,G')}{ \A^\op \times \C \Arrow{\CAT} \B  }
		\NoProof
		\\
	\Theorem{MultivariableFunctorAdjointExtensionLeft}{
		\forall \A, \B, \C \in \mathsf{LSCAT} \.
		\forall F : \A \times \B \Arrow{\CAT} \C \. \NewLine \.
		\forall H  : \prod B \in \B \. 
			\sum H_B :  \C \Arrow{\CAT} \A \.  
			 F_B \dashv H_B \. \NewLine \.
		\exists!  H^\star : \B^\op \times \C \Arrow{\CAT} \B :
		\forall B \in \B \. \forall C \in \C \. H^\star(B,C) = H_B(C) \And \NewLine \And
			\alpha : \prod A \in \A \. 
			\prod B \in \B \. 
			\prod C \in \C \.  
			\Mor_\C\big(F(A,B),C\big) \ToBij \Mor_\B\big(A,H^\star(B,C)\big) : \NewLine :
			\Big(	\forall A \in \A \. 
				\forall B \in \B \.
				\Lambda C \in \C  \. 
				\alpha(A,B,C) :  \Mor_{\C}\big( F(A,B),\cdot\big) \iff  \Mor_{\C}\big(A,H^\star(B,\cdot)\big)
			\Big) \And \NewLine \And
			\Big(	\forall C \in \C \.
				\forall B \in \B \.
				\Lambda A \in \A  \. 
				\alpha(A,B,C) :  \Mor_{\C}\big( F(\cdot,B),C\big) \iff  \Mor_{\C}\big(\cdot,H^\star(B,C)\big)
			\Big) \And \NewLine \And
			\Big(	\forall A \in \A \.
				\forall C \in \B \.
				\Lambda B \in \B  \. 
				\alpha(A,B,C) :  \Mor_{\C}\big( F(A,\cdot),C\big) \iff  \Mor_{\C}\big(A,H^\star(\cdot,C)\big)
			\Big) 
		}
		\NoProof
} \newpage
\Page{
	\DeclareFunc{rightClosure1}{  
		\prod F : \A \times \B \Arrow{\mathsf{LSCAT}} \C \. 
		 \left( \prod A \in \A \. \sum G_A : \C \Arrow{\mathsf{LSCAT}} \B \. F_A \dashv G_A   \right)  \to \NewLine \to
		 \A^\op \times \C \Arrow{\CAT} \B
		}
	\DefineFunc{rightClosure1}{G}{\THM{MultivariableFunctorAdjointExtensionRight}(F,G)}
	\\
	\DeclareFunc{leftClosure1}{  
		\prod F : \A \times \B \Arrow{\mathsf{LSCAT}} \C \. 
		 \left( \prod B \in \B \. \sum G_B : \C \Arrow{\mathsf{LSCAT}} \A \. F_B \dashv G_B   \right)  \to \NewLine \to
		 \B^\op \times \C \Arrow{\CAT} \A
		}
	\DefineFunc{leftClosure1}{G}{\THM{MultivariableFunctorAjointExtensionRight}(F,G)}
	\\
	\Theorem{ClosuresRightAdjoint}{
			\forall \A, \B, \C \in \mathsf{LSCAT} \.
			\forall F : \A \times \B \Arrow{\CAT} \C \. \NewLine
			\forall g : \prod A \in \A \. g_A : \C \Arrow{\CAT} \B \. F_A \dashv g_A \. \NewLine
			\forall h : \prod B \in \B \. h_B : \C \Arrow{\CAT} \A \. F_B \dashv g_B \. \NewLine
			\forall C \in \C \. (G_C,H_C) : \TYPE{RightAdjoint} \NewLine \quad \where \NewLine
			 \quad \quad G = \FUNC{rightClosure1}(F,g) \NewLine
			 \quad \quad H = \FUNC{leftClosure1}(F,h)                                                        
			}
			& \text{Use composition of natural isomorphisms} \\
			\EndProof
}
\newpage
\subsection{Multivariable Adjunctions}
\Page{
	\DeclareType{Biadjoint}{ 
		\prod \A,\B,\C \in \mathsf{LSCAT} \. 
		?\Big( 
			(\A \times \B \Arrow{\CAT} \C) \times
			(\A^\op \times \C \Arrow{\CAT} \B) \times
			(\B^\op \times \C \Arrow{\CAT} \A)
		\Big)  
	}
	\DefineType{ (F,G,H) }{Biadjoint}{   
		\NewLine \iff \Bigg(  \exists
			\alpha : \prod A \in \A \. 
			\prod B \in \B \. 
			\prod C \in \C \.  
			\Mor_\C\big(F(A,B),C\big) \ToBij \Mor_\B\big(B,G(A,C)\big) : \NewLine :
			\Big(	\forall A \in \A \. 
				\forall B \in \B \.
				\Lambda C \in \C  \. 
				\alpha(A,B,C) :  \Mor_{\C}\big( F(A,B),\cdot\big) \iff  \Mor_{\C}\big(A,G(B,\cdot)\big)
			\Big) \And \NewLine \And
			\Big(	\forall C \in \C \.
				\forall B \in \B \.
				\Lambda A \in \A  \. 
				\alpha(A,B,C) :  \Mor_{\C}\big( F(\cdot,B),C\big) \iff  \Mor_{\C}\big(\cdot,G(B,C)\big)
			\Big) \And \NewLine \And
			\Big(	\forall A \in \A \.
				\forall C \in \B \.
				\Lambda B \in \B  \. 
				\alpha(A,B,C) :  \Mor_{\C}\big( F(A,\cdot),C\big) \iff  \Mor_{\C}\big(A,G(\cdot,C)\big)
			\Big) 
		\Bigg) \And \NewLine \And \Bigg(
			\exists \beta :
			\prod A \in \A \.
			\prod B \in \B \.
			\prod C \in \C \.
			\Mor_\B\big(B,G(A,C)\big) \ToBij \Mor_\A(A,H(B,C)) : \NewLine :
			\Big( \forall A \in \A \.
			      \forall B \in \B \.
			      \Lambda C \in \C \.
			      \alpha(A,B,C) : \Mor_{\C}\big(B, G(A,\cdot)\big) \iff \Mor_{\C}\big(A,H(B,\cdot)\big)
			\Big) \And \NewLine \And
			\Big( \forall C \in \C \.
			      \forall B \in \B \.
			      \Lambda A \in \A \.
			      \alpha(A,B,C) : \Mor_{\C}\big(B, G(\cdot,C)\big) \iff \Mor_{\C}\big(\cdot,H(B,C)\big)
			\Big) \And \NewLine \And
			\Big( \forall A \in \A \.
			      \forall C \in \C \.
			      \Lambda B \in \B \.
			      \alpha(A,B,C) : \Mor_{\C}\big(\cdot, G(A,C)\big) \iff \Mor_{\C}\big(A,H(\cdot,C)\big)
			\Big) \Bigg) 
	}
	\\
	\DeclareFunc{synecdoche}{\TYPE{Biadjoint}(\A,\B,\C) \to \A \times \B \Arrow{\CAT} \C }
	\DefineFunc{synecdoche}{F,G,H}{F}
	\\
	\DeclareFunc{leftClosure}{\TYPE{Biadjoint}(\A,\B,\C) \to \B^\op \times \C \Arrow{\CAT} \A}
	\DefineFunc{leftClosure}{F,G,H}{G}
	\\
	\DeclareFunc{rightClosure}{\TYPE{Bidjoint}(\A,\B,\C) \to \A^\op \times \C \Arrow{\CAT} \B}
	\DefineFunc{rightClosure}{F,G,H}{H}
	\\
	\DeclareType{Closed}{ \prod \C \in \mathsf{LSCAT} \. ?( \C \times \C \Arrow{\CAT} \C) }
	\DefineType{F}{Closed}{\exists (F,G,H) : \TYPE{Biadjoint}(\C,\C,\C) : G \cong H }
	\\
	\DeclareFunc{productBifunctor}{\prod \C : \TYPE{WithFiniteProducts} \. \C \times \C \Arrow{\CAT} \C}
	\DefineNamedFunc{productBifunctor}{A,B}{A \times B}{\bd \TYPE{WithFiniteProducts}(A,B)}
	\DefineNamedFunc{productBifunctor}{(A,B),(A',B'),(f,g)}{f \times g}{\bd \TYPE{Limit}(A' \times B')(\pi_1f,\pi_2g)}
	\\
	\DeclareType{CartesianClosed}{? (\mathsf{LSCAT} \And \TYPE{WithFiniteProducts})}
	\DefineType{\C}{CartesianClosed}{\FUNC{productBifunctor}(\C) : \TYPE{Closed}(\C)}
}
\newpage
\Page{
	\DeclareType{MultivariableAdjunction}{
		\prod I : \SET \. 
		\prod \mathcal{X} : I \to \mathsf{LSCAT} \.  
		\prod \mathcal{Y} \. \NewLine \. 
		?\left( \prod i \in \I \. 
			\TYPE{Biadjoint}\left( \mathcal{X}_i,\prod_{j \in \I : j \neq i }\mathcal{X}_j, \mathcal{Y} \right) 
		\right)	
	}
	\DefineType{F}{MultivariableAdjunction}{
		\forall i,j \in \I \. 
		F_i =_{\prod_{i \in \I} \mathsf{X}_j \Arrow{\CAT} \mathsf{Y}_j } F_j
	}
}
\newpage
\subsection{Calculus of Adjunction}
\Page{
	\Theorem{TwoLeftAdjointsAreIso}{ 
		\forall \A,\B \in \mathsf{LSCAT} \. 
		\forall F,F' : \A \Arrow{\CAT} \B \.
		\forall G : \B \Arrow{\CAT} \A  \.
		\forall (0) : F \dashv G \And F' \dashv G  \. 
		\NewLine \.  \exists \theta : F \iff F' :
		\eta G(\theta)  = \eta' \And  (\theta G) \epsilon' = \epsilon  \NewLine
		\quad \where \NewLine 
		\quad \quad    \eta' = \eta^{F',G} 
		\quad \eta = \eta^{F,G} 
		\quad \epsilon' = \epsilon^{F',G}  
		\quad \epsilon = \epsilon^{F,G} 
	}
	\Assume{A}{\A}
	\Say{\theta_A}{ \Big({\id}_{F(A)}^{\top_{F,G}}\Big)^{\bot_{F',G}}}{  F'(A) \Arrow{\B} F(A)   } 
	\Say{\theta'_A}{ \Big( {\id}_{F'(A)}^{\top_{F',G}}\Big)^{\bot_{F,G}} }{ F(A) \Arrow{\B} F'(A) }
	\Say{(1)}{ 
		\bd \theta_A \theta_{A}' 
		\THM{AdjointFunctorsChar2}(F,G)(F',G) 
		\bd \Cov(G)
		\bd \NT(\eta')
		\bd \TYPE{TriangleId}(\eta', \epsilon')
		\bd \NT(\eta)
		\bd \TYPE{TriangeId}(\eta,\epsilon)
	}
	{  
			\NewLine :
			(\theta_A \theta'_A)^{\top_{F',G}} = 
			\bigg(\Big({\id}_{F(A)}^{\top_{F,G}}\Big)^{\bot_{F',G}}
			\Big({\id}_{F'(A)}^{\top_{F',G}}\Big)^{\bot_{F,G}} \bigg)^{\top_{F',G}} =    
			\eta'_{A} G\Big(F'(\eta_A)\epsilon'_{F(A)} F(\eta'_A)\epsilon_{F'(A)} \Big)  = \NewLine = 
			\eta'_{A} F'G(\eta_A) G(\epsilon'_{F(A)}) FG(\eta'_A)G(\epsilon_{F'(A)}) = 
			\eta_{A} \eta'_{FG(A)} G(\epsilon'_{F(A)}) FG(\eta'_A)G(\epsilon_{F'(A)}) = 
			\eta_{A} FG(\eta'_A)G(\epsilon_{F'(A)}) = \NewLine =
			\eta'_A \eta_{F'G(A)} G(\epsilon_{F'(A)}) =
			\eta'_A
		}
	\Say{(2)}{(1)^{\bot_{F',G}}}{ \theta_A \theta'_{A} = \id }
	\Say{(3)}{ 
		\bd \theta'_A \theta_{A} 
		\THM{AdjointFunctorsChar2}(F,G)(F',G) 
		\bd \Cov(G)
		\bd \NT(\eta)
		\bd \TYPE{TriangleId}(\eta, \epsilon)
		\bd \NT(\eta')
		\bd \TYPE{TriangeId}(\eta',\epsilon')
	}
	{  
			\NewLine :
			(\theta_A' \theta_A)^{\top_{F,G}} = 
			\bigg(\Big({\id}_{F'(A)}^{\top_{F',G}}\Big)^{\bot_{F,G}}
			\Big({\id}_{F(A)}^{\top_{F,G}}\Big)^{\bot_{F',G}} \bigg)^{\top_{F,G}} =    
			\eta_{A} G\Big(F(\eta'_A)\epsilon_{F'(A)} F'(\eta_A)\epsilon'_{F(A)} \Big)  = \NewLine = 
			\eta_{A} FG(\eta'_A) G(\epsilon_{F'(A)}) F'G(\eta_A)G(\epsilon'_{F(A)}) = 
			\eta'_{A} \eta_{F'G(A)} G(\epsilon_{F'(A)}) F'G(\eta_A)G(\epsilon'_{F(A)}) = 
			\eta'_{A} F'G(\eta_A)G(\epsilon'_{F(A)}) = \NewLine =
			\eta_A \eta'_{FG(A)} G(\epsilon'_{F(A)}) =
			\eta_A
		}
	\Conclude{()}{(3)^{\bot_{F,G}}}{ \theta_A' \theta_{A} = \id }
	\Derive{\theta}{I\left( \prod \right)}{\prod A \in \A \. F(A) \ToIso{\B} F'(A)}
	\Assume{X,Y}{ \A }
	\Assume{f}{X \Arrow{\A} Y}
	\Conclude{()}{\bd \theta(Y) \bd \Cov(F) \bd \NT(\eta') \bd \Cov(F) \bd \NT(\epsilon) \bd^{-1} \theta}
	{ 
		\NewLine :
		F(f)\theta(Y) = 
		F(f)F(\eta'_Y)\epsilon_{F'(Y)} = 
		F(f\eta'_Y)\epsilon_{F'(Y)} =
		F(\eta'_X F'G(f) )\epsilon_{F'(Y)} = 
		F(\eta'_X)F'G F(f) \epsilon_{F'(Y)} = \NewLine =
		F(\eta'_X)\epsilon_{F'(X)} F'(f) =
		\theta(X)F'(f)
	}
	\Derive{(1)}{\bd^{-1} \NT}{ [\theta : F \iff F'] }
	\Assume{A}{\A}
	\Say{()_1}{ \bd \theta(A) \bd \Cov(G) \bd \NT(\eta) \bd \TYPE{TriangleId}(\eta,\epsilon)}
	{      
		\NewLine :
		\eta_AG(\theta(A)) = 
		\eta_A G( F(\eta'_A) \epsilon_{F'(A)}    ) = 
		\eta_A FG(\eta'_A) G(\epsilon_{F'(A)}) = 
		\eta'_A  \eta_{F'G(A)} G(\epsilon_{F'(A)}) = 
		\eta'_A            
	}
	\Conclude{()_2}{  \bd \theta(G(A))  \bd \Cov(F) \bd \NT(\epsilon) \bd \TYPE{TriangleId}    }
	{
		\NewLine :
		\theta(G(A))\epsilon'_A = 
		 F(\eta'_G(A)) \epsilon_{GF'(A)} \epsilon'_A = 
		 F(\eta'_G(A)) GF(\epsilon'_A) \epsilon_{A} =
		 \epsilon_A
	}
	\DeriveConclude{(*)}{I(=,\to)^2}{\LOGIC{This}}
	\EndProof	
}
\newpage
\Page{
	\Theorem{CompositionOfAdjoints}{ 
		\forall \A,\B,\C \in \mathsf{LSCAT} \.  
		\forall (F,G) : \TYPE{Adjoint}(\A,\B) \.
		\forall (F',G') : \TYPE{Adjoint}(\B,\C) \. \NewLine \.
		(FF',G'G) : \TYPE{Adjoint}(\A,\C)
	}
	\Say{ \eta' }{ \eta^{F',G'}   }{ {\id}_\B \Rightarrow F'G'  }
	\Say{ \eta  }{\eta^{F,G}}{  {\id}_\A \Rightarrow FG }
	\Say{ \epsilon' }{ \epsilon^{F',G'}  }{  G'F' \Rightarrow  {\id}_\C  }
	\Say{ \epsilon }{ \epsilon^{F,G} }{  GF \Rightarrow {\id}_\B   }
	\Say{ \bar \eta }{   \eta G \eta' F }{ {\id}_\A \Rightarrow  FF'G'G  }
	\Say{ \bar \epsilon }{  F' \epsilon G' \epsilon'  }{ G'GFF' \Rightarrow {\id}_\C  }
	\Assume{  A  }{ \A  }
	\Conclude{()}
	{
		\bd \bar \eta \bd \bar \epsilon 
		\bd \Cov( FF')
		\bd \Cov( F' )
		\bd \NT(\epsilon)
		\bd \Cov( F') \NewLine
		\bd \TYPE{TriangleId}^2(\eta,\epsilon)(\eta',\epsilon')
		\bd \Cov( F' ) \bd \TYPE{Identity}({\id}_{FF'A})
	}
	{   
		\NewLine  :
		FF'(\bar \eta_A)\bar \epsilon_{FF' A} = 	
		FF'( \eta_A G(\eta'_{FA})) F'(\epsilon_{FF'G'A}) \epsilon'_{FF'A}   =
		FF'(\eta_A) GFF'(\eta'_{FA}) F'(\epsilon_{FF'G'A}) \epsilon'_{FF'A} = \NewLine =
		FF'(\eta_A)F'\Big( GF(\eta'_{FA})\epsilon_{FF'G'A}\Big) \epsilon'_{FF'A} =
		FF'(\eta_A)F' ( \epsilon_{FA} \eta'_{FA} ) \epsilon'_{FF'A} = 
		F'\Big( F(\eta_A)\epsilon_{FA} \Big) F'(\eta_{FA})\epsilon'_{FF'A} = \NewLine =  
		F'({\id}_{F(A)}){\id}_{FF'A} = 
		{\id}_{FF'A} 
	}
	\Derive{(1)}{I(=,\to)}{ FF'(\eta) \bar \epsilon FF' = {\id}_{FF'} }
	\Assume{ C }{\C}
	\Conclude{()}
	{
		\bd \bar \eta \bd \bar \epsilon 
		\bd \Cov( G'G)
		\bd \Cov( G )
		\bd \NT(\eta')
		\bd \Cov( G ) \NewLine
		\bd \TYPE{TriangleId}^2(\eta,\epsilon)(\eta',\epsilon')
		\bd \Cov( G ) \bd \TYPE{Identity}({\id}_{GG'A})	
	}
	{
		\NewLine :
                \bar \eta_{G'GC} G'G(  \bar \epsilon_{C} ) =
		\eta_{G'GC}G(\eta'_{G'GFC}) G'G\Big(  F'(\epsilon_{G'C}) \epsilon'_{C} \Big) =
		\eta_{G'GC}G(\eta'_{G'GFC}) F'G'G(\epsilon_{G'C})G'G(\epsilon'_{C}) =  \NewLine =
		\eta_{G'GC}G(\eta'_{G'GFC} F'G'(\epsilon_{G'C}) )G'G(\epsilon'_{C}) =
		\eta_{G'GC}G( \epsilon_{G'C} \eta'_{G'C} ) G'G(\epsilon'_{C}) =
		\eta_{G'GC}G(\epsilon_{G'C}\eta'_{G'C})G\Big(\eta'_{GC}G'(\epsilon'_{C})\Big) = \NewLine =
		{\id}_{G'GC} G( {\id}_{G'C} )
	}
	\Derive{(2) }{\bd^{-1}\TYPE{TriangleId} }{\Big[ (\bar \eta, \bar \epsilon) : \TYPE{TriangleId}(\A,\B)  \Big] }
	\Conclude{(*)}{\THM{AdjointFunctorsChar2}(2)}{ FF' \dashv GG' }
	\EndProof
	\\
	\DeclareType{AdjointEquivalence}{?\TYPE{Adjoint}(\A,\B)}
	\DefineType{(F,G)}{AdjointEquivalence}{ \Big(\eta^{F,G} : {\id}_{\A} \iff FG\Big) 
		\And \Big(\epsilon^{F,G} : GF \iff {\id}_{\B}\Big)}
}
\Page{
	\Theorem{EveryEquivalenceIsAdjoint}{\forall \A,\B \in \mathsf{LSCAT} \. \forall (0) : \A \simeq \B \.   
		\exists \TYPE{AdjointEquivalence}(\A,\B)}
	\Say{(F,G,\eta,\epsilon)}{ \bd \TYPE{EqCat}(1) }
	{ \sum F : \TYPE{FullyFaithful}(\A, \B) \. \sum G : \TYPE{FullyFaithful}(\B,\A) \. \NewLine \. 
		({\id}_\A \iff FG) \times (GF \iff {\id}_\B) }
	\Say{\gamma}{ \eta G (G \epsilon)    }{    G  \iff G    }
	\Say{\epsilon'}{  (F\gamma^{-1}) \epsilon  }{ GF \iff  {\id}_\B }
	\Assume{B}{\B}
	\Conclude{()}{  \bd \epsilon' \bd \NT(\eta) \bd^{-1} \gamma \bd \TYPE{Inverse}       }
	{    
		\NewLine :
		\eta_{GB} G(\epsilon'_B) =  
		\eta_{GB} GF\gamma^{-1}_B G\epsilon_B =   
		\gamma^{-1}_B \eta_{GB} G \epsilon_B =
		\gamma^{-1}_B \gamma_B =
		{\id}_{GB}
	}
	\Derive{(1)}{ I(=,\to)I(\forall)   }{  \eta G G \epsilon = {\id}_{G}      }
	\Assume{A}{\A}
	\Say{(2)}{ \bd^2 \NT (\epsilon') \bd \NT(\eta)     }
	{   
		\NewLine :
		F(\eta_A)\epsilon'_{FA}F(\eta_A)\epsilon'_{FA}  = 
		F(\eta_A)FGF(\eta_A)\epsilon'_{FGFA}\epsilon'_{FA}  =
		F( \eta_A GF(\eta_A) ) GF \epsilon'_{FA} \epsilon'_{FA} = \NewLine = 
		F( \eta_A \eta_{FGA} ) GF \epsilon'_{FA} \epsilon'_{FA} = 
		F( \eta_A ) F(\eta_{FGA}) GF \epsilon'_{FA} \epsilon'_{FA} = 
		F(\eta_A)   \epsilon'_{FA}
	}
	\Say{(3)}{\bd^{-1} \TYPE{Idempotent}(2) }{ \Big[  F(\eta_A)\epsilon'_{FA} : \TYPE{Idempotent}(FA) \Big]   }
	\Conclude{()}{\THM{InvertibleIdempotentIsId}(3)}{  F(\eta_A)\epsilon'_{FA} = {\id}_{F(A)}   }
	\Derive{(2)}{\bd^{-1}\TYPE{TriangleId}(1)}{\Big[ (\eta,\epsilon') : \TYPE{TriangleId} \Big]}
	\Conclude{(*)}{\THM{AdjointFunctorsChar2}(2)}{  F \dashv G }
	\EndProof
	\\
	\Theorem{AdjointExponentiationI}{
		\forall \A,\B : \mathsf{LSCAT} \. 
		\forall (F,G) : \TYPE{Adjoint}(\A,\B) \.  
		\forall \I : \mathsf{SCAT} \.  \NewLine \. 
		(F_*, G_*) : \TYPE{Adjoint}(\A^\I,\B^\I)
	}
	\Say{\eta'}{  \Lambda H \in \A^\I \.  \eta H  }{  \prod H \in \A^\I \. H \Rightarrow HFG }
	\Say{\epsilon'}{ \Lambda H \in \B^\I \. \epsilon H }{ \prod H \in \A^\I  \. HGF \Rightarrow H }
	\Assume{X,Y}{\A^\I}
	\Assume{\alpha}{X \Rightarrow Y}
	\Conclude{ ()  }{\bd \eta'_Y \bd \NT \eta \bd^{-1} \eta'_X}
	{  
		\alpha \eta'_Y = 
		\alpha \eta Y  =
		(\eta X) FG \alpha =
		\eta'_X FG \alpha 
	}
	\Derive{(1)}{\bd^{-1}\NT}{[ \eta' : {\id}_{\A^\I} \Rightarrow F_*G_*  ]}
	\Assume{X,Y}{\B^\I}
	\Assume{\alpha}{X \Rightarrow Y}
	\Conclude{ ()  }{\bd \epsilon'_Y \bd \NT \epsilon \bd^{-1} \epsilon'_X}
	{  
		GF\alpha \epsilon'_Y = 
		GF\alpha \epsilon Y  =
		(\epsilon X) \alpha =
		\epsilon'_X FG \alpha 
	}
	\Derive{(2)}{\bd^{-1}\NT}{[ \epsilon' :  G_*F_* \Rightarrow {\id_{\B}}  ]}
	\Assume{X}{\A^\I}
	\Conclude{()}{  \bd \eta'_X \bd \epsilon' \bd \TYPE{TriangleId}(\eta,\epsilon)}
	{ F_*(\eta'_X) \epsilon'_{F_*X}  = F\eta_X \epsilon_{XF} = {\id}_{F_*X}   }
	\Derive{(3)}{I(=,\to)}{ F_* \eta \epsilon F_* = {\id}_{F_*}   }
	\Assume{X}{\B^\I}
	\Conclude{()}{  \bd \eta'_X \bd \epsilon' \bd \TYPE{TriangleId}(\eta,\epsilon)}
	{ (\eta'_{G_*X}) G_*\epsilon'_{X}  = \eta_{XG} G\epsilon_{X} = {\id}_{G_*X}   }
	\Derive{(4)}{ \bd^{-1} \TYPE{TriangleId} }{  \Big[ (\eta',\epsilon') : \TYPE{TriangleId}(F_*,G_*)   \Big]    }
	\Conclude{(*)}{\THM{AdjointFunctorsChar2}(4)}{ F_* \dashv G_*  }
	\EndProof
} \Page{
	\Theorem{AdjointExponentiationII}{
		\forall \A,\B : \mathsf{LSCAT} \. 
		\forall (F,G) : \TYPE{Adjoint}(\A,\B) \.  
		\forall \C : \mathsf{LSCAT} \.  \NewLine \. 
		(F^*, G^*) : \TYPE{Adjoint}(\C^\B,\C^\A)     
	}
	\NoProof
}
\newpage
\subsection{Limits and Adjunctions}
\Page{
	\Theorem{WithLimitsByAdjuction}{  
			\forall \C \in \mathsf{LSCAT} \. 
			\forall \I \in \mathsf{SCAT} \. 
			\C : \TYPE{WithLimit}(\I) \iff \mathrm{Const}_\I \dashv \lim_{i \in \I}	
		   }
	\Assume{(1)}{ \C : \TYPE{WithLimit}(\I)  }
	\Assume{X}{\C}
	\Assume{F}{\I \Arrow{\CAT} \C}
	\Say{\lambda}{\FUNC{legs}(\lim_{i \in \I} F_i)}{\prod j \in \I \. \lim_{i \in \I} F_i \Arrow{\C} F_j   }
	\Assume{\alpha}{ \mathrm{Const}_\I(X) \Rightarrow F  }
	\Assume{i,j}{\I}
	\Assume{ f }{i \Arrow{\I} j}
	\Conclude{()}{\bd \NT \alpha }{  \alpha_i F_{i,j}(f)  = \alpha_j   }
	\Derive{(2)}{ \bd^{-1}\TYPE{Cone}  }{ (X,\alpha) : \TYPE{Cone}(F) }
	\Conclude{\tau_{X,F}(f)}{\bd \TYPE{Limit}(1)}{X \Arrow{\int_{\C} \mathrm{Cone}_F} \lim_{i \in \I} F_i}
	\Derive{\tau_{X,F}}{ I(\to)  }{\Big(\mathrm{Const}_\I(X) \Rightarrow F\Big) \to \Big(X \Arrow{\C} \lim_{i \in \I} F_i\Big)}
	\Assume{f}{X \Arrow{\C} \lim_{i \in \I} F_i }
	\Say{\sigma(f)}{f\lambda}{\prod j \in \I \. X \Arrow{\C} F_j  }
	\Assume{i,j}{\I}
	\Assume{ g }{ i \Arrow{\I} j} 
	\Conclude{()}{ \bd \sigma_{i}(f) \bd \TYPE{Cone}(\lim_{i \in \I} f_i, \lambda ) \bd^{-1} \sigma_j(f) }
	{ \sigma_{i}(f) F_{i,j}(g) = f \lambda_i F_{i,j}(g)  = f\lambda_j  = \sigma_j(f)   }
	\DeriveConclude{()}{\bd^{-1}\NT}{\Big[\sigma : \mathrm{Const}(X) \Rightarrow F \Big]}
	\Say{\sigma}{ I(\to) }{\Big( X \Arrow{\C} \lim_{i \in \I} F_i \Big) \to \Big(\mathrm{Const}_\I(X) \Rightarrow F \Big) }
	\Say{(2)}{ \bd \sigma \bd \int_{ \C} \mathrm{Cone}_F(x) \; \mathrm{d}x(\tau_{X,F}(\alpha)) \bd^{-1} {\id}_{\C^\I}}{
			\NewLine :
			\tau_{X,F}\sigma = 
			\Lambda \alpha : \mathrm{Const}_\I(X) \Rightarrow F \. \tau_{X,F}(\alpha)\lambda  = 
			\Lambda \alpha : \mathrm{Const}_\I(X) \Rightarrow F \. \alpha =
			{\id}_{ \mathrm{Const}_\I(X) \Rightarrow F}
		}
	\Say{(3)}{\bd \TYPE{Limit}(F) }{\sigma\tau_{X,F} = {\id}_{X \to \lim_{i \in \I} F_i}}
	\Conclude{()}{\bd^{-1}\TYPE{Inverse}(2)(3)}{\sigma = \tau^{-1}_{X,F}}
	\Derive{\tau}{I\left( \prod \right)}{ \prod X \in \C \. \prod F : \I \Arrow{\CAT} \C \. 
		\Big(\mathrm{Const}_\I(X) \Rightarrow F\Big) \ToBij \Big(X \Arrow{\C} \lim_{i \in \I} F_i\Big)}
	\Assume{F,G}{\mathrm{Const}_\I(X) \Rightarrow F}
	\Assume{X,Y}{\C}
	\Assume{f}{X \Arrow{\C} Y}
	\Assume{\beta}{F \Rightarrow G}
	\Say{()_1}{ \bd f^* \bd \TYPE{Limit}(F) \bd^{-1} f^*  }{  
		f^* \tau_{Y,F} = 
		\Lambda \alpha : \mathrm{Const}(X) \Rightarrow F \. \tau_{Y,F}(f\alpha)  =    
		\Lambda \alpha : \mathrm{Const}(X) \Rightarrow F \.  f\tau_{X,F}(\alpha)  = 
		\tau_{X,F} f^* 
		}
	\Conclude{()_2}{\bd \beta_* \bd \TYPE{Limit} \bd^{-1}\beta_*  }
	{
		\beta_* \tau_{X,G} = 
		\Lambda \alpha : \mathrm{Const}(X) \Rightarrow F \. \tau_{X,G}(\alpha\beta) =
		\Lambda   \alpha : \mathrm{Const}(X) \Rightarrow F \. \tau_{X,F}(\alpha)\lim_{i \in \I} \beta_i =
		\tau_{X,F} \beta_*
	}
	\Derive{(2)}{\bd^{-1} \NT}
	{ \tau : \Big(\mathrm{Const}_\I(X) \Rightarrow F\Big) \iff \Big(X \Arrow{\C} \lim_{i \in \I} F_i\Big)}
	\Conclude{(*)}{\bd^{-1}\TYPE{Adjoint}(\C,\C^\I)(\tau)}{\mathrm{Const}_\I \dashv \lim_{i \in \I}}
	\EndProof
}
\Page{
	\Theorem{ColimitsByAdjunction}{  
		\forall \C : \TYPE{LSCAT} \. 
		\forall \J : \TYPE{SCAT} \.                
		\C : \TYPE{WithLimits} \iff 
		\colim_{i \in \I} \dashv \mathrm{Const}_\I 
	}
	\NoProof
	\\
	\Theorem{RAPL}{   
		\forall \A,\B \in \mathsf{LSCAT} \. 
		\forall F : \A \Arrow{\CAT} \B \. 
		\forall G : \B \Arrow{\CAT} \A \. 
		\forall (0) :  G \dashv F \.
		F : \TYPE{PreservesLimits}
	}
	\Assume{(\I,X)}{\TYPE{Diagram}(\A)}
	\Assume{ (L,\lambda)   }{ \TYPE{Limit}(X) }
	\Assume{(C,\mu)}{\TYPE{Cone}(XF)} 
	\Say{(1)}{\bd \Cov(F) \bd^{-1} \TYPE{Cone}}{\Big[(GC,G\mu) : \TYPE{Cone}(XFG)\Big]}
	\Say{(2)}{ \bd^{-1} \TYPE{Cone} \bd^{-1} \epsilon }{  \Big[  (GC,G\mu\epsilon_{X}) : \TYPE{Cone}(X) \Big]   }
	\Say{(\psi,3)}{  \bd \TYPE{Limit}(L,\lambda)(2) }{
		\sum \psi : GC \Arrow{\A} L \. \forall i \in \I \.  \psi \lambda_i = G(\mu_i)\epsilon_{X_i}
	}
	\Say{ \phi}{   \eta_{C} F(\psi)   }{  C \Arrow{\B} FL  } 
	\Assume{i}{\I}
	\Conclude{()}{ \bd \phi \bd \Cov F (3) \bd \Cov G  \bd \NT(\eta) \bd \TYPE{TriangleId}(\epsilon, \eta) }
	{   
		\NewLine : 
		\phi F\lambda_i =  
		\eta_{C}  F(\psi)F(\lambda_i) =
		\eta_{C} F( \psi \lambda_i  ) = 
		\eta_{C} F(  G(\mu_i) \epsilon_{X_i} ) =
		\eta_{C} FG(\mu_i) F(\epsilon_{X_i}) =
		\mu_i \eta_{FX_i} F(\epsilon_{X_i}) = 
		\mu_i 
	}
	\Derive{  (4)  }{\bd^{-1} \int_{\B} \mathrm{Cone}_{FX}}{ \Big[ \phi : C \Arrow{\int_{\B} \mathrm{Cone}_{FX}} FL  \Big]  }
	\Assume{\phi'}{  C \Arrow{\int_{\B} \mathrm{Cone}_{FX}} FL  }
	\Say{(5)}{\bd \FUNC{antitranspose}}{  [\phi^\bot, (\phi')^\bot  : GC \Arrow{\A} L  ]  }
	\Assume{i}{\I}
	\Conclude{()}{  \bd \NT \FUNC{antitranspose} \bd \int_{\B} \mathrm {Cone} \bd \NT \FUNC{antitranspose} \bd^{-1} \epsilon }{ 
			\phi^\bot \lambda_i   =  
			(\phi F\lambda_i)^\bot =  
			(\mu_i)^\bot =
			G\mu_i({\id}_{FX_i})^{\bot} =
			G\mu_i\epsilon_{X_i}
		    }
	\Derive{(6)}{ \bd^{-1} \int_{\A} \mathrm{Cone}_{X_i} }
	{ \Big[\phi^\bot,(\phi')^\bot : GC \Arrow{\int_{\A} \mathrm{Cone}_{X}} L  \Big]  }
	\Say{(7)}{\bd \TYPE{Limit}(X)(L,\lambda)(6)}{ \phi^\bot = (\phi')^\bot  }
	\Conclude{()}{(7)^\top}{ \phi = \phi' }
	\DeriveConclude{()}{\bd^{-1} \TYPE{Limit}}{ \Big[  (FL,F\lambda) :  \TYPE{Limit}( FX  )  \Big]}
	\DeriveConclude{(*)}{\bd^{-1} \TYPE{PreservesLimits}}{ [F : \TYPE{PreservesLimits} ] }
	\EndProof
	\\
	\Theorem{LAPC}{      
		\forall \A,\B \in \mathsf{LSCAT} \.
		\forall F : \A \Arrow{\CAT} \B \. 
		\forall G : \B \Arrow{\CAT} \A \. 
		\forall (0)  : F \dashv G \.
		F : \TYPE{PreservesColimits}                                       
	}G
	\NoProof 
}
\newpage
\subsection{Reflective Subcategory}
\Page{
	\DeclareType{ReflectiveSubcat}{\prod \C \in \mathsf{LSCAT} \. ? \TYPE{FullSubcat}(\C)}
	\DefineType{ (\D,I)   }{ReflectiveSubcat}{ \exists L : \C \Arrow{\CAT} \D :  L \dashv I }
	\\
	\DeclareFunc{localization}{  \prod \D : \TYPE{ReflectiveSubcat} \.  \C \Arrow{\CAT} \D  }
	\DefineNamedFunc{localization}{    }{L_\D}{\bd \TYPE{ReflectiveSubcal} }
	\\
	\Theorem{RightAdjointEpimorphism}{ 
		\forall \A,\B \in \mathsf{LSCAT} \. 
		\forall (F,G) : \TYPE{Adjoint}(\A,\B) \. 
		\NewLine \.
			G : \TYPE{Faithfull}(\B,\A) \iff 
			\epsilon :  \prod B \in \B \. \TYPE{Epic}(GFB,B)
	}
	\Assume{ (1) }{[G : \TYPE{Faithful}(\B,\A)]}
	\Assume{B}{ \B }
	\Assume{Y}{\B}
	\Assume{f,g}{  B \Arrow{\B} Y   }
	\Assume{(2)}{\epsilon_B f = \epsilon_B g}
	\Say{(3)}{ \bd \epsilon_B \bd \NT \FUNC{transpose}  }
	{   
		(Gf)^\top   =  (\id_{GB})^\top f  = \epsilon_B f  =  \epsilon_B g =  (\id_{GB})^\top g  = ( Gg)^\top
	} 
	\Say{(4)}{ (3)^\bot }{  Gf =  Gg      }
	\Conclude{()}{\bd^{-1} \TYPE{Faithful}(G)(1)(4)}{f = g }
	\Derive{(1)}{I(\Rightarrow)}{  \LOGIC{Left} \Rightarrow \LOGIC{Right} }
	\Assume{(2)}{  \forall B \in \B \. \epsilon_B : \TYPE{Epic}(GFB,B) }
	\Assume{X,Y}{\B}
	\Assume{f,g}{X \Arrow{\B} Y} 
	\Assume{(3)}{Gf = Gg}
	\Say{(4)}{(3)^\top}{ (Gf)^\top = (Gg)^\top  }
	\Say{(5)}{  \bd^{-1} \epsilon_B \bd \NT \FUNC{transpose}(4) }{  \epsilon_B f = \epsilon_B g }
	\Conclude{(6)}{\bd \TYPE{Epic}(\epsilon_B)(5)}{   f = g  }
	\DeriveConclude{(*)}{I(\iff)(1)}{ \LOGIC{This} }
	\EndProof
} \Page{
	\Theorem{RightAdjointSplitMonomorphism}{ 
		\forall \A,\B \in \mathsf{LSCAT} \. 
		\forall (F,G) : \TYPE{Adjoint}(\A,\B) \. 
		\NewLine \.
			G : \TYPE{Full}(\B,\A) \iff 
			\epsilon :  \prod B \in \B \. \TYPE{SplitMonic}(GFB,B) 
	}
	\Assume{(1)}{[G : \TYPE{Full}(\B,\A)]}
	\Assume{B}{\B}
	\Say{\gamma}{ G^{-1}\eta_{GB}  }{ \Big[ B \mapsto GFB \Big]}
	\Conclude{()}{   \bd \epsilon_B \bd \NT \FUNC{transpose} \bd \eta_{GB} \bd \TYPE{Inverse}    }{  
			\NewLine : 
			\epsilon_B G^{-1}\eta_{GB}  = 
			({\id}_{GB})^\top G^{-1}\alpha_{GB}  =   
			(\alpha_{GB})^\top =
			{\id}_{GFB}
		     }
	\Derive{(1)}{I(\Rightarrow)}{\LOGIC{Left} \Rightarrow \LOGIC{Right}}
	\Assume{(2)}{\forall B \in \B \.  \epsilon_B : \TYPE{SplitMonic}(GFB,B)}
	\Assume{X,Y}{\B}
	\Assume{y}{GX \Arrow{\A} GY}
	\Say{x}{ \epsilon^{-1}_X y^{\bot}  }{X \Arrow{B} Y}
	\Say{(3)}{  \THM{AdjointFunctorsChar2}(F,G)(Gx) \bd \NT \epsilon \bd \TYPE{Retraction}(e_X)     }{      
			\NewLine :
			(Gx)^\bot =    
			FG\Big(\epsilon^{-1}_X y^{\bot}\Big) \epsilon_{Y} = 
			\epsilon_X \epsilon^{-1}_X  y^{\bot} = 
			y^\bot
		}
	\Conclude{(4)}{(3)^\top}{  Gx = y     }
	\DeriveConclude{()}{\bd^{-1} \TYPE{Surjective}}{\Big[ G_{X,Y} : (X \Arrow{\B} Y) \ToSurj (GX \Arrow{\A} GY)\Big]}
	\DeriveConclude{(*)}{I(\iff)(1)}{\LOGIC{This}}
	\EndProof
	\\
	\Theorem{RightAdjointIsomorphism}{ 
		\forall \A,\B \in \mathsf{LSCAT} \. 
		\forall (F,G) : \TYPE{Adjoint}(\A,\B) \. 
		\NewLine \.
			G : \TYPE{FullyFaithful}(\B,\A) \iff 
			\epsilon :  \prod B \in \B \. \TYPE{Iso}(GFB,B) 
	}
	\NoProof
	\\
	\Theorem{LeftAdjointMonomorphism}{ 
		\forall \A,\B \in \mathsf{LSCAT} \. 
		\forall (F,G) : \TYPE{Adjoint}(\A,\B) \. 
		\NewLine \.
			F : \TYPE{Faithful}(\B,\A) \iff 
			\epsilon :  \prod B \in \B \. \TYPE{Monic}(GFB,B) 
	}
	\NoProof
	\\
	\Theorem{LeftAdjointSolitEpimorphism}{ 
		\forall \A,\B \in \mathsf{LSCAT} \. 
		\forall (F,G) : \TYPE{Adjoint}(\A,\B) \. 
		\NewLine \.
			F : \TYPE{Full}(\B,\A) \iff 
			\epsilon :  \prod B \in \B \. \TYPE{SplitEpic}(GFB,B) 
	}
	\NoProof
} \Page{
	\Theorem{LeftAdjointIsomorphism}{ 
		\forall \A,\B \in \mathsf{LSCAT} \. 
		\forall (F,G) : \TYPE{Adjoint}(\A,\B) \. 
		\NewLine \.
			F : \TYPE{Faithful}(\B,\A) \iff 
			\epsilon :  \prod B \in \B \. \TYPE{Iso}(GFB,B) 
	}
	\NoProof
	\\
	\Theorem{ReflectiveInclusionCreatesLimits}{
		\forall \D : \TYPE{Reflective} \. I_\D : \TYPE{CreatesLimits}
		}
	G\Assume{(\I,X)}{\TYPE{Diagram}(\D)}
	\Assume{(Y,\lambda)}{\TYPE{Limit}(I_\D X)}
	\Say{(A,\mu)}{(L_\D Y, L_\D \lambda)}{ \sum A \in \D \.  \prod i \in \I \. A \Arrow{\D} X_i    }
	\Assume{i,j}{\I}
	\Assume{f}{i \Arrow{f} j}
	\Conclude{()}{  \bd \mu_i \bd \TYPE{Reflective} \bd \bd \TYPE{Cone}(Y,\lambda) \bd^{-1} \mu_j  }{
		\NewLine :
		\mu_i X_{i,j}(f) = 
		\Big(L_\D \lambda_i \Big) X_{i,j}(f)  = 
		L_\D\lambda_i I_\D L_\D X_{i,j}(f)   = 
		L_\D( \lambda_i I_\D X_{i,j}(f))  = 
		L_\D(\lambda_j) = \mu_j 
	}
	\Derive{(1)}{\bd^{-1} \TYPE{Cone}}{ \Big[ (A,\mu) : \TYPE{Cone}(\I,X)   \Big] }
	\Assume{(C,\alpha)}{\TYPE{Cone}(\I,X)}
	\Say{(2)}{ \bd^{-1} \TYPE{Cone} \bd \Cov(I_\D)\bd \TYPE{Cone}(C,\alpha)  }{ 
		\Big[ (I_\D C,I_\D \alpha) : \TYPE{Cone}(\I,I_\D\alpha) \Big]  }
	\Say{ \phi}{ \bd \TYPE{Limit}(Y,\lambda)}{    I_\D C \Arrow{\int \mathrm{Cone}_{I_\D X}} Y   }
	\Say{\psi}{ L_\D \phi  }{ C \Arrow{\D} A   }
	\Assume{i}{\I}
	\Conclude{()}{ \bd \psi \bd \mu_i \bd \Cov L_\D \bd  \phi \bd \TYPE{Reflective}(\D)}
	{ \psi \mu_i = L_D(\phi \lambda_i) = L_\D(  I_\D \alpha_i  ) = \alpha_i}
	\Derive{ (3) }{\bd^{-1} \int_\D \mathrm{Cone}_X(x) \; \mathrm{d}x}
	{ \Big[ \psi : C \Arrow{\int \mathrm{Cone}_X}  A \Big]  }
	\Assume{\psi'}{(C, \alpha) \Arrow{\int \mathrm{Cone}_X} (A,\mu)}
	\Say{(4)}{\bd  \Cov I_\D}    
	{ \Big[ I_\D \psi' : (I_\D C, I_\D \alpha) \Arrow{\int \mathrm{Cone}_{I_\D X}} (I_\D A, I_\D \mu_i  )  \Big] }
	\Say{\varphi}{\bd \TYPE{Limit}(Y,\lambda)}{ 
	\Big[ (I_\D A, I_\D \mu_i) \Arrow{\int \mathrm{Cone}_{I_\D X}} ( Y, \lambda ) \Big]  }
	\Say{\phi'}{I_\D \psi' \varphi}{  (I_\D C, I_\D \alpha) \Arrow{\int \mathrm{Cone}_{I_\D X}} (Y, \lambda) }
	\Say{(5)}{\bd \TYPE{Limit}(Y,\lambda)(\phi',\phi)}{ \phi = \phi'  \varphi}
	\Say{}{}{ (L_\D \varphi)^{\top} :  I_\D A   \Arrow{\C}  I_\D A    }
	\Conclude{()}{}
	{  
		\NewLine :
		\psi = L_\D \phi' = 
		I_\D L_\D \psi' L_\D \varphi = 
		\psi' L_\D \varphi = 
		\psi'    
	}
	\NoProof
	\\
	\Theorem{ReflectiveInclusionCreatesColimits}{
		\forall \D : \TYPE{Reflective} \. I_\D : \TYPE{CreatesColimits}
		}
	\NoProof
}
\newpage
\subsection{Existance of Adjoint Functors}
\Page{
	\Theorem{LeftAdjointExistsByComma}{  
		\forall \A,\B : \TYPE{LSCAT} \. 
		\forall U : \B \Arrow{\CAT} \A \.  \NewLine \. 
			\exists F : \A \Arrow{\CAT} \B :
			F \dashv U
		\iff
			\forall A \in \A \.
			 \exists  \TYPE{Initial}(\mathrm{Const}(A) \downarrow U )
	}
	\Assume{F}{\A \Arrow{\CAT} B}
	\Assume{(1)}{F \dashv U}
	\Assume{A}{\A}
	\Assume{(X,f)}{\mathrm{Const}(A) \downarrow U}
	\Say{(2)}{ \bd \mathrm{Const}(A) \downarrow U (X,f)}{ [ f : A \Arrow{\A} U(X)  ]   }
	\Say{(3)}{ \THM{AdjointFunctorsChar2}(F,U) \bd \TYPE{Inverse} }{   \eta_A U(f^\bot) = (f^\bot)^\top = f }
	\Say{(4)}{\bd^{-1} \bd \mathrm{Const}(A) \downarrow U}
	{ \Big[ f^\bot : (FA,\eta_A) \Arrow{\mathrm{Const}(A) \downarrow U  } (X,U)  \Big]  }
	\Assume{g}{  (FA, \eta_A) \Arrow{\mathrm{Const}(A) \downarrow U} (X,U) }
	\Say{ (5)   }{  \bd^\bot \mathrm{Const}(A)   }{  
		f = \eta_A Ug = g^\top	
	}
	\Conclude{()}{  (5)^\bot   }{ f^\bot = g }
	\DeriveConclude{ () }{ \bd^{-1} \TYPE{Initial} }{ (FA,\eta_A) : \TYPE{Initial}(\mathrm{Const}(A) \downarrow U )}
	\Derive{(1)}{I(\Rightarrow)}{ \LOGIC{Right} \Rightarrow \LOGIC{Left}}
	\Assume{(2)}{\forall A \in \A \. \exists  \TYPE{Initial}(\mathrm{Const}(A) \downarrow U) }
	\Assume{A}{ \A }
	\Say{(X,f)}{(2)(A)}{\TYPE{Initial}(\mathrm{Const}(A) \downarrow U)}
	\Conclude{F'(A)}{ X }{\B}
	\Assume{X,Y}{\A}
	\Assume{f}{X \Arrow{\A} Y}
	\Say{(F'(X),g)}{(2)(X)}{\TYPE{Initial}(\mathrm{Const}(X) \downarrow U)}
	\Say{(F'(Y),h)}{(2)(X)}{\TYPE{Initial}(\mathrm{Const}(Y) \downarrow U)}
	\Say{ (3) }{  (2)(X)    }{ (F'(Y),fh) \in  \mathrm{Const}(X) \downarrow U  }
	\Conclude{  F''(f) }{  \bd \TYPE{Initial}(F'(X),g))(3) }{  F'(X) \Arrow{\B} F'(Y) }
	\Derive{F''}{I\left( \prod \right)}{\prod X,Y \in \A \. (X \Arrow{\A} Y) \to (F'(X) \Arrow{\B} F'(Y))}
	\Say{F}{(F',F'')}{  \A \Arrow{\CAT} \B }
	\Assume{A}{\A}
	\Assume{B}{\B}
	\Assume{f}{ F(A) \Arrow{\B} B}
	\Say{(F(A),\eta_A)}{(2)(A)}{\TYPE{Initial}(\mathrm{Const}(A) \downarrow U)} 
	\Conclude{\tau(f)}{  \eta_A U(f)}{A \Arrow{\B} U(f)}
	\Derive{\tau}{I(\to)}{ \Mor_\B(F(\cdot),\cdot) \Rightarrow  \Mor_\A(\cdot, U(\cdot))  }
	\NoProof
}
\newpage
\Page{
	\DeclareType{SolutionSetCondition}{ \prod  \A,\B \in \CAT \. ?\TYPE{Continuous}(\A,\B)  }
	\DefineType{U}{SolutionSetCondition}{  
		\forall B \in \B \.  
		\exists 
			\sum I \in \SET  \.  
			\sum A : I \to \A \. \NewLine \.
			\sum f : \prod i \in I \. B \to UA_i \. 
			\forall X \in \A \. \forall \phi : B \Arrow{\B} UA \. \exists  i \in I :
			\exists \alpha_i : A_i \Arrow{\A} X :  \phi = f_i U\alpha_i
	}
	\\
	\DeclareType{JointlyWeaklyInitial}{\prod \C \in \CAT \. ?\sum I \in \SET \. I \to \C  }
	\DefineType{C}{JointlyWeaklyInitial}{\forall X \in \C \. \exists i \in I : \exists C_i \Arrow{\C} X}
	\\
	\Theorem{JWILemma}{
		\forall \C : \TYPE{Complete} \. 
		\forall (I,C) : \TYPE{JointlyWeaklyInitial}(\C)  \. 
		\exists \TYPE{Initial}(\C)	
	}
	\Say{\D}{\FUNC{fullSubcat}(\C,(I,C))}{\mathsf{SCAT}}
	\Say{(L,\lambda)}{\lim_{d \in \D} d}{\sum L \in \C \. \prod i \in \I \. L \Arrow{\C} C_i}
	\Assume{X}{\C}
	\Assume{(1)}{\exists i \in I \. X = C_i}
	\Conclude{f_X}{\lambda_i}{L \Arrow{\C} X}
	\Derive{(1)}{I(\If)}{\If X = C_i \Then f_X = \lambda_i}
	\Assume{(2)}{\forall i \in I \. X \neq C_i}
	\Say{(i,\phi)}{ \bd \TYPE{JointlyWeaklyInitial}(C)(X)  }{\sum i \in I \. C_i \Arrow{\C} X}
	\Conclude{f_X}{\lambda_i \phi}{ L \Arrow X}
	\Derive{f}{I\left(\prod\right)}{\prod X \in \C \. L \Arrow{\C} X }
	\Assume{X,Y}{\C}
	\Assume{g}{X \Arrow{\C} Y}
	\Say{(i,\phi_i)}{\bd \TYPE{JointlyWeaklyInitial}(C)(X)}{\sum i \in I \. C_i \Arrow{\C} X}
	\Say{(j,\phi_j)}{\bd \TYPE{JointlyWeaklyInitial}(C)(X)}{ \sum j \in I \. C_i \Arrow{\C} X}
	\Say{(P,\pi_i,\pi_j)}{\FUNC{pullback}(\phi_j,\phi_i g)}{\sum P \in \C \. (P \Arrow{\A} C_i) \times (P \Arrow{\A} C_j)}
	\Say{(k,\phi_k)  }{ \bd \TYPE{JointlyWeaklyInitial}(C)(P)}{ \sum k \in I \. C_k \Arrow{\C} X }
	\Conclude{()}{\bd f_X \bd \TYPE{Cone}(L,\lambda)(\phi_k\pi_i) \bd \TYPE{Pullback}(P,\pi_i,\pi_j)
		\bd \TYPE{Cone}(L,\lambda)(\phi_k\pi_j) \bd^{-1} f_Y
	}{
		\NewLine
		f_X g =   
		\lambda_i \phi_i g   = 
		\lambda_k \phi_k \pi_i \phi_i  g  =  
		\lambda_k \phi_k \pi_j \phi_j =
		\lambda_j \phi_j = 
		f_Y
		}
	\Derive{(1)}{\bd^{-1}\TYPE{Cone}}{\Big[ (L,f) : \TYPE{Cone}(\C,\id)  \Big]}
	\Say{(2)}{\bd \TYPE{Identity}(1)}{f_L = {\id_L}}
	\Assume{(K,\mu)}{\TYPE{Cone}(\C,\id)}
	\Say{(3)}{\bd (K,\mu)}{\mu_L : K \Arrow{\C} L}
	\Conclude{(4)}{ \bd (K,\mu)(2)(1)}{ \mu_L = \lambda_K^{-1}}
	\Say{(3)}{\bd^{-1} \TYPE{Limit}}{\Big[(L,\lambda) : \TYPE{Limit}(\C,\id)\Big]}
	\Conclude{(*)}{\THM{SelfLimitIsInitial}}{\Big[ L : \TYPE{Initial}(\C,\id) \Big] }
	\EndProof
}\Page{
	\Theorem{GeneralAdjointFunctorTheorem}{ 
			\forall \A \in  \mathsf{LSCAT} \.
			\forall \B : \mathsf{LSCAT} \And \TYPE{Complete} \. \NewLine 
			\. \forall U : \TYPE{SolutionSetCondition}(\B,\A) \.
			\exists F : \Cov(\A,\B) : F \dashv U
		}
    \Assume{A}{\A}
    \Say{(I,B,\phi,1)}{\bd \TYPE{SolutionSetCondition}}{
	    \NewLine :
	    \sum I \in \SET \. 
	    \sum B : I \to \B \. 
    	    \sum \phi : \prod i \in \I \. A \Arrow{\A} UB_i \. \NewLine \.
	    \forall X \in \B \. \forall f : A \Arrow{\A} UX \. 
	    \exists i \in I :
	    \exists \beta : B_i \Arrow{\B} B :
	    f = \phi_i U\beta
    }
    \Say{(2)}{\bd^{-1} \TYPE{JointlyWeaklyInitial}(1)}{
	    \Big[  \big(I,(B,\phi)\big) : \TYPE{JointlyWeaklyInitial}(\mathrm{Const}(A) \downarrow U)  \Big]}
    \Say{(3)}{\THM{ContinuousCommaComplete}(A,U) }{ \Big[ \mathrm{Const}(A) \downarrow  U : \TYPE{Complete} \Big]  }
    \Conclude{L}{\THM{JWILemma}(2,3)(I,(B,\phi))}{ \TYPE{Initial}(\mathrm{Const}(A) \downarrow U) }
    \Derive{(1)}{I(\forall)I(\exists)}{\forall A \in \A \. \exists \TYPE{Initial}(\mathrm{Const}(A) \downarrow U)}
    \Conclude{(*)}{\THM{LeftAdjointExistsByComma}}{\LOGIC{This}}
    \EndProof
    \\
    \DeclareType{GeneratingSet}
    {
	\prod \C \in \CAT \. 
	?\left(
	    	\sum I \in \SET \. 
		\sum  C : I \to \C \. 
		\prod X \in \C \. 
		\sum i \in I \. 
		C_i \Arrow{\C_i} X 
   	\right) 
   }
   \DefineType{(I,C,h)}{GeneratingSet}{ \forall X,Y \in \C \. \forall f,g : X \Arrow{\C} Y \. f \neq g \Rightarrow  
   	h_X f \neq h_X g}
   \\
   \Conclude{\TYPE{CogeneratingSet}(\C)}{\TYPE{GeneratingSet}(\C^\op)}{ \CAT \to \Type }
   \\
   \Conclude{\TYPE{Intersection}}{
	   	\prod \C : \CAT \.  
		\prod X \in \C \. 
		\prod J \in \SET \. 
		\prod (C,I) : J \to \TYPE{Subobject}(X) \. 
		\TYPE{Limit}(I)	
	}{\Type}
  	\\
  	\DeclareType{Intersectable}{? \TYPE{Complete}}
	\DefineType{\C}{Intersectable}{\forall X \in \C \. \exists J \in \Set : \exists (C,I) : 
  		J \to \TYPE{Subobject}(X) \. \forall (S,i) : \TYPE{Subobject}(X) \. 
		\NewLine \. \exists j \in J \. (C_j,I_j) \cong (S,i) }
	\\
	\Theorem{IntersectableLemma}{
		\forall \C : \TYPE{Intersectable} \And \mathsf{LSCAT} \. 
		\forall (I,C,h) : \TYPE{CogeneratingSet}(\C) \.
		\exists \TYPE{Initial}{\C}
	}
	\Say{P}{\prod_{i \in I} C_i}{\C}
	\Say{(J,S,\iota)}{\bd \TYPE{Intersectable}(J)}
	{ \sum J \in \SET \. \sum S : J \to \C \. \prod j \in J \. S  \ToMono{\C} P }
	\Say{T}{  \lim_{j \in J} (S,\iota_j) }{\C}
	\Assume{X}{\C}
	\Say{P'}{ \prod_{i \in \I} \prod_{f \in \Mor_\C(X,C_i)} C_i}{\C}
	\Say{\phi}{\prod_{i \in \I} \prod_{f \in \Mor_\C(X,C_i)} f }{ X \Arrow{\C} P'  }
	\Say{(1)}{\bd \phi \bd \TYPE{CogeneratingSet}(I,C,h)}{[\phi : X \ToMono{\C} P' ]} 
	\Say{\psi}{ \prod_{i \in \I} \prod_{f \in \Mor_\C(X,C_i)} \pi_i{\id}_{C_i}}{ P \Arrow P'}
}\Page{	
	\Say{(P'',\theta_1,\theta_2)}{\FUNC{pullback}(\phi,\psi)}
		{\sum P'' \in \C \. (P'' \Arrow{\C} P') \times (P'' \Arrow{\C} P)   }
	\Say{(2)}{ \bd \TYPE{Pullback}(P'')(1)  }{  \Big[   \theta_2 : X \ToMono{\C} P \Big]    }
	\Say{(3)}{\bd^{-1} \TYPE{Subobject}}{ \Big[ (P'',\theta^2) : \TYPE{Subobject}(P) \Big]   }
	\Say{\xi}{\bd T(3)}{ T \Arrow{\C} P''  }
	\Say{f}{\xi \theta_1}{T \Arrow{\C} X }
	\Assume{g}{T \Arrow{\C} X}
	\Assume{(4)}{f \neq g}
	\Say{(T',\nu)}{ \FUNC{coequalizer}(f,g )  }{ \sum T' \in \C \. T' \Arrow{\C} X }
	\Say{(5)}{\bd^{-1} \TYPE{Cone}}{ \Big[ (T',\nu\mu) : \TYPE{Cone}(S,\iota) \Big]  }
	\Say{(6)}{\bd T' (5)(4)}{T \IsNot \TYPE{Limit}(S,\iota)}
	\Conclude{()}{\bd T (6)}{\bot}
	\Derive{(*)}{\bd^{-1} \TYPE{Initial}}{\Big[ T : \TYPE{Initial}(\C) \Big]}
	\EndProof
	\\
	\Theorem{SpecialAdjointFunctorTHM}
	{
		\forall  \A : \mathsf{LSCAT} \.
		\forall  \B : \mathsf{LSCAT} \And \TYPE{Intersectable} \.
		\NewLine \.
		\forall  U : \TYPE{Continuous}(\B,\A) \.
		\forall  (I,C,h) : \TYPE{Cogenerating}(\B) \.
		\exists F : \Cov(\A,\B) \. 
		F \dashv U
	}
	\NoProof
	\\
	\Theorem{CocompletenesByCogenerating}
	{
		\forall  \C : \mathsf{LSCAT} \And \TYPE{Intersectable} \.
		\NewLine \.
		\forall  (I,C,h) : \TYPE{Cogenerating}(\C) \.
		\C : \TYPE{Cocomplete} \
	}
	\NoProof
} 
\newpage
\subsection{Locally Presentable Categories}
\Page{
	\Theorem{ContinuousIsRepresentable}
	{
		\forall \A : \mathsf{LSCAT} \And \TYPE{Intersectable} \.
		\forall F : \A \Arrow{\CAT} \SET \.
		\NewLine \.
		\forall (I,C,h) : \TYPE{Cogenerating}(\C) \.
		F : \TYPE{Representable}
	}
	\NoProof
	\\
	\Theorem{FreydRepresentabilityTheorem}
	{
		\forall \A : \mathsf{LSCAT} \And \TYPE{Complete} \.
		\forall F  : \TYPE{SolutionSetCondition}(\A,\SET) \. \NewLine \. 
		F : \TYPE{Representable}
	}
	\NoProof
	\\
	\DeclareType{KPresentable}{\prod \kappa : \TYPE{RegularCardinal} \.  ?(\mathsf{LSCAT} \And \TYPE{Cocomplete})}
	\DefineNamedType{\C}{KPresentable}{ \C : \kappa\hyph\TYPE{Presenable} }{
		 \exists S : ?\C : 
		 \forall C \in \C \.  
		 \exists (\I,D) : \TYPE{Diagram}(\C) : \NewLine : 
		 \im D \in S \And 
		 C = \colim_{i \in \I} D_i \And 
		 \forall  s \in S \.  
		 \Mor_\C(s,\cdot) : \TYPE{PreservesLimits}(\kappa\hyph\TYPE{Filtered})
	}
	\\
      \DeclareType{LocallyPresentable}{?(\mathsf{LSCAT} \And \TYPE{Cocomplete})}
      \DefineType{\C}{LocallyPresentable}{\exists \kappa : \TYPE{RegularCardinal} \. \C : \kappa\hyph\TYPE{Presentable}}
      \\
      \DeclareType{Accessible}{ \prod \A,\B : \kappa\hyph\TYPE{Presentable} \. ?(\A \Arrow{\CAT} \B)}
      \DefineType{F}{Accessible}{ F : \TYPE{PreserevesLimits}(\kappa\hyph \TYPE{Filtered})}
      \\
      \Theorem{FunctorBetweenLPCAdmitsRA}{ 
      		\forall \A, \B : \TYPE{LocallyPresentable} \.
		\forall F : \A \Arrow{\CAT} \B \. \NewLine
			\exists G : \B \Arrow{\CAT} \A :
			F \dashv G
		\iff
			F : \TYPE{Cocontinuous}
	}
     \NoProof
     \\
     \Theorem{FunctorBetweenLPCAdmitsLA}{
		\forall \A,\B : \TYPE{LocallYPresentable} \.
		\forall F : \A \Arrow{\CAT} \B \. \NewLine
			\exists G : \B \Arrow{\CAT} \A \. 
			G \dashv F
		\iff
			F : \TYPE{Continuous} \And \TYPE{Accessible}
     }
     \NoProof
}
\newpage
\section{Monads and Monoids}
\section{Kan Extension}
\end{document}
